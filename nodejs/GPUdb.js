/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
/**
 * Creates a GPUdb API object for the specified URL using the given options.
 * Once created, all options are immutable; to use a different URL or change
 * options, create a new instance. (Creating a new instance does not
 * communicate with the server and should not cause performance concerns.)
 *
 * @class
 * @classdesc GPUdb API object that provides access to GPUdb server functions.
 * @param {String|String[]} url The URL of the GPUdb server (e.g.,
 *                 <code>http://hostname:9191</code>). May also be specified as
 *                 a list of urls; all urls in the list must be well formed.
 * @param {Object} [options] A set of configurable options for the GPUdb API.
 * @param {String} [options.username] The username to be used for authentication
 *                 to GPUdb. This username will be sent with every GPUdb request
 *                 made via the API along with the specified password and may be
 *                 used for authorization decisions by the server if it is so
 *                 configured. If neither username nor password is specified, no
 *                 authentication will be performed.
 * @param {String} [options.password] The password to be used for authentication
 *                 to GPUdb. This password will be sent with every GPUdb request
 *                 made via the API along with the specified username and may be
 *                 used for authorization decisions by the server if it is so
 *                 configured. If neither username nor password is specified, no
 *                 authentication will be performed.
 * @param {Number} [options.timeout] The timeout value, in milliseconds, after
 *                 which requests to GPUdb will be aborted. A timeout value of
 *                 zero is interpreted as an infinite timeout. Note that timeout
 *                 is not suppored for synchronous requests, which will not
 *                 return until a response is received and cannot be aborted.
 */
function GPUdb(url, options) {
    /**
     * The URLs of the GPUdb servers.
     *
     * @name GPUdb#parsedUrls
     * @type ConnectionToken[]
     * @readonly
     */
    var urls = (url instanceof Array) ? url : [url];
    var parsedUrls = [];

    urls.forEach(function(elem, index, array) {
        var parsed_url = require("url").parse(elem);
        if (parsed_url.protocol !== "http:" && parsed_url.protocol !== "https:") {
            throw new Error("Invalid URL specified.");
        }

        parsedUrls.push(new GPUdb.ConnectionToken(parsed_url));
    });

    var initialIndex = Math.floor(Math.random() * urls.length);
    Object.defineProperty(this, "urls", {
        enumerable: true,
        value: new GPUdb.RingList(parsedUrls, initialIndex)
    });

    /**
     * The URL of the current GPUdb server.
     *
     * @name GPUdb#url
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "url", {
        get: function() {
            var token = this.urls.getCurrentItem();
            return token.protocol + '//' + token.host;
        },
        enumerable: true
    });

    /**
     * The protocol of the current GPUdb server address.
     *
     * @name GPUdb#protocol
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "protocol", {
        get: function() { return this.urls.getCurrentItem().protocol; },
        enumerable: true
    });

    /**
     * The hostname of the current GPUdb server.
     *
     * @name GPUdb#hostname
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "hostname", {
        get: function() { return this.urls.getCurrentItem().hostname; },
        enumerable: true
    });

    /**
     * The port of the current GPUdb server.
     *
     * @name GPUdb#port
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "port", {
        get: function() { return this.urls.getCurrentItem().port; },
        enumerable: true
    });

    /**
     * The pathname of the current GPUdb server.
     *
     * @name GPUdb#pathname
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "pathname", {
        get: function() { return this.urls.getCurrentItem().pathname; },
        enumerable: true
    });

    if (options !== undefined && options !== null) {
        /**
         * The username used for authentication to GPUdb. Will be an empty
         * string if none was provided to the {@link GPUdb GPUdb contructor}.
         *
         * @name GPUdb#username
         * @type String
         * @readonly
         */
        Object.defineProperty(this, "username", {
            enumerable: true,
            value: options.username !== undefined && options.username !== null ? options.username : ""
        });

        /**
         * The password used for authentication to GPUdb. Will be an empty
         * string if none was provided to the {@link GPUdb GPUdb constructor}.
         *
         * @name GPUdb#password
         * @type String
         * @readonly
         */
        Object.defineProperty(this, "password", {
            enumerable: true,
            value: options.password !== undefined && options.password !== null ? options.password : ""
        });

        /**
         * The timeout value, in milliseconds, after which requests to GPUdb
         * will be aborted. A timeout of zero is interpreted as an infinite
         * timeout. Will be zero if none was provided to the {@link GPUdb GPUdb
         * constructor}.
         *
         * @name GPUdb#timeout
         * @type Number
         * @readonly
         */
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            value: options.timeout !== undefined && options.timeout !== null && options.timeout >= 0 ? options.timeout : 0
        });

        /**
         * Function to get request cookie
         *
         * @name GPUdb#getCookie
         * @type Function
         * @readonly
         */
        Object.defineProperty(this, "getCookie", {
            enumerable: true,
            value: options.getCookie
        });

        /**
         * Function to set responce cookie
         *
         * @name GPUdb#setCookie
         * @type Function
         * @readonly
         */
        Object.defineProperty(this, "setCookie", {
            enumerable: true,
            value: options.setCookie
        });

    } else {
        Object.defineProperty( this, "username", { enumerable: true, value: "" } );
        Object.defineProperty( this, "password", { enumerable: true, value: "" } );
        Object.defineProperty( this, "timeout", { enumerable: true, value: 0 } );
    }

    if (this.username !== "" || this.password !== "") {
        Object.defineProperty(this, "authorization", {
            value: "Basic " + Buffer.from(this.username + ":" + this.password).toString("base64")
        });
    } else {
        Object.defineProperty(this, "authorization", { value: "" });
    }


    // Set the default value of the GPUdb#force_infinity_nan_conversion_to_null property
    this._force_infinity_nan_conversion_to_null = false;

    /*
     * The flag to indicate if quoted "Infinity", "-Infinity", and "NaN"
     * values returned by Kinetica will be converted to null.  Regular
     * Infinity, -Infinity, and NaN are automatically handled; but
     * the quoted versions need special handling that is an expensive
     * operation.  Default is false.
     *
     * @name GPUdb#force_infinity_nan_conversion_to_null
     * @type Boolean
     * @readonly
     */
    Object.defineProperty( this, "force_infinity_nan_conversion_to_null",
                           {
                               enumerable: true,
                               get: function() { return this._force_infinity_nan_conversion_to_null; },
                               set: function( newValue ) {
                                   // Value must be boolean
                                   if ( [true, false].indexOf( newValue ) == -1 ) {
                                       throw "Value must be true or false"; }

                                   // Only allow setting a boolean value
                                   this._force_infinity_nan_conversion_to_null = Boolean( newValue );
                               }
                           } );

    // Protected headers
    this._protected_headers = ["Accept", "Authorization", "Content-type", "Cookie", "X-Kinetica-Group"];

    // Custom headers set by users
    this._custom_http_headers = {};
    Object.defineProperty( this, "custom_http_headers",
                           {
                               enumerable: true,
                               get: function() { return this._custom_http_headers; },
                               set: function( value ) {
                                   // Value must be an object
                                   if ( typeof( value ) !== 'object' ) {
                                       throw "Value must be an object";
                                   }

                                   // Handle nulls (which are also objects)
                                   if ( value === null ) {
                                       return;
                                   }

                                   // Protected headers are not allowed to be overridden
                                   const headers = Object.keys( value );
                                   headers.forEach( (header, index) => {
                                       // Check this header against each of the protecetd ones
                                       if ( this._protected_headers.indexOf( header ) > -1 ) {
                                           throw `Cannot override protected header ${header}`;
                                       }
                                   } );

                                   this._custom_http_headers =  value;
                               }
                           }
                         );
} // end GPUdb


/**
 * Adds an HTTP header to the map of additional HTTP headers to send to
 * the server with each endpoint request.  If the header is already in the map,
 * its value is replaced with the specified value.  The user is not allowed
 * to modify the following headers:
 * <ul>
 *     <li>  'Accept'
 *     <li>  'Authorization'
 *     <li>  'Content-type'
 *     <li>  'X-Kinetica-Group'
 *  </ul>
 *
 * @param {String} header  The custom header to add.
 * @param {String} header  The value for the custom header to add.
 */
GPUdb.prototype.add_http_header = function( header, value ) {
    if ( ( header === undefined )
         || ( header === null )
         || ( ( typeof header !== 'string' )
              && !(header instanceof String) )
         || (header == "") ) {
        throw `Header ${header} must be a non-empty string!`;
    }

    // The value must also be a string
    // The header must be given and be a string (empty strings allowed)
    if ( ( value === undefined )
         || ( value === null )
         || ( ( typeof value !== 'string' )
              && !(value instanceof String) ) ) {
        throw `Value ${value} must be a string!`;
    }

    // Protected headers are not allowed to be overridden
    if ( this._protected_headers.indexOf( header ) > -1 ) {
        throw `Cannot override protected header ${header}`;
    }

    this._custom_http_headers[ header ] = value;
}  // end add_http_header



/**
 * Removes the given HTTP header from the map of additional HTTP headers
 * to send to GPUdb with each request. The user is not allowed to remove
 * the following protected headers:
 * <ul>
 *     <li>  'Accept'
 *     <li>  'Authorization'
 *     <li>  'Content-type'
 *     <li>  'X-Kinetica-Group'
 *  </ul>
 *
 * @param {String} header  The header to remove.
 */
GPUdb.prototype.remove_http_header = function( header ) {
    // Protected headers are not allowed to be overridden
    if ( this._protected_headers.indexOf( header ) > -1 ) {
        throw `Cannot remove protected header ${header}`;
    }

    // Can remove the header only if it exists!
    if ( header in this._custom_http_headers ) {
        delete this._custom_http_headers[ header ];
    }
}  // end remove_http_header


/**
 * Returns an object containing all the custom headers used currently
 * by the API.  Returns a deep copy so that the user does not
 * accidentally change the actual headers.  Note that the API may use other
 * headers as appropriate; the ones returned here are the custom ones set
 * up by the user.
 *
 * @returns {Object}  The object containing all the custom headers the
 *                    user has set up so far.
 */
GPUdb.prototype.get_http_headers = function() {
    // Return a deep copy
    return JSON.parse( JSON.stringify( this._custom_http_headers ) );
}  // end get_http_headers



/**
 * Sets the headers for the given request.
 *
 * @private
 * @param {String} The authorization string, if any.
 * @param {Object} A function for setting a cookie.
 * @param {Object} Pairs of key and value for custom HTTP headers.
 */
GPUdb.prototype._create_headers = function( authorization,
                                            getCookie,
                                            custom_headers ) {
    var headers = {};

    // JavaScript always uses JSON encoding
    headers[ "Content-type" ] = "application/json";

    // Use the class members if some arguments are missing
    if (authorization === undefined ) {
        authorization = this.authorization;
    }
    if (getCookie === undefined ) {
        getCookie = this.getCookie;
    }
    if (custom_headers === undefined ) {
        custom_headers = this._custom_http_headers;
    }

    // Set the authorization header only if username and password are set
    if (authorization !== "") {
        headers[ "Authorization" ] = authorization;
    }

    if (getCookie && typeof getCookie === "function") {
        headers["Cookie"] = getCookie();
    }

    // Set the custom headers
    for (let header in custom_headers) {
        headers[ header ] = custom_headers[ header ];
    }

    return headers;
}  // end _create_headers


module.exports = GPUdb;

/**
 * Wrapper struct to tie together the parsed url fields.
 * @private
 */
GPUdb.ConnectionToken = function(parsed_url) {
    Object.defineProperty(this, "protocol", { value: parsed_url.protocol });
    Object.defineProperty(this, "hostname", { value: parsed_url.hostname });
    Object.defineProperty(this, "port", { value: parsed_url.port });
    Object.defineProperty(this, "pathname", { value: parsed_url.pathname.replace(/\/$/, "") });
    Object.defineProperty(this, "host", { value: parsed_url.host });
}

/**
 * Equality helper for comparing instances.
 * @private
 * @param {ConnectionToken} other The instance to compare to.
 */
GPUdb.ConnectionToken.prototype.equals = function(other) {
    return this.host === other.host;
}

/**
 * Submits an arbitrary request to GPUdb. The response will be returned via the
 * specified callback function, or via a promise if no callback function is
 * provided.
 *
 * @param {String} endpoint The endpoint to which to submit the request.
 * @param {Object} request The request object to submit.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the response object,
 *                    if no callback function is provided.
 */
GPUdb.prototype.submit_request = function(endpoint, request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.submit_request(endpoint, request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var requestString = JSON.stringify(request);
    var initialConnToken = this.urls.getCurrentItem();
    var failureCount = 0;
    var timeout = this.timeout;
    var urls = this.urls;
    var authorization = this.authorization;
    var getCookie = this.getCookie;
    var setCookie = this.setCookie;
    var custom_headers  = this._custom_http_headers;
    var _create_headers = this._create_headers;

    /// Wraps the async callback with auto-retry logic
    var failureWrapperCB = function(err, data, url) {
        failureCount += 1;
        if (failureCount < urls.getSize()) {
            // If the current item has changed another request failed and
            // has already advanced the list. Retry using the new head.
            if ((url !== urls.getCurrentItem()) ||
                (!urls.getNextItem().equals(initialConnToken))) {
                sendRequest();
            }
        }
        else {
            callback(err, data);
        }
    };

    var that = this;
    var sendRequest = function() {
        var connToken = urls.getCurrentItem();

        if (connToken.protocol === "http:") {
            var http = require("http");
        } else {
            var http = require("https");
        }

        var headers = that._create_headers( authorization, getCookie,
                                            custom_headers );
        var got_error = false;

        var req = http.request({
            hostname: connToken.hostname,
            port: connToken.port,
            path: connToken.pathname + endpoint,
            method: "POST",
            headers: headers
        }, function(res) {
            var responseString = "";
            if (setCookie && typeof setCookie === "function") {
                setCookie(res.headers["set-cookie"]);
            }

            res.on("data", function(chunk) {
                responseString += chunk;
            });

            res.on("end", function() {
                if (got_error) {
                    return;
                }

                try {
                    var response = JSON.parse(responseString);
                } catch (e) {
                    callback(new Error("Unable to parse response: " + e), null);
                    return;
                }

                if (response.status === "OK") {
                    try {
                        var data = JSON.parse( response.data_str );
                    } catch (e) {
                        callback(new Error("Unable to parse response: " + e), null);
                        return;
                    }

                    if ("x-request-time-secs" in res.headers) {
                        data.request_time_secs = Number(res.headers["x-request-time-secs"]);
                    }

                    callback(null, data);
                } else {
                    callback(new Error(response.message), null);
                }
            });

            res.on("error", function(err) {
                got_error = true;
                failureWrapperCB(err, null, connToken);
            });
        });

        req.on("error", function(err) {
            got_error = true;
            failureWrapperCB(err, null, connToken);
        });

        req.setTimeout(timeout, function() {
            got_error = true;
            failureWrapperCB(new Error("Request timed out"), null, connToken);
        });

        req.write(requestString);
        req.end();
    };

    sendRequest();
};

/**
 * Request a WMS (Web Map Service) rasterized image. The image will be returned
 * as a Node.js Buffer object via the specified callback function, or via a
 * promise if no callback function is provided.
 *
 * @param {Object} request Object containing WMS parameters.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the image, if no
 *                    callback function is provided.
 */
GPUdb.prototype.wms_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.wms_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var queryString = require("querystring").stringify(request);
    var initialConnToken = this.urls.getCurrentItem();
    var failureCount = 0;
    var timeout = this.timeout;
    var urls = this.urls;
    var authorization = this.authorization;
    var getCookie = this.getCookie;
    var setCookie = this.setCookie;
    var custom_headers  = this._custom_http_headers;
    var _create_headers = this._create_headers;

    /// Wraps the async callback with auto-retry logic
    var failureWrapperCB = function(err, data, url) {
        failureCount += 1;
        if (failureCount < urls.getSize()) {
            // If the current item has changed another request failed and
            // has already advanced the list. Retry using the new head.
            if ((url !== urls.getCurrentItem()) ||
                (!urls.getNextItem().equals(initialConnToken))) {
                sendRequest();
            }
        }
        else {
            callback(err, data);
        }
    };

    var that = this;
    var sendRequest = function() {
        var connToken = urls.getCurrentItem();

        if (connToken.protocol === "http:") {
            var http = require("http");
        } else {
            var http = require("https");
        }

        var headers = that._create_headers( authorization, getCookie,
                                            custom_headers );
        var got_error = false;

        var req = http.request({
            hostname: connToken.hostname,
            port: connToken.port,
            path: connToken.pathname + "/wms?" + queryString,
            headers: headers,
        }, function(res) {
            var data = [];
            if (setCookie && typeof setCookie === "function") {
                setCookie(res.headers["set-cookie"]);
            }

            res.on("data", function(chunk) {
                data.push(chunk);
            });

            res.on("end", function() {
                if (got_error) {
                    return;
                }

                var result = Buffer.concat(data);

                if ("x-request-time-secs" in res.headers) {
                    result.request_time_secs = Number(res.headers["x-request-time-secs"]);
                }

                callback(null, result);
            });

            res.on("error", function(err) {
                got_error = true;
                failureWrapperCB(err, null, connToken);
            });
        });

        req.on("error", function(err) {
            got_error = true;
            failureWrapperCB(err, null, connToken);
        });

        req.setTimeout(timeout, function() {
            got_error = true;
            failureWrapperCB(new Error("Request timed out"), null, connToken);
        });

        req.end();
    };

    sendRequest();
}
/**
 * A list with only one exposed element at a time, but with N stored elements.
 * The elements of the list are immutable.
 * @private
 */
GPUdb.RingList = function(items, initialIndex) {
    Object.defineProperty(this, "items", { enumerable: true, value: items });
    Object.defineProperty(this, "index", {
        enumerable: true,
        value: (initialIndex !== undefined && initialIndex !== null &&
                initialIndex >= 0 ? initialIndex : 0),
        writable: true
    });
}

/**
 * @private
 * @return The currently exposed item
 */
GPUdb.RingList.prototype.getCurrentItem = function() {
    return this.items[this.index];
}

/**
 * Increments the current item index, wrapping if necessary.
 * @private
 * @return The currently exposed item
 */
GPUdb.RingList.prototype.getNextItem = function() {
    this.index += 1;
    if (this.index >= this.items.length) {
        this.index = 0;
    }

    return this.items[this.index];
}

/**
 * @private
 *
 * @return The number of elements available within the list.
 */
GPUdb.RingList.prototype.getSize = function() {
    return this.items.length;
}

/**
 * Callback function used for asynchronous GPUdb calls.
 *
 * @callback GPUdbCallback
 * @param {Error} err Object containing error information returned from the
 *                call. Will be null if no error occurred.
 * @param {Object} response Object containing any data returned from the call.
 *                 Will be null if an error occurred.
 */
/**
 * Creates a Type object containing metadata about a GPUdb type.
 *
 * @class
 * @classdesc Metadata about a GPUdb type.
 * @param {String} label A user-defined description string which can be used to
 *                 differentiate between data with otherwise identical schemas.
 * @param {...GPUdb.Type.Column} columns The list of columns that the type
 *                               comprises.
 */
GPUdb.Type = function(label, columns) {
    /**
     * A user-defined description string which can be used to differentiate
     * between data with otherwise identical schemas.
     *
     * @name GPUdb.Type#label
     * @type String
     */
    this.label = label;

    /**
     * The list of columns that the type comprises.
     *
     * @name GPUdb.Type#columns
     * @type GPUdb.Type.Column[]
     */
    if (Array.isArray(columns)) {
        this.columns = columns;
    } else {
        this.columns = [];

        for (var i = 1; i < arguments.length; i++) {
            this.columns.push(arguments[i]);
        }
    }
};

/**
 * Creates a Column object containing metadata about a column that is part of a
 * GPUdb type.
 *
 * @class
 * @classdesc Metadata about a column that is part of a GPUdb type.
 * @param {String} name The name of the column.
 * @param {String} type The data type of the column.
 * @param {...String} [properties] The list of properties that apply to the
 *                                 column; defaults to none.
 */
GPUdb.Type.Column = function(name, type, properties) {
    /**
     * The name of the column.
     *
     * @name GPUdb.Type.Column#name
     * @type String
     */
    this.name = name;

    /**
     * The data type of the column.
     *
     * @name GPUdb.Type.Column#type
     * @type String
     */
    this.type = type;

    /**
     * The list of properties that apply to the column.
     *
     * @name GPUdb.Type.Column#properties
     * @type String[]
     */
    if (properties !== undefined && properties !== null) {
        if (Array.isArray(properties)) {
            this.properties = properties;
        } else {
            this.properties = [];

            for (var i = 2; i < arguments.length; i++) {
                this.properties.push(arguments[i]);
            }
        }
    } else {
        this.properties = [];
    }
};

/**
 * Gets whether the column is nullable.
 *
 * @returns {boolean} Whether the column is nullable.
 */
GPUdb.Type.Column.prototype.is_nullable = function() {
    return this.properties.indexOf("nullable") > -1;
};

/**
 * Creates a Type object using data returned from the GPUdb show_table or
 * show_types endpoints.
 *
 * @param {String} label A user-defined description string which can be used to
 *                 differentiate between data with otherwise identical schemas.
 * @param {String|Object} type_schema The Avro record schema for the type.
 * @param {Object.<String, String[]>} properties A map of column names to
 *                                    lists of properties that apply to those
 *                                    columns.
 * @returns {GPUdb.Type} The Type object.
 */
GPUdb.Type.from_type_info = function(label, type_schema, properties) {
    if (typeof type_schema === "string" || type_schema instanceof String) {
        type_schema = JSON.parse(type_schema);
    }

    var columns = [];

    for (var i = 0; i < type_schema.fields.length; i++) {
        var field = type_schema.fields[i];
        var type = field.type;

        if (Array.isArray(type)) {
            for (var j = 0; j < type.length; j++) {
                if (type[j] !== "null") {
                    type = type[j];
                    break;
                }
            }
        }

        columns.push(new GPUdb.Type.Column(field.name, type, properties[field.name]));
    }

    return new GPUdb.Type(label, columns);
};

/**
 * Generates an Avro record schema based on the metadata in the Type object.
 *
 * @returns {Object} The Avro record schema.
 */
GPUdb.Type.prototype.generate_schema = function() {
    var schema = {
        type: "record",
        name: "type_name",
        fields: []
    };

    for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];

        schema.fields.push({
            name: column.name,
            type: column.is_nullable() ? [ column.type, "null" ] : column.type
        });
    }

    return schema;
};

/**
 * The version number of the GPUdb JavaScript API.
 *
 * @name GPUdb#api_version
 * @type String
 * @readonly
 * @static
 */
Object.defineProperty(GPUdb, "api_version", { enumerable: true, value: "7.1.6.0" });

/**
 * Constant used with certain requests to indicate that the maximum allowed
 * number of results should be returned.
 *
 * @name GPUdb#END_OF_SET
 * @type Number
 * @readonly
 * @static
 */
Object.defineProperty(GPUdb, "END_OF_SET", { value: -9999 });


/**
 * Decodes a JSON string, or array of JSON strings, returned from GPUdb into
 * JSON object(s).
 *
 * @param {String | String[]} o The JSON string(s) to decode.
 * @returns {Object | Object[]} The decoded JSON object(s).
 */
GPUdb.decode = function(o) {
    if (Array.isArray(o)) {
        var result = [];

        for (var i = 0; i < o.length; i++) {
            result.push(GPUdb.decode(o[i]));
        }

        return result;
    } else {
        return JSON.parse(o);
    }
};



/**
 * Decodes a JSON string, or array of JSON strings, returned from GPUdb into
 * JSON object(s).
 *
 * @param {String | String[]} o The JSON string(s) to decode.
 * @returns {Object | Object[]} The decoded JSON object(s).
 */
GPUdb.prototype.decode = function(o) {
    // Force quoted "Infinity", "-Infinity", and "NaN" to be converted
    // to null
    if ( this.force_infinity_nan_conversion_to_null === true ) {
        return GPUdb.decode_no_inf_nan( o );
    }

    // Regular conversion, no special transformation needed
    return GPUdb.decode_regular( o );
};


/**
 * Decodes a JSON string, or array of JSON strings, returned from GPUdb into
 * JSON object(s).
 *
 * @param {String | String[]} o The JSON string(s) to decode.
 * @returns {Object | Object[]} The decoded JSON object(s).
 */
GPUdb.decode_regular = function(o) {
    if (Array.isArray(o)) {
        var result = [];

        for (var i = 0; i < o.length; i++) {
            result.push( GPUdb.decode_regular(o[i]) );
        }

        return result;
    } else {
        return JSON.parse(o);
    }
};


/**
 * Decodes a JSON string, or array of JSON strings, returned from GPUdb into
 * JSON object(s).  Special treatment for quoted "Infinity", "-Infinity",
 * and "NaN".  Catches those and converts to null.  This is significantly
 * slower than the regular decode function.
 *
 * @param {String | String[]} o The JSON string(s) to decode.
 * @returns {Object | Object[]} The decoded JSON object(s).
 */
GPUdb.decode_no_inf_nan = function(o) {
    if (Array.isArray(o)) {
        var result = [];

        for (var i = 0; i < o.length; i++) {
            result.push( GPUdb.decode_no_inf_nan( o[i] ) );
        }

        return result;
    } else {
        // Check for
        return JSON.parse( o, function(k, v) {
            if (v === "Infinity") return null;
            else if (v === "-Infinity") return null;
            else if (v === "NaN") return null;
            else return v;
        } );
    }
};


/**
 * Encodes a JSON object, or array of JSON objects, into JSON string(s) to be
 * passed to GPUdb.
 *
 * @param {Object | Object[]} o The JSON object(s) to encode.
 * @returns {String | String[]} The encoded JSON string(s).
 */
GPUdb.encode = function(o) {
    if (Array.isArray(o)) {
        var result = [];

        for (var i = 0; i < o.length; i++) {
            result.push(GPUdb.encode(o[i]));
        }

        return result;
    } else {
        return JSON.stringify(o);
    }
};
/**
 * Creates a Type object containing metadata about the type stored in the
 * specified table in GPUdb and returns it via the specified callback function,
 * or via a promise if no callback function is provided.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {String} table_name The table from which to obtain type metadata.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type object, if
 *                    no callback function is provided.
 */
GPUdb.Type.from_table = function(gpudb, table_name, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.from_table(gpudb, table_name, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var process_response = function(response, callback) {
        if (response.type_ids.length === 0) {
            callback(new Error("Table " + table_name + " does not exist."), null);
        }

        if (response.type_ids.length > 1) {
            var type_id = response.type_ids[0];

            for (var i = 1; i < response.type_ids.length; i++) {
                if (response.type_ids[i] !== type_id) {
                    callback(new Error("Table " + table_name + " is not homogeneous."), null);
                }
            }
        }

        callback(null, GPUdb.Type.from_type_info(response.type_labels[0], response.type_schemas[0], response.properties[0]));
    };

    gpudb.show_table(table_name, {}, function(err, data) {
        if (err === null) {
            process_response(data, callback);
        } else {
            callback(err, null);
        }
    });
};

/**
 * Creates a Type object containing metadata about the specified type in GPUdb
 * and returns it via the specified callback function, or via a promise if no
 * callback function is provided.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {String} type_id The type for which to obtain metadata.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type object, if
 *                    no callback function is provided.
 */
GPUdb.Type.from_type = function(gpudb, type_id, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.from_type(gpudb, type_id, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var process_response = function(response, callback) {
        if (response.type_ids.length === 0) {
            callback(Error("Type " + type_id + " does not exist."), null);
        }

        callback(null, GPUdb.Type.from_type_info(response.labels[0], response.type_schemas[0], response.properties[0]));
    };

    gpudb.show_types(type_id, "", {}, function(err, data) {
        if (err === null) {
            process_response(data, callback);
        } else {
            callback(err, null);
        }
    });
};

/**
 * Creates a new type in GPUdb based on the metadata in the Type object and
 * returns the GPUdb type ID via the specified callback function, or via a
 * promise if no callback function is provided, for use in subsequent
 * operations.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type ID, if no
 *                    callback function is provided.
 */
GPUdb.Type.prototype.create = function(gpudb, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.create(gpudb, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var properties = {};

    for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];

        if (column.properties.length > 0) {
            properties[column.name] = column.properties;
        }
    }

    gpudb.create_type(JSON.stringify(this.generate_schema()), this.label, properties, {}, function(err, data) {
        if (err === null) {
            callback(null, data.type_id);
        } else {
            callback(err, null);
        }
    });
};


/**
 * Retrieves records from a given table as a GeoJSON, optionally filtered by an expression
 * and/or sorted by a column. This operation can be performed on tables, views,
 * or on homogeneous collections (collections containing tables of all the same
 * type). Records can be returned encoded as binary, json or geojson.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and <code>limit</code> parameters. Note that when paging through a table, if
 * the table (or the underlying table in case of a view) is updated (records
 * are inserted, deleted or modified) the records retrieved may differ between
 * calls based on the updates applied.
 *
 * @param {String} table_name  Name of the table from which the records will be
 *                             fetched. Must be a table, view or homogeneous
 *                             collection.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned. Or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'expression': Optional filter
 *                          expression to apply to the table.
 *                                  <li> 'fast_index_lookup': Indicates if
 *                          indexes should be used to perform the lookup for a
 *                          given expression if possible. Only applicable if
 *                          there is no sorting, the expression contains only
 *                          equivalence comparisons based on existing tables
 *                          indexes and the range of requested values is from
 *                          [0 to END_OF_SET].
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'sort_by': Optional column that the
 *                          data should be sorted by. Empty by default (i.e. no
 *                          sorting is applied).
 *                                  <li> 'sort_order': String indicating how
 *                          the returned values should be sorted - ascending or
 *                          descending. If sort_order is provided, sort_by has
 *                          to be provided.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'ascending'
 *                                  <li> 'descending'
 *                          </ul>
 *                          The default value is 'ascending'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the GeoJSON
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_geo_json = function(table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_geo_json(table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "geojson",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records", actual_request, function(err, data) {
        if (err === null) {
            var geo_json = GPUdb.decode( data.records_json )[0];
            // Return just the GeoJSON
            callback(err, geo_json);
        }
        else {
            // There was an error, so nothing to decode
            callback(err, data);
        }
    });
};



/**
 * Adds a host to an existing cluster.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_add_host_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_add_host_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        host_address: request.host_address,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/add/host", actual_request, callback);
};

/**
 * Adds a host to an existing cluster.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String} host_address  IP address of the host that will be added to
 *                               the cluster. This host must have installed the
 *                               same version of Kinetica as the cluster to
 *                               which it is being added.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'dry_run': If set to
 *                          <code>true</code>, only validation checks will be
 *                          performed. No host is added.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'accepts_failover': If set to
 *                          <code>true</code>, the host will accept processes
 *                          (ranks, graph server, etc.) in the event of a
 *                          failover on another node in the cluster. See <a
 *                          href="../../../n_plus_1/" target="_top">Cluster
 *                          Resilience</a> for more information.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'public_address': The
 *                          publicly-accessible IP address for the host being
 *                          added, typically specified for clients using
 *                          multi-head operations. This setting is required if
 *                          any other host(s) in the cluster specify a public
 *                          address.
 *                                  <li> 'host_manager_public_url': The
 *                          publicly-accessible full path URL to the host
 *                          manager on the host being added, e.g.,
 *                          'http://172.123.45.67:9300'. The default host
 *                          manager port can be found in the <a
 *                          href="../../../install/shared/ports/"
 *                          target="_top">list of ports</a> used by Kinetica.
 *                                  <li> 'ram_limit': The desired RAM limit for
 *                          the host being added, i.e. the sum of RAM usage for
 *                          all processes on the host will not be able to
 *                          exceed this value. Supported units: K (thousand),
 *                          KB (kilobytes), M (million), MB (megabytes), G
 *                          (billion), GB (gigabytes); if no unit is provided,
 *                          the value is assumed to be in bytes. For example,
 *                          if <code>ram_limit</code> is set to 10M, the
 *                          resulting RAM limit is 10 million bytes. Set
 *                          <code>ram_limit</code> to -1 to have no RAM limit.
 *                                  <li> 'gpus': Comma-delimited list of GPU
 *                          indices (starting at 1) that are eligible for
 *                          running worker processes. If left blank, all GPUs
 *                          on the host being added will be eligible.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_add_host = function(host_address, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_add_host(host_address, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        host_address: host_address,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/add/host", actual_request, callback);
};

/**
 * Add one or more ranks to an existing Kinetica cluster. The new ranks will
 * not contain any data initially (other than replicated tables) and will not
 * be assigned any shards. To rebalance data and shards across the cluster, use
 * {@linkcode GPUdb#admin_rebalance}.
 * <p>
 * The database must be offline for this operation, see
 * {@linkcode GPUdb#admin_offline}
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * <code>hosts</code>
 *   would be an array including 172.123.45.67 in the first two indices
 *   (signifying two ranks being added to host 172.123.45.67) and
 *   172.123.45.68 in the last index (signifying one rank being added
 *   to host 172.123.45.67)
 * * <code>config_params</code>
 *   would be an array of maps, with each map corresponding to the ranks
 *   being added in <code>hosts</code>. The key of each map would be
 *   the configuration parameter name and the value would be the
 *   parameter's value, e.g. '{"rank.gpu":"1"}'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@linkcode GPUdb#create_job}.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_add_ranks_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_add_ranks_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        hosts: request.hosts,
        config_params: request.config_params,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/add/ranks", actual_request, callback);
};

/**
 * Add one or more ranks to an existing Kinetica cluster. The new ranks will
 * not contain any data initially (other than replicated tables) and will not
 * be assigned any shards. To rebalance data and shards across the cluster, use
 * {@linkcode GPUdb#admin_rebalance}.
 * <p>
 * The database must be offline for this operation, see
 * {@linkcode GPUdb#admin_offline}
 * <p>
 * For example, if attempting to add three new ranks (two ranks on host
 * 172.123.45.67 and one rank on host 172.123.45.68) to a Kinetica cluster with
 * additional configuration parameters:
 * <p>
 * * <code>hosts</code>
 *   would be an array including 172.123.45.67 in the first two indices
 *   (signifying two ranks being added to host 172.123.45.67) and
 *   172.123.45.68 in the last index (signifying one rank being added
 *   to host 172.123.45.67)
 * * <code>config_params</code>
 *   would be an array of maps, with each map corresponding to the ranks
 *   being added in <code>hosts</code>. The key of each map would be
 *   the configuration parameter name and the value would be the
 *   parameter's value, e.g. '{"rank.gpu":"1"}'
 * <p>
 * This endpoint's processing includes copying all replicated table data to the
 * new rank(s) and therefore could take a long time. The API call may time out
 * if run directly.  It is recommended to run this endpoint asynchronously via
 * {@linkcode GPUdb#create_job}.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String[]} hosts  Array of host IP addresses (matching a
 *                          hostN.address from the gpudb.conf file), or host
 *                          identifiers (e.g. 'host0' from the gpudb.conf
 *                          file), on which to add ranks to the cluster. The
 *                          hosts must already be in the cluster. If needed
 *                          beforehand, to add a new host to the cluster use
 *                          {@linkcode GPUdb#admin_add_host}. Include the
 *                          same entry as many times as there are ranks to add
 *                          to the cluster, e.g., if two ranks on host
 *                          172.123.45.67 should be added, <code>hosts</code>
 *                          could look like '["172.123.45.67",
 *                          "172.123.45.67"]'. All ranks will be added
 *                          simultaneously, i.e. they're not added in the order
 *                          of this array. Each entry in this array corresponds
 *                          to the entry at the same index in the
 *                          <code>config_params</code>.
 * @param {Object[]} config_params  Array of maps containing configuration
 *                                  parameters to apply to the new ranks
 *                                  found in <code>hosts</code>. For example,
 *                                  '{"rank.gpu":"2",
 *                                  "tier.ram.rank.limit":"10000000000"}'.
 *                                  Currently, the available parameters
 *                                  are rank-specific parameters in the <a
 *                                  href="../../../config/#config-main-network"
 *                                  target="_top">Network</a>,
 *                                  <a
 *                                  href="../../../config/#config-main-hardware"
 *                                  target="_top">Hardware</a>,
 *                                  <a
 *                                  href="../../../config/#config-main-text-search"
 *                                  target="_top">Text Search</a>, and
 *                                  <a
 *                                  href="../../../config/#config-main-ram-tier"
 *                                  target="_top">RAM Tiered Storage</a>
 *                                  sections in the gpudb.conf file, with the
 *                                  key exception of the 'rankN.host' settings
 *                                  in the Network section that will be
 *                                  determined by
 *                                  <code>hosts</code> instead. Though many of
 *                                  these configuration parameters typically
 *                                  are affixed with
 *                                  'rankN' in the gpudb.conf file (where N is
 *                                  the rank number), the 'N' should be omitted
 *                                  in
 *                                  <code>config_params</code> as the new rank
 *                                  number(s) are not allocated until the ranks
 *                                  have been added
 *                                  to the cluster. Each entry in this array
 *                                  corresponds to the entry at the same index
 *                                  in the
 *                                  <code>hosts</code>. This array must either
 *                                  be completely empty or have the same number
 *                                  of elements as
 *                                  the <code>hosts</code>.  An empty
 *                                  <code>config_params</code> array will
 *                                  result in the new ranks being set
 *                                  with default parameters.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'dry_run': If <code>true</code>, only
 *                          validation checks will be performed. No ranks are
 *                          added.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_add_ranks = function(hosts, config_params, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_add_ranks(hosts, config_params, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        hosts: hosts,
        config_params: config_params,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/add/ranks", actual_request, callback);
};

/**
 * Alter properties on an existing host in the cluster. Currently, the only
 * property that can be altered is a hosts ability to accept failover
 * processes.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_alter_host_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_alter_host_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        host: request.host,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/alter/host", actual_request, callback);
};

/**
 * Alter properties on an existing host in the cluster. Currently, the only
 * property that can be altered is a hosts ability to accept failover
 * processes.
 *
 * @param {String} host  Identifies the host this applies to. Can be the host
 *                       address, or formatted as 'hostN' where N is the host
 *                       number as specified in gpudb.conf
 * @param {Object} options  Optional parameters
 *                          <ul>
 *                                  <li> 'accepts_failover': If set to
 *                          <code>true</code>, the host will accept processes
 *                          (ranks, graph server, etc.) in the event of a
 *                          failover on another node in the cluster. See <a
 *                          href="../../../n_plus_1/" target="_top">Cluster
 *                          Resilience</a> for more information.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_alter_host = function(host, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_alter_host(host, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        host: host,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/alter/host", actual_request, callback);
};

/**
 * Perform the requested action on a list of one or more job(s). Based
 * on the type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See
 * <a href="../../../admin/job_manager/" target="_top">Job Manager</a> for more
 * information.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_alter_jobs_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_alter_jobs_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        job_ids: request.job_ids,
        action: request.action,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/alter/jobs", actual_request, callback);
};

/**
 * Perform the requested action on a list of one or more job(s). Based
 * on the type of job and the current state of execution, the action may not be
 * successfully executed. The final result of the attempted actions for each
 * specified job is returned in the status array of the response. See
 * <a href="../../../admin/job_manager/" target="_top">Job Manager</a> for more
 * information.
 *
 * @param {Number[]} job_ids  Jobs to be modified.
 * @param {String} action  Action to be performed on the jobs specified by
 *                         job_ids.
 *                         Supported values:
 *                         <ul>
 *                                 <li> 'cancel'
 *                         </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'job_tag': Job tag returned in call to
 *                          create the job
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_alter_jobs = function(job_ids, action, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_alter_jobs(job_ids, action, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        job_ids: job_ids,
        action: action,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/alter/jobs", actual_request, callback);
};

/**
 * Prepares the system for a backup by closing all open file handles after
 * allowing current active jobs to complete. When the database is in backup
 * mode, queries that result in a disk write operation will be blocked until
 * backup mode has been completed by using
 * {@linkcode GPUdb#admin_backup_end}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_backup_begin_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_backup_begin_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/backup/begin", actual_request, callback);
};

/**
 * Prepares the system for a backup by closing all open file handles after
 * allowing current active jobs to complete. When the database is in backup
 * mode, queries that result in a disk write operation will be blocked until
 * backup mode has been completed by using
 * {@linkcode GPUdb#admin_backup_end}.
 *
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_backup_begin = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_backup_begin(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/backup/begin", actual_request, callback);
};

/**
 * Restores the system to normal operating mode after a backup has completed,
 * allowing any queries that were blocked to complete.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_backup_end_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_backup_end_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/backup/end", actual_request, callback);
};

/**
 * Restores the system to normal operating mode after a backup has completed,
 * allowing any queries that were blocked to complete.
 *
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_backup_end = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_backup_end(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/backup/end", actual_request, callback);
};

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_offline_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_offline_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        offline: request.offline,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/offline", actual_request, callback);
};

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 *
 * @param {Boolean} offline  Set to true if desired state is offline.
 *                           Supported values:
 *                           <ul>
 *                                   <li> true
 *                                   <li> false
 *                           </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'flush_to_disk': Flush to disk when
 *                          going offline
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_offline = function(offline, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_offline(offline, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        offline: offline,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/offline", actual_request, callback);
};

/**
 * Rebalance the data in the cluster so that all nodes contain an equal
 * number of records approximately and/or rebalance the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * The database must be offline for this operation, see
 * {@linkcode GPUdb#admin_offline}
 * <p>
 * * If {@linkcode GPUdb#admin_rebalance} is invoked after a change is
 *   made to the cluster, e.g., a host was added or removed,
 *   <a href="../../../concepts/tables/#sharding" target="_top">sharded
 * data</a> will be
 *   evenly redistributed across the cluster by number of shards per rank
 *   while unsharded data will be redistributed across the cluster by data
 *   size per rank
 * * If {@linkcode GPUdb#admin_rebalance}
 *   is invoked at some point when unsharded data (a.k.a.
 *   <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>)
 *   in the cluster is unevenly distributed over time, sharded data will
 *   not move while unsharded data will be redistributed across the
 *   cluster by data size per rank
 * <p>
 * NOTE: Replicated data will not move as a result of this call
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@linkcode GPUdb#create_job}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_rebalance_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_rebalance_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/rebalance", actual_request, callback);
};

/**
 * Rebalance the data in the cluster so that all nodes contain an equal
 * number of records approximately and/or rebalance the shards to be equally
 * distributed (as much as possible) across all the ranks.
 * <p>
 * The database must be offline for this operation, see
 * {@linkcode GPUdb#admin_offline}
 * <p>
 * * If {@linkcode GPUdb#admin_rebalance} is invoked after a change is
 *   made to the cluster, e.g., a host was added or removed,
 *   <a href="../../../concepts/tables/#sharding" target="_top">sharded
 * data</a> will be
 *   evenly redistributed across the cluster by number of shards per rank
 *   while unsharded data will be redistributed across the cluster by data
 *   size per rank
 * * If {@linkcode GPUdb#admin_rebalance}
 *   is invoked at some point when unsharded data (a.k.a.
 *   <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>)
 *   in the cluster is unevenly distributed over time, sharded data will
 *   not move while unsharded data will be redistributed across the
 *   cluster by data size per rank
 * <p>
 * NOTE: Replicated data will not move as a result of this call
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@linkcode GPUdb#create_job}.
 *
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'rebalance_sharded_data': If
 *                          <code>true</code>, <a
 *                          href="../../../concepts/tables/#sharding"
 *                          target="_top">sharded data</a> will be rebalanced
 *                          approximately equally across the cluster. Note that
 *                          for clusters with large amounts of sharded data,
 *                          this data transfer could be time consuming and
 *                          result in delayed query responses.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'rebalance_unsharded_data': If
 *                          <code>true</code>, unsharded data (a.k.a. <a
 *                          href="../../../concepts/tables/#random-sharding"
 *                          target="_top">randomly-sharded</a>) will be
 *                          rebalanced approximately equally across the
 *                          cluster. Note that for clusters with large amounts
 *                          of unsharded data, this data transfer could be time
 *                          consuming and result in delayed query responses.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'table_includes': Comma-separated list
 *                          of unsharded table names to rebalance. Not
 *                          applicable to sharded tables because they are
 *                          always rebalanced. Cannot be used simultaneously
 *                          with <code>table_excludes</code>. This parameter is
 *                          ignored if <code>rebalance_unsharded_data</code> is
 *                          <code>false</code>.
 *                                  <li> 'table_excludes': Comma-separated list
 *                          of unsharded table names to not rebalance. Not
 *                          applicable to sharded tables because they are
 *                          always rebalanced. Cannot be used simultaneously
 *                          with <code>table_includes</code>. This parameter is
 *                          ignored if <code>rebalance_unsharded_data</code> is
 *                          <code>false</code>.
 *                                  <li> 'aggressiveness': Influences how much
 *                          data is moved at a time during rebalance.  A higher
 *                          <code>aggressiveness</code> will complete the
 *                          rebalance faster.  A lower
 *                          <code>aggressiveness</code> will take longer but
 *                          allow for better interleaving between the rebalance
 *                          and other queries. Valid values are constants from
 *                          1 (lowest) to 10 (highest).  The default value is
 *                          '10'.
 *                                  <li> 'compact_after_rebalance': Perform
 *                          compaction of deleted records once the rebalance
 *                          completes to reclaim memory and disk space. Default
 *                          is <code>true</code>, unless
 *                          <code>repair_incorrectly_sharded_data</code> is set
 *                          to <code>true</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'compact_only': If set to
 *                          <code>true</code>, ignore rebalance options and
 *                          attempt to perform compaction of deleted records to
 *                          reclaim memory and disk space without rebalancing
 *                          first.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'repair_incorrectly_sharded_data':
 *                          Scans for any data sharded incorrectly and
 *                          re-routes the data to the correct location. Only
 *                          necessary if {@linkcode GPUdb#admin_verify_db}
 *                          reports an error in sharding alignment. This can be
 *                          done as part of a typical rebalance after expanding
 *                          the cluster or in a standalone fashion when it is
 *                          believed that data is sharded incorrectly somewhere
 *                          in the cluster. Compaction will not be performed by
 *                          default when this is enabled. If this option is set
 *                          to <code>true</code>, the time necessary to
 *                          rebalance and the memory used by the rebalance may
 *                          increase.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_rebalance = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_rebalance(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/rebalance", actual_request, callback);
};

/**
 * Removes a host from an existing cluster. If the host to be removed has any
 * ranks running on it, the ranks must be removed using
 * {@linkcode GPUdb#admin_remove_ranks} or manually switched over to a new
 * host using {@linkcode GPUdb#admin_switchover} prior to host removal. If
 * the host to be removed has the graph server or SQL planner running on it,
 * these must be manually switched over to a new host using
 * {@linkcode GPUdb#admin_switchover}.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_remove_host_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_remove_host_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        host: request.host,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/remove/host", actual_request, callback);
};

/**
 * Removes a host from an existing cluster. If the host to be removed has any
 * ranks running on it, the ranks must be removed using
 * {@linkcode GPUdb#admin_remove_ranks} or manually switched over to a new
 * host using {@linkcode GPUdb#admin_switchover} prior to host removal. If
 * the host to be removed has the graph server or SQL planner running on it,
 * these must be manually switched over to a new host using
 * {@linkcode GPUdb#admin_switchover}.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String} host  Identifies the host this applies to. Can be the host
 *                       address, or formatted as 'hostN' where N is the host
 *                       number as specified in gpudb.conf
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'dry_run': If set to
 *                          <code>true</code>, only validation checks will be
 *                          performed. No host is removed.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_remove_host = function(host, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_remove_host(host, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        host: host,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/remove/host", actual_request, callback);
};

/**
 * Remove one or more ranks from an existing Kinetica cluster. All data
 * will be rebalanced to other ranks before the rank(s) is removed unless the
 * <code>rebalance_sharded_data</code> or
 * <code>rebalance_unsharded_data</code> parameters are set to
 * <code>false</code> in the
 * <code>options</code>, in which case the corresponding
 * <a href="../../../concepts/tables/#sharding" target="_top">sharded data</a>
 * and/or unsharded data (a.k.a.
 * <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>) will be deleted.
 * <p>
 * The database must be offline for this operation, see
 * {@linkcode GPUdb#admin_offline}
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@linkcode GPUdb#create_job}.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_remove_ranks_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_remove_ranks_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        ranks: request.ranks,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/remove/ranks", actual_request, callback);
};

/**
 * Remove one or more ranks from an existing Kinetica cluster. All data
 * will be rebalanced to other ranks before the rank(s) is removed unless the
 * <code>rebalance_sharded_data</code> or
 * <code>rebalance_unsharded_data</code> parameters are set to
 * <code>false</code> in the
 * <code>options</code>, in which case the corresponding
 * <a href="../../../concepts/tables/#sharding" target="_top">sharded data</a>
 * and/or unsharded data (a.k.a.
 * <a href="../../../concepts/tables/#random-sharding"
 * target="_top">randomly-sharded</a>) will be deleted.
 * <p>
 * The database must be offline for this operation, see
 * {@linkcode GPUdb#admin_offline}
 * <p>
 * This endpoint's processing time depends on the amount of data in the system,
 * thus the API call may time out if run directly.  It is recommended to run
 * this
 * endpoint asynchronously via {@linkcode GPUdb#create_job}.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String[]} ranks  Each array value designates one or more ranks to
 *                          remove from the cluster. Values can be formatted as
 *                          'rankN' for a specific rank, 'hostN' (from the
 *                          gpudb.conf file) to remove all ranks on that host,
 *                          or the host IP address (hostN.address from the
 *                          gpub.conf file) which also removes all ranks on
 *                          that host. Rank 0 (the head rank) cannot be removed
 *                          (but can be moved to another host using
 *                          {@linkcode GPUdb#admin_switchover}). At least one
 *                          worker rank must be left in the cluster after the
 *                          operation.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'rebalance_sharded_data': If
 *                          <code>true</code>, <a
 *                          href="../../../concepts/tables/#sharding"
 *                          target="_top">sharded data</a> will be rebalanced
 *                          approximately equally across the cluster. Note that
 *                          for clusters with large amounts of sharded data,
 *                          this data transfer could be time consuming and
 *                          result in delayed query responses.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'rebalance_unsharded_data': If
 *                          <code>true</code>, unsharded data (a.k.a. <a
 *                          href="../../../concepts/tables/#random-sharding"
 *                          target="_top">randomly-sharded</a>) will be
 *                          rebalanced approximately equally across the
 *                          cluster. Note that for clusters with large amounts
 *                          of unsharded data, this data transfer could be time
 *                          consuming and result in delayed query responses.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'aggressiveness': Influences how much
 *                          data is moved at a time during rebalance.  A higher
 *                          <code>aggressiveness</code> will complete the
 *                          rebalance faster.  A lower
 *                          <code>aggressiveness</code> will take longer but
 *                          allow for better interleaving between the rebalance
 *                          and other queries. Valid values are constants from
 *                          1 (lowest) to 10 (highest).  The default value is
 *                          '10'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_remove_ranks = function(ranks, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_remove_ranks(ranks, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        ranks: ranks,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/remove/ranks", actual_request, callback);
};

/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_show_alerts_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_show_alerts_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        num_alerts: request.num_alerts,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/show/alerts", actual_request, callback);
};

/**
 * Requests a list of the most recent alerts.
 * Returns lists of alert data, including timestamp and type.
 *
 * @param {Number} num_alerts  Number of most recent alerts to request. The
 *                             response will include up to
 *                             <code>num_alerts</code> depending on how many
 *                             alerts there are in the system. A value of 0
 *                             returns all stored alerts.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_show_alerts = function(num_alerts, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_show_alerts(num_alerts, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        num_alerts: num_alerts,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/show/alerts", actual_request, callback);
};

/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by <code>history_index</code>.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_show_cluster_operations_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_show_cluster_operations_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        history_index: (request.history_index !== undefined && request.history_index !== null) ? request.history_index : 0,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/show/cluster/operations", actual_request, callback);
};

/**
 * Requests the detailed status of the current operation (by default) or a
 * prior cluster operation specified by <code>history_index</code>.
 * Returns details on the requested cluster operation.
 * <p>
 * The response will also indicate how many cluster operations are stored in
 * the history.
 *
 * @param {Number} history_index  Indicates which cluster operation to
 *                                retrieve.  Use 0 for the most recent.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_show_cluster_operations = function(history_index, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_show_cluster_operations(history_index, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        history_index: (history_index !== undefined && history_index !== null) ? history_index : 0,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/show/cluster/operations", actual_request, callback);
};

/**
 * Get a list of the current jobs in GPUdb.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_show_jobs_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_show_jobs_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/show/jobs", actual_request, callback);
};

/**
 * Get a list of the current jobs in GPUdb.
 *
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'show_async_jobs': If
 *                          <code>true</code>, then the completed async jobs
 *                          are also included in the response. By default, once
 *                          the async jobs are completed they are no longer
 *                          included in the jobs list.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_show_jobs = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_show_jobs(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/show/jobs", actual_request, callback);
};

/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_show_shards_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_show_shards_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/show/shards", actual_request, callback);
};

/**
 * Show the mapping of shards to the corresponding rank and tom.  The response
 * message contains list of 16384 (total number of shards in the system) Rank
 * and TOM numbers corresponding to each shard.
 *
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_show_shards = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_show_shards(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/show/shards", actual_request, callback);
};

/**
 * Exits the database server application.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_shutdown_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_shutdown_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        exit_type: request.exit_type,
        authorization: request.authorization,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/shutdown", actual_request, callback);
};

/**
 * Exits the database server application.
 *
 * @param {String} exit_type  Reserved for future use. User can pass an empty
 *                            string.
 * @param {String} authorization  No longer used. User can pass an empty
 *                                string.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_shutdown = function(exit_type, authorization, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_shutdown(exit_type, authorization, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        exit_type: exit_type,
        authorization: authorization,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/shutdown", actual_request, callback);
};

/**
 * Manually switch over one or more processes to another host. Individual ranks
 * or entire hosts may be moved to another host.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_switchover_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_switchover_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        processes: request.processes,
        destinations: request.destinations,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/switchover", actual_request, callback);
};

/**
 * Manually switch over one or more processes to another host. Individual ranks
 * or entire hosts may be moved to another host.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String[]} processes  Indicates the process identifier to switch over
 *                              to another host. Options are
 *                              'hostN' and 'rankN' where 'N' corresponds to
 *                              the number associated with a host or rank in
 *                              the
 *                              <a href="../../../config/#config-main-network"
 *                              target="_top">Network</a> section of the
 *                              gpudb.conf file; e.g.,
 *                              'host[N].address' or 'rank[N].host'. If 'hostN'
 *                              is provided, all processes on that host will be
 *                              moved to another host. Each entry in this array
 *                              will be switched over to the corresponding host
 *                              entry at the same index in
 *                              <code>destinations</code>.
 * @param {String[]} destinations  Indicates to which host to switch over each
 *                                 corresponding process given in
 *                                 <code>processes</code>. Each index must be
 *                                 specified as 'hostN' where 'N' corresponds
 *                                 to the number
 *                                 associated with a host or rank in the <a
 *                                 href="../../../config/#config-main-network"
 *                                 target="_top">Network</a> section of the
 *                                 gpudb.conf file; e.g., 'host[N].address'.
 *                                 Each entry in this array will receive the
 *                                 corresponding
 *                                 process entry at the same index in
 *                                 <code>processes</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'dry_run': If set to
 *                          <code>true</code>, only validation checks will be
 *                          performed. Nothing is switched over.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_switchover = function(processes, destinations, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_switchover(processes, destinations, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        processes: processes,
        destinations: destinations,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/switchover", actual_request, callback);
};

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_verify_db_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_verify_db_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/verifydb", actual_request, callback);
};

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 *
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'rebuild_on_error':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'verify_nulls': When enabled, verifies
 *                          that null values are set to zero
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'verify_persist':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'concurrent_safe': When enabled,
 *                          allows this endpoint to be run safely with other
 *                          concurrent database operations. Other operations
 *                          may be slower while this is running.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'verify_rank0': When enabled, compares
 *                          rank0 table meta-data against workers meta-data
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_verify_db = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_verify_db(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/verifydb", actual_request, callback);
};

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by <code>table_name</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_convex_hull_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_convex_hull_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/convexhull", actual_request, callback);
};

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by <code>table_name</code>.
 *
 * @param {String} table_name  Name of table on which the operation will be
 *                             performed. Must be an existing table, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates of the points for the operation
 *                                being performed.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates of the points for the operation
 *                                being performed.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_convex_hull = function(table_name, x_column_name, y_column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_convex_hull(table_name, x_column_name, y_column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/convexhull", actual_request, callback);
};

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table or view and computes aggregates on each unique combination. This
 * is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../../concepts/aggregation/" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../../concepts/aggregation/#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the <code>offset</code> and <code>limit</code>
 * parameters. For example, to get 10 groups with the largest counts the inputs
 * would be: limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * <code>options</code> can be used to customize behavior of this call e.g.
 * filtering or sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../../concepts/rollup/"
 * target="_top">Rollup</a>, <a href="../../../concepts/cube/"
 * target="_top">Cube</a>, and <a href="../../../concepts/grouping_sets/"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../../concepts/pivot/"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to <code>having</code>.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a <code>result_table</code> name is specified in the
 * <code>options</code>, the results are stored in a new table with that
 * name--no results are returned in the response.  Both the table name and
 * resulting column names must adhere to <a
 * href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../../concepts/tables/#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (<code>offset</code> is 0 and <code>limit</code> is
 * -9999), the result table will be sharded, in all other cases it will be
 * replicated.  Sorting will properly function only if the result table is
 * replicated or if there is only one processing node and should not be relied
 * upon in other cases.  Not available when any of the values of
 * <code>column_names</code> is an unrestricted-length string.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_group_by_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_group_by_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : -9999,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    var self = this;
    this.submit_request("/aggregate/groupby", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Calculates unique combinations (groups) of values for the given columns in a
 * given table or view and computes aggregates on each unique combination. This
 * is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * <p>
 * For aggregation details and examples, see <a
 * href="../../../concepts/aggregation/" target="_top">Aggregation</a>.  For
 * limitations, see <a href="../../../concepts/aggregation/#limitations"
 * target="_top">Aggregation Limitations</a>.
 * <p>
 * Any column(s) can be grouped on, and all column types except
 * unrestricted-length strings may be used for computing applicable aggregates;
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a> are unable to be used in grouping or
 * aggregation.
 * <p>
 * The results can be paged via the <code>offset</code> and <code>limit</code>
 * parameters. For example, to get 10 groups with the largest counts the inputs
 * would be: limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * <code>options</code> can be used to customize behavior of this call e.g.
 * filtering or sorting the results.
 * <p>
 * To group by columns 'x' and 'y' and compute the number of objects within
 * each group, use:  column_names=['x','y','count(*)'].
 * <p>
 * To also compute the sum of 'z' over each group, use:
 * column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available <a href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> are: count(*), sum, min, max, avg,
 * mean, stddev, stddev_pop, stddev_samp, var, var_pop, var_samp, arg_min,
 * arg_max and count_distinct.
 * <p>
 * Available grouping functions are <a href="../../../concepts/rollup/"
 * target="_top">Rollup</a>, <a href="../../../concepts/cube/"
 * target="_top">Cube</a>, and <a href="../../../concepts/grouping_sets/"
 * target="_top">Grouping Sets</a>
 * <p>
 * This service also provides support for <a href="../../../concepts/pivot/"
 * target="_top">Pivot</a> operations.
 * <p>
 * Filtering on aggregates is supported via expressions using <a
 * href="../../../concepts/expressions/#aggregate-expressions"
 * target="_top">aggregation functions</a> supplied to <code>having</code>.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic schemas
 * documentation</a>.
 * <p>
 * If a <code>result_table</code> name is specified in the
 * <code>options</code>, the results are stored in a new table with that
 * name--no results are returned in the response.  Both the table name and
 * resulting column names must adhere to <a
 * href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>; column/aggregation expressions will need to be aliased.  If
 * the source table's <a href="../../../concepts/tables/#shard-keys"
 * target="_top">shard key</a> is used as the grouping column(s) and all result
 * records are selected (<code>offset</code> is 0 and <code>limit</code> is
 * -9999), the result table will be sharded, in all other cases it will be
 * replicated.  Sorting will properly function only if the result table is
 * replicated or if there is only one processing node and should not be relied
 * upon in other cases.  Not available when any of the values of
 * <code>column_names</code> is an unrestricted-length string.
 *
 * @param {String} table_name  Name of an existing table or view on which the
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String[]} column_names  List of one or more column names,
 *                                 expressions, and aggregate expressions.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned, or
 *                        END_OF_SET (-9999) to indicate that the maximum
 *                        number of results allowed by the server should be
 *                        returned.  The number of records returned will never
 *                        exceed the server's own limit, defined by the
 *                        <a href="../../../config/#config-main-general"
 *                        target="_top">max_get_records_size</a> parameter in
 *                        the server configuration.
 *                        Use <code>has_more_records</code> to see if more
 *                        records exist in the result to be fetched, and
 *                        <code>offset</code> & <code>limit</code> to request
 *                        subsequent pages of results.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>result_table</code>. If
 *                          <code>result_table_persist</code> is
 *                          <code>false</code> (or unspecified), then this is
 *                          always allowed even if the caller does not have
 *                          permission to create tables. The generated name is
 *                          returned in
 *                          <code>qualified_result_table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema as part of
 *                          <code>result_table</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema which is
 *                          to contain the table specified in
 *                          <code>result_table</code>. If the schema provided
 *                          is non-existent, it will be automatically created.
 *                                  <li> 'expression': Filter expression to
 *                          apply to the table prior to computing the aggregate
 *                          group by.
 *                                  <li> 'having': Filter expression to apply
 *                          to the aggregated results.
 *                                  <li> 'sort_order': String indicating how
 *                          the returned values should be sorted - ascending or
 *                          descending.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'ascending': Indicates that the
 *                          returned values should be sorted in ascending
 *                          order.
 *                                  <li> 'descending': Indicates that the
 *                          returned values should be sorted in descending
 *                          order.
 *                          </ul>
 *                          The default value is 'ascending'.
 *                                  <li> 'sort_by': String determining how the
 *                          results are sorted.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'key': Indicates that the returned
 *                          values should be sorted by key, which corresponds
 *                          to the grouping columns. If you have multiple
 *                          grouping columns (and are sorting by key), it will
 *                          first sort the first grouping column, then the
 *                          second grouping column, etc.
 *                                  <li> 'value': Indicates that the returned
 *                          values should be sorted by value, which corresponds
 *                          to the aggregates. If you have multiple aggregates
 *                          (and are sorting by value), it will first sort by
 *                          the first aggregate, then the second aggregate,
 *                          etc.
 *                          </ul>
 *                          The default value is 'value'.
 *                                  <li> 'result_table': The name of a table
 *                          used to store the results, in
 *                          [schema_name.]table_name format, using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a> and meeting
 *                          <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>.  Column
 *                          names (group-by and aggregate fields) need to be
 *                          given aliases e.g. ["FChar256 as fchar256",
 *                          "sum(FDouble) as sfd"].  If present, no results are
 *                          returned in the response.  This option is not
 *                          available if one of the grouping attributes is an
 *                          unrestricted string (i.e.; not charN) type.
 *                                  <li> 'result_table_persist': If
 *                          <code>true</code>, then the result table specified
 *                          in <code>result_table</code> will be persisted and
 *                          will not expire unless a <code>ttl</code> is
 *                          specified.   If <code>false</code>, then the result
 *                          table will be an in-memory table and will expire
 *                          unless a <code>ttl</code> is specified otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'result_table_force_replicated': Force
 *                          the result table to be replicated (ignores any
 *                          sharding). Must be used in combination with the
 *                          <code>result_table</code> option.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'result_table_generate_pk': If
 *                          <code>true</code> then set a primary key for the
 *                          result table. Must be used in combination with the
 *                          <code>result_table</code> option.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the table specified in
 *                          <code>result_table</code>.
 *                                  <li> 'chunk_size': Indicates the number of
 *                          records per chunk to be used for the result table.
 *                          Must be used in combination with the
 *                          <code>result_table</code> option.
 *                                  <li> 'create_indexes': Comma-separated list
 *                          of columns on which to create indexes on the result
 *                          table. Must be used in combination with the
 *                          <code>result_table</code> option.
 *                                  <li> 'view_id': ID of view of which the
 *                          result table will be a member.  The default value
 *                          is ''.
 *                                  <li> 'pivot': pivot column
 *                                  <li> 'pivot_values': The value list
 *                          provided will become the column headers in the
 *                          output. Should be the values from the pivot_column.
 *                                  <li> 'grouping_sets': Customize the
 *                          grouping attribute sets to compute the aggregates.
 *                          These sets can include ROLLUP or CUBE operartors.
 *                          The attribute sets should be enclosed in
 *                          paranthesis and can include composite attributes.
 *                          All attributes specified in the grouping sets must
 *                          present in the groupby attributes.
 *                                  <li> 'rollup': This option is used to
 *                          specify the multilevel aggregates.
 *                                  <li> 'cube': This option is used to specify
 *                          the multidimensional aggregates.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_group_by = function(table_name, column_names, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_group_by(table_name, column_names, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : -9999,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    var self = this;
    this.submit_request("/aggregate/groupby", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Performs a histogram calculation given a table, a column, and an
 * interval function. The <code>interval</code> is used to produce bins of that
 * size
 * and the result, computed over the records falling within each bin, is
 * returned.
 * For each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a
 * <code>value_column</code>.  In this latter case the sum of the
 * values corresponding to the <code>value_column</code> is used as the
 * result instead.  The total number of bins requested cannot exceed 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service a request that specifies a <code>value_column</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_histogram_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_histogram_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        start: request.start,
        end: request.end,
        interval: request.interval,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/histogram", actual_request, callback);
};

/**
 * Performs a histogram calculation given a table, a column, and an
 * interval function. The <code>interval</code> is used to produce bins of that
 * size
 * and the result, computed over the records falling within each bin, is
 * returned.
 * For each bin, the start value is inclusive, but the end value is
 * exclusive--except for the very last bin for which the end value is also
 * inclusive.  The value returned for each bin is the number of records in it,
 * except when a column name is provided as a
 * <code>value_column</code>.  In this latter case the sum of the
 * values corresponding to the <code>value_column</code> is used as the
 * result instead.  The total number of bins requested cannot exceed 10,000.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service a request that specifies a <code>value_column</code>.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} column_name  Name of a column or an expression of one or
 *                              more column names over which the histogram will
 *                              be calculated.
 * @param {Number} start  Lower end value of the histogram interval, inclusive.
 * @param {Number} end  Upper end value of the histogram interval, inclusive.
 * @param {Number} interval  The size of each bin within the start and end
 *                           parameters.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'value_column': The name of the column
 *                          to use when calculating the bin values (values are
 *                          summed).  The column must be a numerical type (int,
 *                          double, long, float).
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_histogram = function(table_name, column_name, start, end, interval, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_histogram(table_name, column_name, start, end, interval, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        start: start,
        end: end,
        interval: interval,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/histogram", actual_request, callback);
};

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm
 * that attempts to do k-means clustering.  An ideal k-means clustering
 * algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member
 * of the set to the nearest of the k points is minimized.  The k-means
 * algorithm
 * however does not necessarily produce such an ideal cluster.   It begins with
 * a
 * randomly selected set of k points and then refines the location of the
 * points
 * iteratively and settles to a local minimum.  Various parameters and options
 * are
 * provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_k_means_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_k_means_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        k: request.k,
        tolerance: request.tolerance,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/kmeans", actual_request, callback);
};

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm
 * that attempts to do k-means clustering.  An ideal k-means clustering
 * algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member
 * of the set to the nearest of the k points is minimized.  The k-means
 * algorithm
 * however does not necessarily produce such an ideal cluster.   It begins with
 * a
 * randomly selected set of k points and then refines the location of the
 * points
 * iteratively and settles to a local minimum.  Various parameters and options
 * are
 * provided to control the heuristic search.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String[]} column_names  List of column names on which the operation
 *                                 would be performed. If n columns are
 *                                 provided then each of the k result points
 *                                 will have n dimensions corresponding to the
 *                                 n columns.
 * @param {Number} k  The number of mean points to be determined by the
 *                    algorithm.
 * @param {Number} tolerance  Stop iterating when the distances between
 *                            successive points is less than the given
 *                            tolerance.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'whiten': When set to 1 each of the
 *                          columns is first normalized by its stdv - default
 *                          is not to whiten.
 *                                  <li> 'max_iters': Number of times to try to
 *                          hit the tolerance limit before giving up - default
 *                          is 10.
 *                                  <li> 'num_tries': Number of times to run
 *                          the k-means algorithm with a different randomly
 *                          selected starting points - helps avoid local
 *                          minimum. Default is 1.
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>result_table</code>. If
 *                          <code>result_table_persist</code> is
 *                          <code>false</code> (or unspecified), then this is
 *                          always allowed even if the caller does not have
 *                          permission to create tables. The generated name is
 *                          returned in
 *                          <code>qualified_result_table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'result_table': The name of a table
 *                          used to store the results, in
 *                          [schema_name.]table_name format, using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a> and meeting
 *                          <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>.  If this
 *                          option is specified, the results are not returned
 *                          in the response.
 *                                  <li> 'result_table_persist': If
 *                          <code>true</code>, then the result table specified
 *                          in <code>result_table</code> will be persisted and
 *                          will not expire unless a <code>ttl</code> is
 *                          specified.   If <code>false</code>, then the result
 *                          table will be an in-memory table and will expire
 *                          unless a <code>ttl</code> is specified otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the table specified in
 *                          <code>result_table</code>.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_k_means = function(table_name, column_names, k, tolerance, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_k_means(table_name, column_names, k, tolerance, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        k: k,
        tolerance: tolerance,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/kmeans", actual_request, callback);
};

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_min_max_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_min_max_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/minmax", actual_request, callback);
};

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} column_name  Name of a column or an expression of one or
 *                              more column on which the min-max will be
 *                              calculated.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_min_max = function(table_name, column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_min_max(table_name, column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/minmax", actual_request, callback);
};

/**
 * Calculates and returns the minimum and maximum x- and y-coordinates
 * of a particular geospatial geometry column in a table.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_min_max_geometry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_min_max_geometry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/minmax/geometry", actual_request, callback);
};

/**
 * Calculates and returns the minimum and maximum x- and y-coordinates
 * of a particular geospatial geometry column in a table.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} column_name  Name of a geospatial geometry column on which
 *                              the min-max will be calculated.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_min_max_geometry = function(table_name, column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_min_max_geometry(table_name, column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/minmax/geometry", actual_request, callback);
};

/**
 * Calculates the requested statistics of the given column(s) in a
 * given table.
 * <p>
 * The available statistics are:
 *   <code>count</code> (number of total objects),
 *   <code>mean</code>,
 *   <code>stdv</code> (standard deviation),
 *   <code>variance</code>,
 *   <code>skew</code>,
 *   <code>kurtosis</code>,
 *   <code>sum</code>,
 *   <code>min</code>,
 *   <code>max</code>,
 *   <code>weighted_average</code>,
 *   <code>cardinality</code> (unique count),
 *   <code>estimated_cardinality</code>,
 *   <code>percentile</code>, and
 *   <code>percentile_rank</code>.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the
 * t-digest algorithm. They must include the desired
 * <code>percentile</code>/<code>percentile_rank</code>.
 * To compute multiple percentiles each value must be specified separately
 * (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the
 * <code>percentile</code> statistic to calculate percentile
 * resolution, e.g., a 50th percentile with 200 resolution would be
 * 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a weight column to be specified in
 * <code>weight_column_name</code>.  The weighted average is then
 * defined as the sum of the products of <code>column_name</code> times the
 * <code>weight_column_name</code> values divided by the sum of the
 * <code>weight_column_name</code> values.
 * <p>
 * Additional columns can be used in the calculation of statistics via
 * <code>additional_column_names</code>.  Values in these columns will
 * be included in the overall aggregate calculation--individual aggregates will
 * not
 * be calculated per additional column.  For instance, requesting the
 * <code>count</code> & <code>mean</code> of
 * <code>column_name</code> x and <code>additional_column_names</code>
 * y & z, where x holds the numbers 1-10, y holds 11-20, and z holds 21-30,
 * would
 * return the total number of x, y, & z values (30), and the single average
 * value
 * across all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and
 * its corresponding value.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        stats: request.stats,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/statistics", actual_request, callback);
};

/**
 * Calculates the requested statistics of the given column(s) in a
 * given table.
 * <p>
 * The available statistics are:
 *   <code>count</code> (number of total objects),
 *   <code>mean</code>,
 *   <code>stdv</code> (standard deviation),
 *   <code>variance</code>,
 *   <code>skew</code>,
 *   <code>kurtosis</code>,
 *   <code>sum</code>,
 *   <code>min</code>,
 *   <code>max</code>,
 *   <code>weighted_average</code>,
 *   <code>cardinality</code> (unique count),
 *   <code>estimated_cardinality</code>,
 *   <code>percentile</code>, and
 *   <code>percentile_rank</code>.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile ranks are approximate and are calculated using
 * the
 * t-digest algorithm. They must include the desired
 * <code>percentile</code>/<code>percentile_rank</code>.
 * To compute multiple percentiles each value must be specified separately
 * (i.e.
 * 'percentile(75.0),percentile(99.0),percentile_rank(1234.56),percentile_rank(-5)').
 * <p>
 * A second, comma-separated value can be added to the
 * <code>percentile</code> statistic to calculate percentile
 * resolution, e.g., a 50th percentile with 200 resolution would be
 * 'percentile(50,200)'.
 * <p>
 * The weighted average statistic requires a weight column to be specified in
 * <code>weight_column_name</code>.  The weighted average is then
 * defined as the sum of the products of <code>column_name</code> times the
 * <code>weight_column_name</code> values divided by the sum of the
 * <code>weight_column_name</code> values.
 * <p>
 * Additional columns can be used in the calculation of statistics via
 * <code>additional_column_names</code>.  Values in these columns will
 * be included in the overall aggregate calculation--individual aggregates will
 * not
 * be calculated per additional column.  For instance, requesting the
 * <code>count</code> & <code>mean</code> of
 * <code>column_name</code> x and <code>additional_column_names</code>
 * y & z, where x holds the numbers 1-10, y holds 11-20, and z holds 21-30,
 * would
 * return the total number of x, y, & z values (30), and the single average
 * value
 * across all x, y, & z values (15.5).
 * <p>
 * The response includes a list of key/value pairs of each statistic requested
 * and
 * its corresponding value.
 *
 * @param {String} table_name  Name of the table on which the statistics
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} column_name  Name of the primary column for which the
 *                              statistics are to be calculated.
 * @param {String} stats  Comma separated list of the statistics to calculate,
 *                        e.g. "sum,mean".
 *                        Supported values:
 *                        <ul>
 *                                <li> 'count': Number of objects (independent
 *                        of the given column(s)).
 *                                <li> 'mean': Arithmetic mean (average),
 *                        equivalent to sum/count.
 *                                <li> 'stdv': Sample standard deviation
 *                        (denominator is count-1).
 *                                <li> 'variance': Unbiased sample variance
 *                        (denominator is count-1).
 *                                <li> 'skew': Skewness (third standardized
 *                        moment).
 *                                <li> 'kurtosis': Kurtosis (fourth
 *                        standardized moment).
 *                                <li> 'sum': Sum of all values in the
 *                        column(s).
 *                                <li> 'min': Minimum value of the column(s).
 *                                <li> 'max': Maximum value of the column(s).
 *                                <li> 'weighted_average': Weighted arithmetic
 *                        mean (using the option
 *                        <code>weight_column_name</code> as the weighting
 *                        column).
 *                                <li> 'cardinality': Number of unique values
 *                        in the column(s).
 *                                <li> 'estimated_cardinality': Estimate (via
 *                        hyperloglog technique) of the number of unique values
 *                        in the column(s).
 *                                <li> 'percentile': Estimate (via t-digest) of
 *                        the given percentile of the column(s)
 *                        (percentile(50.0) will be an approximation of the
 *                        median). Add a second, comma-separated value to
 *                        calculate percentile resolution, e.g.,
 *                        'percentile(75,150)'
 *                                <li> 'percentile_rank': Estimate (via
 *                        t-digest) of the percentile rank of the given value
 *                        in the column(s) (if the given value is the median of
 *                        the column(s), percentile_rank(<median>) will return
 *                        approximately 50.0).
 *                        </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'additional_column_names': A list of
 *                          comma separated column names over which statistics
 *                          can be accumulated along with the primary column.
 *                          All columns listed and <code>column_name</code>
 *                          must be of the same type.  Must not include the
 *                          column specified in <code>column_name</code> and no
 *                          column can be listed twice.
 *                                  <li> 'weight_column_name': Name of column
 *                          used as weighting attribute for the weighted
 *                          average statistic.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics = function(table_name, column_name, stats, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics(table_name, column_name, stats, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        stats: stats,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/statistics", actual_request, callback);
};

/**
 * Divides the given set into bins and calculates statistics of the
 * values of a value-column in each bin.  The bins are based on the values of a
 * given binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and
 * weighted average. In addition to the requested statistics the count of total
 * samples in each bin is returned. This counts vector is just the histogram of
 * the
 * column used to divide the set members into bins. The weighted average
 * statistic
 * requires a weight column to be specified in
 * <code>weight_column_name</code>. The weighted average is then
 * defined as the sum of the products of the value column times the weight
 * column
 * divided by the sum of the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be
 * used for numeric valued binning-columns, a min, max and interval are
 * specified.
 * The number of bins, nbins, is the integer upper bound of (max-min)/interval.
 * Values that fall in the range [min+n*interval,min+(n+1)*interval) are placed
 * in
 * the nth bin where n ranges from 0..nbin-2. The final bin is
 * [min+(nbin-1)*interval,max]. In the second method,
 * <code>bin_values</code> specifies a list of binning column values.
 * Binning-columns whose value matches the nth member of the
 * <code>bin_values</code> list are placed in the nth bin. When a list
 * is provided, the binning-column must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        select_expression: (request.select_expression !== undefined && request.select_expression !== null) ? request.select_expression : "",
        column_name: request.column_name,
        value_column_name: request.value_column_name,
        stats: request.stats,
        start: request.start,
        end: request.end,
        interval: request.interval,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/statistics/byrange", actual_request, callback);
};

/**
 * Divides the given set into bins and calculates statistics of the
 * values of a value-column in each bin.  The bins are based on the values of a
 * given binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and
 * weighted average. In addition to the requested statistics the count of total
 * samples in each bin is returned. This counts vector is just the histogram of
 * the
 * column used to divide the set members into bins. The weighted average
 * statistic
 * requires a weight column to be specified in
 * <code>weight_column_name</code>. The weighted average is then
 * defined as the sum of the products of the value column times the weight
 * column
 * divided by the sum of the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be
 * used for numeric valued binning-columns, a min, max and interval are
 * specified.
 * The number of bins, nbins, is the integer upper bound of (max-min)/interval.
 * Values that fall in the range [min+n*interval,min+(n+1)*interval) are placed
 * in
 * the nth bin where n ranges from 0..nbin-2. The final bin is
 * [min+(nbin-1)*interval,max]. In the second method,
 * <code>bin_values</code> specifies a list of binning column values.
 * Binning-columns whose value matches the nth member of the
 * <code>bin_values</code> list are placed in the nth bin. When a list
 * is provided, the binning-column must be of type string or int.
 * <p>
 * NOTE:  The Kinetica instance being accessed must be running a CUDA
 * (GPU-based)
 * build to service this request.
 *
 * @param {String} table_name  Name of the table on which the ranged-statistics
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} select_expression  For a non-empty expression statistics are
 *                                    calculated for those records for which
 *                                    the expression is true.
 * @param {String} column_name  Name of the binning-column used to divide the
 *                              set samples into bins.
 * @param {String} value_column_name  Name of the value-column for which
 *                                    statistics are to be computed.
 * @param {String} stats  A string of comma separated list of the statistics to
 *                        calculate, e.g. 'sum,mean'. Available statistics:
 *                        mean, stdv (standard deviation), variance, skew,
 *                        kurtosis, sum.
 * @param {Number} start  The lower bound of the binning-column.
 * @param {Number} end  The upper bound of the binning-column.
 * @param {Number} interval  The interval of a bin. Set members fall into bin i
 *                           if the binning-column falls in the range
 *                           [start+interval*i, start+interval*(i+1)).
 * @param {Object} options  Map of optional parameters:
 *                          <ul>
 *                                  <li> 'additional_column_names': A list of
 *                          comma separated value-column names over which
 *                          statistics can be accumulated along with the
 *                          primary value_column.
 *                                  <li> 'bin_values': A list of comma
 *                          separated binning-column values. Values that match
 *                          the nth bin_values value are placed in the nth bin.
 *                                  <li> 'weight_column_name': Name of the
 *                          column used as weighting column for the
 *                          weighted_average statistic.
 *                                  <li> 'order_column_name': Name of the
 *                          column used for candlestick charting techniques.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_by_range = function(table_name, select_expression, column_name, value_column_name, stats, start, end, interval, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_by_range(table_name, select_expression, column_name, value_column_name, stats, start, end, interval, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        select_expression: (select_expression !== undefined && select_expression !== null) ? select_expression : "",
        column_name: column_name,
        value_column_name: value_column_name,
        stats: stats,
        start: start,
        end: end,
        interval: interval,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/statistics/byrange", actual_request, callback);
};

/**
 * Returns all the unique values from a particular column
 * (specified by <code>column_name</code>) of a particular table or view
 * (specified by <code>table_name</code>). If <code>column_name</code> is a
 * numeric column,
 * the values will be in <code>binary_encoded_response</code>. Otherwise if
 * <code>column_name</code> is a string column, the values will be in
 * <code>json_encoded_response</code>.  The results can be paged via
 * <code>offset</code>
 * and <code>limit</code> parameters.
 * <p>
 * Columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>
 * are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order
 * <code>options</code>
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * <p>
 * If a <code>result_table</code> name is specified in the
 * <code>options</code>, the results are stored in a new table with that
 * name--no
 * results are returned in the response.  Both the table name and resulting
 * column
 * name must adhere to
 * <a href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>;
 * any column expression will need to be aliased.  If the source table's
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * is used as the
 * <code>column_name</code>, the result table will be sharded, in all other
 * cases it
 * will be replicated.  Sorting will properly function only if the result table
 * is
 * replicated or if there is only one processing node and should not be relied
 * upon
 * in other cases.  Not available if the value of <code>column_name</code> is
 * an
 * unrestricted-length string.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_unique_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_unique_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : -9999,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    var self = this;
    this.submit_request("/aggregate/unique", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Returns all the unique values from a particular column
 * (specified by <code>column_name</code>) of a particular table or view
 * (specified by <code>table_name</code>). If <code>column_name</code> is a
 * numeric column,
 * the values will be in <code>binary_encoded_response</code>. Otherwise if
 * <code>column_name</code> is a string column, the values will be in
 * <code>json_encoded_response</code>.  The results can be paged via
 * <code>offset</code>
 * and <code>limit</code> parameters.
 * <p>
 * Columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>
 * are unable to be used with this function.
 * <p>
 * To get the first 10 unique values sorted in descending order
 * <code>options</code>
 * would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 * <p>
 * If a <code>result_table</code> name is specified in the
 * <code>options</code>, the results are stored in a new table with that
 * name--no
 * results are returned in the response.  Both the table name and resulting
 * column
 * name must adhere to
 * <a href="../../../concepts/tables/#table" target="_top">standard naming
 * conventions</a>;
 * any column expression will need to be aliased.  If the source table's
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * is used as the
 * <code>column_name</code>, the result table will be sharded, in all other
 * cases it
 * will be replicated.  Sorting will properly function only if the result table
 * is
 * replicated or if there is only one processing node and should not be relied
 * upon
 * in other cases.  Not available if the value of <code>column_name</code> is
 * an
 * unrestricted-length string.
 *
 * @param {String} table_name  Name of an existing table or view on which the
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} column_name  Name of the column or an expression containing
 *                              one or more column names on which the unique
 *                              function would be applied.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned, or
 *                        END_OF_SET (-9999) to indicate that the maximum
 *                        number of results allowed by the server should be
 *                        returned.  The number of records returned will never
 *                        exceed the server's own limit, defined by the
 *                        <a href="../../../config/#config-main-general"
 *                        target="_top">max_get_records_size</a> parameter in
 *                        the server configuration.
 *                        Use <code>has_more_records</code> to see if more
 *                        records exist in the result to be fetched, and
 *                        <code>offset</code> & <code>limit</code> to request
 *                        subsequent pages of results.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>result_table</code>. If
 *                          <code>result_table_persist</code> is
 *                          <code>false</code> (or unspecified), then this is
 *                          always allowed even if the caller does not have
 *                          permission to create tables. The generated name is
 *                          returned in
 *                          <code>qualified_result_table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema as part of
 *                          <code>result_table</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema which is
 *                          to contain the table specified in
 *                          <code>result_table</code>. If the schema provided
 *                          is non-existent, it will be automatically created.
 *                                  <li> 'expression': Optional filter
 *                          expression to apply to the table.
 *                                  <li> 'sort_order': String indicating how
 *                          the returned values should be sorted.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'ascending'
 *                                  <li> 'descending'
 *                          </ul>
 *                          The default value is 'ascending'.
 *                                  <li> 'result_table': The name of the table
 *                          used to store the results, in
 *                          [schema_name.]table_name format, using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a> and meeting
 *                          <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>.  If
 *                          present, no results are returned in the response.
 *                          Not available if <code>column_name</code> is an
 *                          unrestricted-length string.
 *                                  <li> 'result_table_persist': If
 *                          <code>true</code>, then the result table specified
 *                          in <code>result_table</code> will be persisted and
 *                          will not expire unless a <code>ttl</code> is
 *                          specified.   If <code>false</code>, then the result
 *                          table will be an in-memory table and will expire
 *                          unless a <code>ttl</code> is specified otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'result_table_force_replicated': Force
 *                          the result table to be replicated (ignores any
 *                          sharding). Must be used in combination with the
 *                          <code>result_table</code> option.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'result_table_generate_pk': If
 *                          <code>true</code> then set a primary key for the
 *                          result table. Must be used in combination with the
 *                          <code>result_table</code> option.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the table specified in
 *                          <code>result_table</code>.
 *                                  <li> 'chunk_size': Indicates the number of
 *                          records per chunk to be used for the result table.
 *                          Must be used in combination with the
 *                          <code>result_table</code> option.
 *                                  <li> 'view_id': ID of view of which the
 *                          result table will be a member.  The default value
 *                          is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_unique = function(table_name, column_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_unique(table_name, column_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : -9999,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    var self = this;
    this.submit_request("/aggregate/unique", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see
 * <a href="../../../concepts/unpivot/" target="_top">Unpivot</a>.  For
 * limitations, see
 * <a href="../../../concepts/unpivot/#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting
 * purposes. The unpivot operator rotates the column values for all the pivoted
 * columns. A variable column, value column and all columns from the source
 * table
 * except the unpivot columns are projected into the result table. The variable
 * column and value columns in the result table indicate the pivoted column
 * name
 * and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_unpivot_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_unpivot_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        variable_column_name: (request.variable_column_name !== undefined && request.variable_column_name !== null) ? request.variable_column_name : "",
        value_column_name: (request.value_column_name !== undefined && request.value_column_name !== null) ? request.value_column_name : "",
        pivoted_columns: request.pivoted_columns,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    var self = this;
    this.submit_request("/aggregate/unpivot", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Rotate the column values into rows values.
 * <p>
 * For unpivot details and examples, see
 * <a href="../../../concepts/unpivot/" target="_top">Unpivot</a>.  For
 * limitations, see
 * <a href="../../../concepts/unpivot/#limitations" target="_top">Unpivot
 * Limitations</a>.
 * <p>
 * Unpivot is used to normalize tables that are built for cross tabular
 * reporting
 * purposes. The unpivot operator rotates the column values for all the pivoted
 * columns. A variable column, value column and all columns from the source
 * table
 * except the unpivot columns are projected into the result table. The variable
 * column and value columns in the result table indicate the pivoted column
 * name
 * and values respectively.
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be an existing table/view, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String[]} column_names  List of column names or expressions. A
 *                                 wildcard '*' can be used to include all the
 *                                 non-pivoted columns from the source table.
 * @param {String} variable_column_name  Specifies the variable/parameter
 *                                       column name.
 * @param {String} value_column_name  Specifies the value column name.
 * @param {String[]} pivoted_columns  List of one or more values typically the
 *                                    column names of the input table. All the
 *                                    columns in the source table must have the
 *                                    same data type.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>result_table</code>. If
 *                          <code>result_table_persist</code> is
 *                          <code>false</code> (or unspecified), then this is
 *                          always allowed even if the caller does not have
 *                          permission to create tables. The generated name is
 *                          returned in
 *                          <code>qualified_result_table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema as part of
 *                          <code>result_table</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema which is
 *                          to contain the table specified in
 *                          <code>result_table</code>. If the schema is
 *                          non-existent, it will be automatically created.
 *                                  <li> 'result_table': The name of a table
 *                          used to store the results, in
 *                          [schema_name.]table_name format, using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a> and meeting
 *                          <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>. If
 *                          present, no results are returned in the response.
 *                                  <li> 'result_table_persist': If
 *                          <code>true</code>, then the result table specified
 *                          in <code>result_table</code> will be persisted and
 *                          will not expire unless a <code>ttl</code> is
 *                          specified.   If <code>false</code>, then the result
 *                          table will be an in-memory table and will expire
 *                          unless a <code>ttl</code> is specified otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'expression': Filter expression to
 *                          apply to the table prior to unpivot processing.
 *                                  <li> 'order_by': Comma-separated list of
 *                          the columns to be sorted by; e.g. 'timestamp asc, x
 *                          desc'.  The columns specified must be present in
 *                          input table.  If any alias is given for any column
 *                          name, the alias must be used, rather than the
 *                          original column name.  The default value is ''.
 *                                  <li> 'chunk_size': Indicates the number of
 *                          records per chunk to be used for the result table.
 *                          Must be used in combination with the
 *                          <code>result_table</code> option.
 *                                  <li> 'limit': The number of records to
 *                          keep.  The default value is ''.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the table specified in
 *                          <code>result_table</code>.
 *                                  <li> 'view_id': view this result table is
 *                          part of.  The default value is ''.
 *                                  <li> 'create_indexes': Comma-separated list
 *                          of columns on which to create indexes on the table
 *                          specified in <code>result_table</code>. The columns
 *                          specified must be present in output column names.
 *                          If any alias is given for any column name, the
 *                          alias must be used, rather than the original column
 *                          name.
 *                                  <li> 'result_table_force_replicated': Force
 *                          the result table to be replicated (ignores any
 *                          sharding). Must be used in combination with the
 *                          <code>result_table</code> option.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_unpivot = function(table_name, column_names, variable_column_name, value_column_name, pivoted_columns, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_unpivot(table_name, column_names, variable_column_name, value_column_name, pivoted_columns, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        variable_column_name: (variable_column_name !== undefined && variable_column_name !== null) ? variable_column_name : "",
        value_column_name: (value_column_name !== undefined && value_column_name !== null) ? value_column_name : "",
        pivoted_columns: pivoted_columns,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    var self = this;
    this.submit_request("/aggregate/unpivot", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Alter the properties of an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_credential_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_credential_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        credential_name: request.credential_name,
        credential_updates_map: request.credential_updates_map,
        options: request.options
    };

    this.submit_request("/alter/credential", actual_request, callback);
};

/**
 * Alter the properties of an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 *
 * @param {String} credential_name  Name of the credential to be altered. Must
 *                                  be an existing credential.
 * @param {Object} credential_updates_map  Map containing the properties of the
 *                                         credential to be updated. Error if
 *                                         empty.
 *                                         <ul>
 *                                                 <li> 'type': New type for
 *                                         the credential.
 *                                         Supported values:
 *                                         <ul>
 *                                                 <li> 'aws_access_key'
 *                                                 <li> 'aws_iam_role'
 *                                                 <li> 'azure_ad'
 *                                                 <li> 'azure_oauth'
 *                                                 <li> 'azure_sas'
 *                                                 <li> 'azure_storage_key'
 *                                                 <li> 'docker'
 *                                                 <li> 'hdfs'
 *                                                 <li> 'kafka'
 *                                                 <li>
 *                                         'gcs_service_account_id'
 *                                                 <li>
 *                                         'gcs_service_account_keys'
 *                                         </ul>
 *                                                 <li> 'identity': New user
 *                                         for the credential
 *                                                 <li> 'secret': New password
 *                                         for the credential
 *                                                 <li> 'schema_name': Updates
 *                                         the schema name.  If
 *                                         <code>schema_name</code>
 *                                         doesn't exist, an error will be
 *                                         thrown. If <code>schema_name</code>
 *                                         is empty, then the user's
 *                                         default schema will be used.
 *                                         </ul>
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_credential = function(credential_name, credential_updates_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_credential(credential_name, credential_updates_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        credential_name: credential_name,
        credential_updates_map: credential_updates_map,
        options: options
    };

    this.submit_request("/alter/credential", actual_request, callback);
};

/**
 * Alters the properties of an existing <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_datasink_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_datasink_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        datasink_updates_map: request.datasink_updates_map,
        options: request.options
    };

    this.submit_request("/alter/datasink", actual_request, callback);
};

/**
 * Alters the properties of an existing <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a>
 *
 * @param {String} name  Name of the data sink to be altered. Must be an
 *                       existing data sink.
 * @param {Object} datasink_updates_map  Map containing the properties of the
 *                                       data sink to be updated. Error if
 *                                       empty.
 *                                       <ul>
 *                                               <li> 'destination':
 *                                       Destination for the output data in
 *                                       format
 *                                       'destination_type://path[:port]'.
 *                                       Supported destination types are
 *                                       'http', 'https' and 'kafka'.
 *                                               <li> 'connection_timeout':
 *                                       Timeout in seconds for connecting to
 *                                       this sink
 *                                               <li> 'wait_timeout': Timeout
 *                                       in seconds for waiting for a response
 *                                       from this sink
 *                                               <li> 'credential': Name of the
 *                                       <a
 *                                       href="../../../concepts/credentials/"
 *                                       target="_top">credential</a> object to
 *                                       be used in this data sink
 *                                               <li> 'kafka_topic_name': Name
 *                                       of the Kafka topic to use for this
 *                                       data sink, if it references a Kafka
 *                                       broker
 *                                               <li> 'max_batch_size': Maximum
 *                                       number of records per notification
 *                                       message.  The default value is '1'.
 *                                               <li> 'max_message_size':
 *                                       Maximum size in bytes of each
 *                                       notification message.  The default
 *                                       value is '1000000'.
 *                                               <li> 'json_format': The
 *                                       desired format of JSON encoded
 *                                       notifications message.
 *                                       If <code>nested</code>, records are
 *                                       returned as an array.
 *                                       Otherwise, only a single record per
 *                                       messages is returned.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'flat'
 *                                               <li> 'nested'
 *                                       </ul>
 *                                       The default value is 'flat'.
 *                                               <li> 'skip_validation': Bypass
 *                                       validation of connection to this data
 *                                       sink.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'schema_name': Updates
 *                                       the schema name.  If
 *                                       <code>schema_name</code>
 *                                       doesn't exist, an error will be
 *                                       thrown. If <code>schema_name</code> is
 *                                       empty, then the user's
 *                                       default schema will be used.
 *                                       </ul>
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_datasink = function(name, datasink_updates_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_datasink(name, datasink_updates_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        datasink_updates_map: datasink_updates_map,
        options: options
    };

    this.submit_request("/alter/datasink", actual_request, callback);
};

/**
 * Alters the properties of an existing <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_datasource_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_datasource_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        datasource_updates_map: request.datasource_updates_map,
        options: request.options
    };

    this.submit_request("/alter/datasource", actual_request, callback);
};

/**
 * Alters the properties of an existing <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>
 *
 * @param {String} name  Name of the data source to be altered. Must be an
 *                       existing data source.
 * @param {Object} datasource_updates_map  Map containing the properties of the
 *                                         data source to be updated. Error if
 *                                         empty.
 *                                         <ul>
 *                                                 <li> 'location': Location of
 *                                         the remote storage in
 *                                         'storage_provider_type://[storage_path[:storage_port]]'
 *                                         format.
 *                                         Supported storage provider types are
 *                                         'azure','gcs','hdfs','kafka' and
 *                                         's3'.
 *                                                 <li> 'user_name': Name of
 *                                         the remote system user; may be an
 *                                         empty string
 *                                                 <li> 'password': Password
 *                                         for the remote system user; may be
 *                                         an empty string
 *                                                 <li> 'skip_validation':
 *                                         Bypass validation of connection to
 *                                         remote source.
 *                                         Supported values:
 *                                         <ul>
 *                                                 <li> 'true'
 *                                                 <li> 'false'
 *                                         </ul>
 *                                         The default value is 'false'.
 *                                                 <li> 'connection_timeout':
 *                                         Timeout in seconds for connecting to
 *                                         this storage provider
 *                                                 <li> 'wait_timeout': Timeout
 *                                         in seconds for reading from this
 *                                         storage provider
 *                                                 <li> 'credential': Name of
 *                                         the Credential object to be used in
 *                                         data source
 *                                                 <li> 's3_bucket_name': Name
 *                                         of the Amazon S3 bucket to use as
 *                                         the data source
 *                                                 <li> 's3_region': Name of
 *                                         the Amazon S3 region where the given
 *                                         bucket is located
 *                                                 <li> 's3_aws_role_arn':
 *                                         Amazon IAM Role ARN which has
 *                                         required S3 permissions that can be
 *                                         assumed for the given S3 IAM user
 *                                                 <li> 'hdfs_kerberos_keytab':
 *                                         Kerberos keytab file location for
 *                                         the given HDFS user
 *                                                 <li>
 *                                         'hdfs_delegation_token': Delegation
 *                                         token for the given HDFS user
 *                                                 <li> 'hdfs_use_kerberos':
 *                                         Use kerberos authentication for the
 *                                         given HDFS cluster
 *                                         Supported values:
 *                                         <ul>
 *                                                 <li> 'true'
 *                                                 <li> 'false'
 *                                         </ul>
 *                                         The default value is 'false'.
 *                                                 <li>
 *                                         'azure_storage_account_name': Name
 *                                         of the Azure storage account to use
 *                                         as the data source, this is valid
 *                                         only if tenant_id is specified
 *                                                 <li> 'azure_container_name':
 *                                         Name of the Azure storage container
 *                                         to use as the data source
 *                                                 <li> 'azure_tenant_id':
 *                                         Active Directory tenant ID (or
 *                                         directory ID)
 *                                                 <li> 'azure_sas_token':
 *                                         Shared access signature token for
 *                                         Azure storage account to use as the
 *                                         data source
 *                                                 <li> 'azure_oauth_token':
 *                                         Oauth token to access given storage
 *                                         container
 *                                                 <li> 'gcs_bucket_name': Name
 *                                         of the Google Cloud Storage bucket
 *                                         to use as the data source
 *                                                 <li> 'gcs_project_id': Name
 *                                         of the Google Cloud project to use
 *                                         as the data source
 *                                                 <li>
 *                                         'gcs_service_account_keys': Google
 *                                         Cloud service account keys to use
 *                                         for authenticating the data source
 *                                                 <li> 'kafka_url': The
 *                                         publicly-accessible full path URL to
 *                                         the kafka broker, e.g.,
 *                                         'http://172.123.45.67:9300'.
 *                                                 <li> 'kafka_topic_name':
 *                                         Name of the Kafka topic to use as
 *                                         the data source
 *                                                 <li> 'anonymous': Create an
 *                                         anonymous connection to the storage
 *                                         provider--DEPRECATED: this is now
 *                                         the default.  Specify
 *                                         use_managed_credentials for
 *                                         non-anonymous connection
 *                                         Supported values:
 *                                         <ul>
 *                                                 <li> 'true'
 *                                                 <li> 'false'
 *                                         </ul>
 *                                         The default value is 'true'.
 *                                                 <li>
 *                                         'use_managed_credentials': When no
 *                                         credentials are supplied, we use
 *                                         anonymous access by default.  If
 *                                         this is set, we will use cloud
 *                                         provider user settings.
 *                                         Supported values:
 *                                         <ul>
 *                                                 <li> 'true'
 *                                                 <li> 'false'
 *                                         </ul>
 *                                         The default value is 'false'.
 *                                                 <li> 'use_https': Use https
 *                                         to connect to datasource if true,
 *                                         otherwise use http
 *                                         Supported values:
 *                                         <ul>
 *                                                 <li> 'true'
 *                                                 <li> 'false'
 *                                         </ul>
 *                                         The default value is 'true'.
 *                                                 <li> 'schema_name': Updates
 *                                         the schema name.  If
 *                                         <code>schema_name</code>
 *                                         doesn't exist, an error will be
 *                                         thrown. If <code>schema_name</code>
 *                                         is empty, then the user's
 *                                         default schema will be used.
 *                                         </ul>
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_datasource = function(name, datasource_updates_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_datasource(name, datasource_updates_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        datasource_updates_map: datasource_updates_map,
        options: options
    };

    this.submit_request("/alter/datasource", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.alter_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        action: request.action,
        action_arg: request.action_arg,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/graph", actual_request, callback);
};

/**
 *
 * @param {String} graph_name
 * @param {String} action
 *                         Supported values:
 *                         <ul>
 *                                 <li> 'add_table_monitor'
 *                                 <li> 'reset_client'
 *                                 <li> 'reset_server'
 *                                 <li> 'cancel_task'
 *                                 <li> 'alter_logger'
 *                                 <li> 'delete_all'
 *                                 <li> 'status'
 *                                 <li> 'collect_graphs'
 *                                 <li> 'restore_graphs'
 *                         </ul>
 * @param {String} action_arg
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'server_id':
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.alter_graph = function(graph_name, action, action_arg, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_graph(graph_name, action, action_arg, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        action: action,
        action_arg: action_arg,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/graph", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.alter_model_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_model_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_name: request.model_name,
        action: request.action,
        value: request.value,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/model", actual_request, callback);
};

/**
 *
 * @param {String} model_name
 * @param {String} action
 *                         Supported values:
 *                         <ul>
 *                                 <li> 'container'
 *                                 <li> 'registry'
 *                                 <li> 'refresh'
 *                                 <li> 'stop_deployment'
 *                         </ul>
 * @param {String} value
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.alter_model = function(model_name, action, value, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_model(model_name, action, value, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_name: model_name,
        action: action,
        value: value,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/model", actual_request, callback);
};

/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_resource_group_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_resource_group_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        tier_attributes: (request.tier_attributes !== undefined && request.tier_attributes !== null) ? request.tier_attributes : {},
        ranking: (request.ranking !== undefined && request.ranking !== null) ? request.ranking : "",
        adjoining_resource_group: (request.adjoining_resource_group !== undefined && request.adjoining_resource_group !== null) ? request.adjoining_resource_group : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/resourcegroup", actual_request, callback);
};

/**
 * Alters the properties of an exisiting resource group to facilitate resource
 * management.
 *
 * @param {String} name  Name of the group to be altered. Must be an existing
 *                       resource group name or an empty string when used
 *                       inconjunction with the is_default_group option.
 * @param {Object} tier_attributes  Optional map containing tier names and
 *                                  their respective attribute group limits.
 *                                  The only valid attribute limit that can be
 *                                  set is max_memory (in bytes) for the VRAM &
 *                                  RAM tiers.
 *                                  For instance, to set max VRAM capacity to
 *                                  1GB and max RAM capacity to 10GB, use:
 *                                  {'VRAM':{'max_memory':'1000000000'},
 *                                  'RAM':{'max_memory':'10000000000'}}
 *                                  <ul>
 *                                          <li> 'max_memory': Maximum amount
 *                                  of memory usable in the given tier at one
 *                                  time for this group.
 *                                  </ul>
 * @param {String} ranking  If the resource group ranking is to be updated,
 *                          this indicates the relative ranking among existing
 *                          resource groups where this resource group will be
 *                          moved; leave blank if not changing the ranking.
 *                          When using <code>before</code> or
 *                          <code>after</code>, specify which resource group
 *                          this one will be inserted before or after in
 *                          <code>adjoining_resource_group</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> ''
 *                                  <li> 'first'
 *                                  <li> 'last'
 *                                  <li> 'before'
 *                                  <li> 'after'
 *                          </ul>
 *                          The default value is ''.
 * @param {String} adjoining_resource_group  If <code>ranking</code> is
 *                                           <code>before</code> or
 *                                           <code>after</code>, this field
 *                                           indicates the resource group
 *                                           before or after which the current
 *                                           group will be placed; otherwise,
 *                                           leave blank.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'max_cpu_concurrency': Maximum number
 *                          of simultaneous threads that will be used to
 *                          execute a request for this group.
 *                                  <li> 'max_data': Maximum amount of
 *                          cumulative ram usage regardless of tier status for
 *                          this group.
 *                                  <li> 'max_scheduling_priority': Maximum
 *                          priority of a scheduled task for this group.
 *                                  <li> 'max_tier_priority': Maximum priority
 *                          of a tiered object for this group.
 *                                  <li> 'is_default_group': If
 *                          <code>true</code>, this request applies to the
 *                          global default resource group. It is an error for
 *                          this field to be <code>true</code> when the
 *                          <code>name</code> field is also populated.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'persist': If <code>true</code> and a
 *                          system-level change was requested, the system
 *                          configuration will be written to disk upon
 *                          successful application of this request. This will
 *                          commit the changes from this request and any
 *                          additional in-memory modifications.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_resource_group = function(name, tier_attributes, ranking, adjoining_resource_group, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_resource_group(name, tier_attributes, ranking, adjoining_resource_group, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        tier_attributes: (tier_attributes !== undefined && tier_attributes !== null) ? tier_attributes : {},
        ranking: (ranking !== undefined && ranking !== null) ? ranking : "",
        adjoining_resource_group: (adjoining_resource_group !== undefined && adjoining_resource_group !== null) ? adjoining_resource_group : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/resourcegroup", actual_request, callback);
};

/**
 * Alters a Role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        action: request.action,
        value: request.value,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/role", actual_request, callback);
};

/**
 * Alters a Role.
 *
 * @param {String} name  Name of the role to be altered. Must be an existing
 *                       role.
 * @param {String} action  Modification operation to be applied to the role.
 *                         Supported values:
 *                         <ul>
 *                                 <li> 'set_resource_group': Sets the resource
 *                         group for an internal role. The resource group must
 *                         exist, otherwise, an empty string assigns the role
 *                         to the default resource group.
 *                         </ul>
 * @param {String} value  The value of the modification, depending on
 *                        <code>action</code>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_role = function(name, action, value, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_role(name, action, value, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        action: action,
        value: value,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/role", actual_request, callback);
};

/**
 * Used to change the name of a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in <code>schema_name</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_schema_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_schema_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: request.schema_name,
        action: request.action,
        value: request.value,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/schema", actual_request, callback);
};

/**
 * Used to change the name of a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in <code>schema_name</code>.
 *
 * @param {String} schema_name  Name of the schema to be altered.
 * @param {String} action  Modification operation to be applied
 *                         Supported values:
 *                         <ul>
 *                                 <li> 'rename_schema': Renames a schema to
 *                         <code>value</code>. Has the same naming restrictions
 *                         as <a href="../../../concepts/tables/"
 *                         target="_top">tables</a>.
 *                         </ul>
 * @param {String} value  The value of the modification, depending on
 *                        <code>action</code>.  For now the only value of
 *                        <code>action</code> is <code>rename_schema</code>.
 *                        In this case the value is the new name of the schema.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_schema = function(schema_name, action, value, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_schema(schema_name, action, value, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: schema_name,
        action: action,
        value: value,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/schema", actual_request, callback);
};

/**
 * The {@linkcode GPUdb#alter_system_properties} endpoint is primarily used
 * to simplify the testing of the system and is not expected to be used during
 * normal execution.  Commands are given through the
 * <code>property_updates_map</code> whose keys are commands and values are
 * strings representing integer values (for example '8000') or boolean values
 * ('true' or 'false').
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_system_properties_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_system_properties_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        property_updates_map: request.property_updates_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/system/properties", actual_request, callback);
};

/**
 * The {@linkcode GPUdb#alter_system_properties} endpoint is primarily used
 * to simplify the testing of the system and is not expected to be used during
 * normal execution.  Commands are given through the
 * <code>property_updates_map</code> whose keys are commands and values are
 * strings representing integer values (for example '8000') or boolean values
 * ('true' or 'false').
 *
 * @param {Object} property_updates_map  Map containing the properties of the
 *                                       system to be updated. Error if empty.
 *                                       <ul>
 *                                               <li> 'sm_omp_threads': Set the
 *                                       number of OpenMP threads that will be
 *                                       used to service filter & aggregation
 *                                       requests to the specified integer
 *                                       value.
 *                                               <li> 'kernel_omp_threads': Set
 *                                       the number of kernel OpenMP threads to
 *                                       the specified integer value.
 *                                               <li>
 *                                       'concurrent_kernel_execution': Enables
 *                                       concurrent kernel execution if the
 *                                       value is <code>true</code> and
 *                                       disables it if the value is
 *                                       <code>false</code>.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                               <li>
 *                                       'subtask_concurrency_limit': Sets the
 *                                       maximum number of simultaneous threads
 *                                       allocated to a given request, on each
 *                                       rank. Note that thread allocation may
 *                                       also be limted by resource group
 *                                       limits and/or system load.
 *                                               <li> 'chunk_size': Sets the
 *                                       number of records per chunk to be used
 *                                       for all new tables.
 *                                               <li> 'evict_columns': Attempts
 *                                       to evict columns from memory to the
 *                                       persistent store.  Value string is a
 *                                       semicolon separated list of entries,
 *                                       each entry being a table name
 *                                       optionally followed by a comma and a
 *                                       comma separated list of column names
 *                                       to attempt to evict.  An empty value
 *                                       string will attempt to evict all
 *                                       tables and columns.
 *                                               <li> 'execution_mode': Sets
 *                                       the execution_mode for kernel
 *                                       executions to the specified string
 *                                       value. Possible values are host,
 *                                       device, default (engine decides) or an
 *                                       integer value that indicates max chunk
 *                                       size to exec on host
 *                                               <li>
 *                                       'external_files_directory': Sets the
 *                                       root directory path where external
 *                                       table data files are accessed from.
 *                                       Path must exist on the head node
 *                                               <li> 'flush_to_disk': Flushes
 *                                       any changes to any tables to the
 *                                       persistent store.  These changes
 *                                       include updates to the vector store,
 *                                       object store, and text search store,
 *                                       Value string is ignored
 *                                               <li> 'clear_cache': Clears
 *                                       cached results.  Useful to allow
 *                                       repeated timing of endpoints.  Value
 *                                       string is the name of the table for
 *                                       which to clear the cached results, or
 *                                       an empty string to clear the cached
 *                                       results for all tables.
 *                                               <li> 'communicator_test':
 *                                       Invoke the communicator test and
 *                                       report timing results. Value string is
 *                                       is a semicolon separated list of
 *                                       [key]=[value] expressions.
 *                                       Expressions are:
 *                                       num_transactions=[num] where num is
 *                                       the number of request reply
 *                                       transactions to invoke per test;
 *                                       message_size=[bytes] where bytes is
 *                                       the size in bytes of the messages to
 *                                       send; check_values=[enabled] where if
 *                                       enabled is true the value of the
 *                                       messages received are verified.
 *                                               <li>
 *                                       'set_message_timers_enabled': Enables
 *                                       the communicator test to collect
 *                                       additional timing statistics when the
 *                                       value string is <code>true</code>.
 *                                       Disables collecting statistics when
 *                                       the value string is <code>false</code>
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                               <li> 'network_speed': Invoke
 *                                       the network speed test and report
 *                                       timing results. Value string is a
 *                                       semicolon-separated list of
 *                                       [key]=[value] expressions.  Valid
 *                                       expressions are: seconds=[time] where
 *                                       time is the time in seconds to run the
 *                                       test; data_size=[bytes] where bytes is
 *                                       the size in bytes of the block to be
 *                                       transferred; threads=[number of
 *                                       threads]; to_ranks=[space-separated
 *                                       list of ranks] where the list of ranks
 *                                       is the ranks that rank 0 will send
 *                                       data to and get data from. If to_ranks
 *                                       is unspecified then all worker ranks
 *                                       are used.
 *                                               <li> 'request_timeout': Number
 *                                       of minutes after which filtering
 *                                       (e.g., {@linkcode GPUdb#filter}) and
 *                                       aggregating (e.g.,
 *                                       {@linkcode GPUdb#aggregate_group_by})
 *                                       queries will timeout.  The default
 *                                       value is '20'.
 *                                               <li> 'max_get_records_size':
 *                                       The maximum number of records the
 *                                       database will serve for a given data
 *                                       retrieval call.  The default value is
 *                                       '20000'.
 *                                               <li> 'enable_audit': Enable or
 *                                       disable auditing.
 *                                               <li> 'audit_headers': Enable
 *                                       or disable auditing of request
 *                                       headers.
 *                                               <li> 'audit_body': Enable or
 *                                       disable auditing of request bodies.
 *                                               <li> 'audit_data': Enable or
 *                                       disable auditing of request data.
 *                                               <li> 'audit_response': Enable
 *                                       or disable auditing of response
 *                                       information.
 *                                               <li> 'shadow_agg_size': Size
 *                                       of the shadow aggregate chunk cache in
 *                                       bytes.  The default value is
 *                                       '10000000'.
 *                                               <li> 'shadow_filter_size':
 *                                       Size of the shadow filter chunk cache
 *                                       in bytes.  The default value is
 *                                       '10000000'.
 *                                               <li>
 *                                       'synchronous_compression': compress
 *                                       vector on set_compression (instead of
 *                                       waiting for background thread).  The
 *                                       default value is 'false'.
 *                                               <li>
 *                                       'enable_overlapped_equi_join': Enable
 *                                       overlapped-equi-join filter.  The
 *                                       default value is 'true'.
 *                                               <li> 'kafka_batch_size':
 *                                       Maximum number of records to be read
 *                                       in a single kafka batched request.
 *                                       The default value is '1000'.
 *                                               <li> 'kafka_wait_time':
 *                                       Maximum number of seconds to wait in a
 *                                       single kafka batched request.  The
 *                                       default value is '30'.
 *                                               <li> 'kafka_timeout': Number
 *                                       of seconds after which kakfa poll will
 *                                       timeout if datasource has no records.
 *                                       The default value is '5'.
 *                                       </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'persist': If <code>true</code> the
 *                          system configuration will be written to disk upon
 *                          successful application of this request. This will
 *                          commit the changes from this request and any
 *                          additional in-memory modifications.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_system_properties = function(property_updates_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_system_properties(property_updates_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        property_updates_map: property_updates_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/system/properties", actual_request, callback);
};

/**
 * Apply various modifications to a table or view.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * <p>
 * External tables cannot be modified except for their refresh method.
 * <p>
 * Create or delete an <a href="../../../concepts/indexes/#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Create or delete a <a href="../../../concepts/tables/#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../../concepts/tables/#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../../concepts/tables/#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../../concepts/materialized_views/" target="_top">materialized
 * view</a> or an
 * <a href="../../../concepts/external_tables/" target="_top">external
 * table</a>.
 * <p>
 * Set the <a href="../../../concepts/ttl/" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables or views.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        action: request.action,
        value: request.value,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/table", actual_request, callback);
};

/**
 * Apply various modifications to a table or view.  The
 * available modifications include the following:
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 * <p>
 * External tables cannot be modified except for their refresh method.
 * <p>
 * Create or delete an <a href="../../../concepts/indexes/#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Create or delete a <a href="../../../concepts/tables/#foreign-key"
 * target="_top">foreign key</a>
 * on a particular column.
 * <p>
 * Manage a
 * <a href="../../../concepts/tables/#partitioning-by-range"
 * target="_top">range-partitioned</a> or a
 * <a href="../../../concepts/tables/#partitioning-by-list-manual"
 * target="_top">manual list-partitioned</a>
 * table's partitions.
 * <p>
 * Set (or reset) the <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>
 * of a table or view.
 * <p>
 * Refresh and manage the refresh mode of a
 * <a href="../../../concepts/materialized_views/" target="_top">materialized
 * view</a> or an
 * <a href="../../../concepts/external_tables/" target="_top">external
 * table</a>.
 * <p>
 * Set the <a href="../../../concepts/ttl/" target="_top">time-to-live
 * (TTL)</a>. This can be applied
 * to tables or views.
 * <p>
 * Set the global access mode (i.e. locking) for a table. This setting trumps
 * any
 * role-based access controls that may be in place; e.g., a user with write
 * access
 * to a table marked read-only will not be able to insert records into it. The
 * mode
 * can be set to read-only, write-only, read/write, and no access.
 *
 * @param {String} table_name  Table on which the operation will be performed,
 *                             in [schema_name.]table_name format, using
 *                             standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table or view.
 * @param {String} action  Modification operation to be applied
 *                         Supported values:
 *                         <ul>
 *                                 <li> 'allow_homogeneous_tables': No longer
 *                         supported; action will be ignored.
 *                                 <li> 'create_index': Creates either a <a
 *                         href="../../../concepts/indexes/#column-index"
 *                         target="_top">column (attribute) index</a> or <a
 *                         href="../../../concepts/indexes/#chunk-skip-index"
 *                         target="_top">chunk skip index</a>, depending on the
 *                         specified <code>index_type</code>, on the column
 *                         name specified in <code>value</code>. If this column
 *                         already has the specified index, an error will be
 *                         returned.
 *                                 <li> 'delete_index': Deletes either a <a
 *                         href="../../../concepts/indexes/#column-index"
 *                         target="_top">column (attribute) index</a> or <a
 *                         href="../../../concepts/indexes/#chunk-skip-index"
 *                         target="_top">chunk skip index</a>, depending on the
 *                         specified <code>index_type</code>, on the column
 *                         name specified in <code>value</code>. If this column
 *                         does not have the specified index, an error will be
 *                         returned.
 *                                 <li> 'move_to_collection':
 *                         [DEPRECATED--please use <code>move_to_schema</code>
 *                         and use {@linkcode GPUdb#create_schema} to create
 *                         the schema if non-existent]  Moves a table or view
 *                         into a schema named <code>value</code>.  If the
 *                         schema provided is non-existent, it will be
 *                         automatically created.
 *                                 <li> 'move_to_schema': Moves a table or view
 *                         into a schema named <code>value</code>.  If the
 *                         schema provided is nonexistent, an error will be
 *                         thrown. If <code>value</code> is empty, then the
 *                         table or view will be placed in the user's default
 *                         schema.
 *                                 <li> 'protected': No longer used.
 *                         Previously set whether the given
 *                         <code>table_name</code> should be protected or not.
 *                         The <code>value</code> would have been either 'true'
 *                         or 'false'.
 *                                 <li> 'rename_table': Renames a table or view
 *                         within its current schema to <code>value</code>. Has
 *                         the same naming restrictions as <a
 *                         href="../../../concepts/tables/"
 *                         target="_top">tables</a>.
 *                                 <li> 'ttl': Sets the <a
 *                         href="../../../concepts/ttl/"
 *                         target="_top">time-to-live</a> in minutes of the
 *                         table or view specified in <code>table_name</code>.
 *                                 <li> 'add_column': Adds the column specified
 *                         in <code>value</code> to the table specified in
 *                         <code>table_name</code>.  Use
 *                         <code>column_type</code> and
 *                         <code>column_properties</code> in
 *                         <code>options</code> to set the column's type and
 *                         properties, respectively.
 *                                 <li> 'change_column': Changes type and
 *                         properties of the column specified in
 *                         <code>value</code>.  Use <code>column_type</code>
 *                         and <code>column_properties</code> in
 *                         <code>options</code> to set the column's type and
 *                         properties, respectively. Note that primary key
 *                         and/or shard key columns cannot be changed. All
 *                         unchanging column properties must be listed for the
 *                         change to take place, e.g., to add dictionary
 *                         encoding to an existing 'char4' column, both 'char4'
 *                         and 'dict' must be specified in the
 *                         <code>options</code> map.
 *                                 <li> 'set_column_compression': No longer
 *                         supported; action will be ignored.
 *                                 <li> 'delete_column': Deletes the column
 *                         specified in <code>value</code> from the table
 *                         specified in <code>table_name</code>.
 *                                 <li> 'create_foreign_key': Creates a <a
 *                         href="../../../concepts/tables/#foreign-key"
 *                         target="_top">foreign key</a> specified in
 *                         <code>value</code> using the format
 *                         '(source_column_name [, ...]) references
 *                         target_table_name(primary_key_column_name [, ...])
 *                         [as foreign_key_name]'.
 *                                 <li> 'delete_foreign_key': Deletes a <a
 *                         href="../../../concepts/tables/#foreign-key"
 *                         target="_top">foreign key</a>.  The
 *                         <code>value</code> should be the foreign_key_name
 *                         specified when creating the key or the complete
 *                         string used to define it.
 *                                 <li> 'add_partition': Adds the partition
 *                         specified in <code>value</code>, to either a <a
 *                         href="../../../concepts/tables/#partitioning-by-range"
 *                         target="_top">range-partitioned</a> or <a
 *                         href="../../../concepts/tables/#partitioning-by-list-manual"
 *                         target="_top">manual list-partitioned</a> table.
 *                                 <li> 'remove_partition': Removes the
 *                         partition specified in <code>value</code> (and
 *                         relocates all of its data to the default partition)
 *                         from either a <a
 *                         href="../../../concepts/tables/#partitioning-by-range"
 *                         target="_top">range-partitioned</a> or <a
 *                         href="../../../concepts/tables/#partitioning-by-list-manual"
 *                         target="_top">manual list-partitioned</a> table.
 *                                 <li> 'delete_partition': Deletes the
 *                         partition specified in <code>value</code> (and all
 *                         of its data) from either a <a
 *                         href="../../../concepts/tables/#partitioning-by-range"
 *                         target="_top">range-partitioned</a> or <a
 *                         href="../../../concepts/tables/#partitioning-by-list-manual"
 *                         target="_top">manual list-partitioned</a> table.
 *                                 <li> 'set_global_access_mode': Sets the
 *                         global access mode (i.e. locking) for the table
 *                         specified in <code>table_name</code>. Specify the
 *                         access mode in <code>value</code>. Valid modes are
 *                         'no_access', 'read_only', 'write_only' and
 *                         'read_write'.
 *                                 <li> 'refresh': For a <a
 *                         href="../../../concepts/materialized_views/"
 *                         target="_top">materialized view</a>, replays all the
 *                         table creation commands required to create the view.
 *                         For an <a href="../../../concepts/external_tables/"
 *                         target="_top">external table</a>, reloads all data
 *                         in the table from its associated source files or <a
 *                         href="../../../concepts/data_sources/"
 *                         target="_top">data source</a>.
 *                                 <li> 'set_refresh_method': For a <a
 *                         href="../../../concepts/materialized_views/"
 *                         target="_top">materialized view</a>, sets the method
 *                         by which the view is refreshed to the method
 *                         specified in <code>value</code> - one of 'manual',
 *                         'periodic', or 'on_change'.  For an <a
 *                         href="../../../concepts/external_tables/"
 *                         target="_top">external table</a>, sets the method by
 *                         which the table is refreshed to the method specified
 *                         in <code>value</code> - either 'manual' or
 *                         'on_start'.
 *                                 <li> 'set_refresh_start_time': Sets the time
 *                         to start periodic refreshes of this <a
 *                         href="../../../concepts/materialized_views/"
 *                         target="_top">materialized view</a> to the datetime
 *                         string specified in <code>value</code> with format
 *                         'YYYY-MM-DD HH:MM:SS'.  Subsequent refreshes occur
 *                         at the specified time + N * the refresh period.
 *                                 <li> 'set_refresh_period': Sets the time
 *                         interval in seconds at which to refresh this <a
 *                         href="../../../concepts/materialized_views/"
 *                         target="_top">materialized view</a> to the value
 *                         specified in <code>value</code>.  Also, sets the
 *                         refresh method to periodic if not already set.
 *                                 <li> 'set_refresh_execute_as': Sets the user
 *                         name to refresh this <a
 *                         href="../../../concepts/materialized_views/"
 *                         target="_top">materialized view</a> to the value
 *                         specified in <code>value</code>.
 *                                 <li> 'remove_text_search_attributes':
 *                         Removes <a
 *                         href="../../../concepts/full_text_search/"
 *                         target="_top">text search</a> attribute from all
 *                         columns.
 *                                 <li> 'set_strategy_definition': Sets the <a
 *                         href="../../../rm/concepts/#tier-strategies"
 *                         target="_top">tier strategy</a> for the table and
 *                         its columns to the one specified in
 *                         <code>value</code>, replacing the existing tier
 *                         strategy in its entirety.
 *                                 <li> 'cancel_datasource_subscription':
 *                         Permanently unsubscribe a data source that is
 *                         loading continuously as a stream. The data source
 *                         can be kafka / S3 / Azure.
 *                                 <li> 'pause_datasource_subscription':
 *                         Temporarily unsubscribe a data source that is
 *                         loading continuously as a stream. The data source
 *                         can be kafka / S3 / Azure.
 *                                 <li> 'resume_datasource_subscription':
 *                         Resubscribe to a paused data source subscription.
 *                         The data source can be kafka / S3 / Azure.
 *                                 <li> 'change_owner': Change the owner
 *                         resource group of the table.
 *                         </ul>
 * @param {String} value  The value of the modification, depending on
 *                        <code>action</code>.  For example, if
 *                        <code>action</code> is <code>add_column</code>, this
 *                        would be the column name; while the column's
 *                        definition would be covered by the
 *                        <code>column_type</code>,
 *                        <code>column_properties</code>,
 *                        <code>column_default_value</code>, and
 *                        <code>add_column_expression</code> in
 *                        <code>options</code>.  If <code>action</code> is
 *                        <code>ttl</code>, it would be the number of minutes
 *                        for the new TTL. If <code>action</code> is
 *                        <code>refresh</code>, this field would be blank.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'action':
 *                                  <li> 'column_name':
 *                                  <li> 'table_name':
 *                                  <li> 'column_default_value': When adding a
 *                          column, set a default value for existing records.
 *                          For nullable columns, the default value will be
 *                          null, regardless of data type.
 *                                  <li> 'column_properties': When adding or
 *                          changing a column, set the column properties
 *                          (strings, separated by a comma: data, store_only,
 *                          text_search, char8, int8 etc).
 *                                  <li> 'column_type': When adding or changing
 *                          a column, set the column type (strings, separated
 *                          by a comma: int, double, string, null etc).
 *                                  <li> 'compression_type': No longer
 *                          supported; option will be ignored.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'none'
 *                                  <li> 'snappy'
 *                                  <li> 'lz4'
 *                                  <li> 'lz4hc'
 *                          </ul>
 *                          The default value is 'snappy'.
 *                                  <li> 'copy_values_from_column':
 *                          [DEPRECATED--please use
 *                          <code>add_column_expression</code> instead.]
 *                                  <li> 'rename_column': When changing a
 *                          column, specify new column name.
 *                                  <li> 'validate_change_column': When
 *                          changing a column, validate the change before
 *                          applying it (or not).
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': Validate all values. A value
 *                          too large (or too long) for the new type will
 *                          prevent any change.
 *                                  <li> 'false': When a value is too large or
 *                          long, it will be truncated.
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'update_last_access_time': Indicates
 *                          whether the <a href="../../../concepts/ttl/"
 *                          target="_top">time-to-live</a> (TTL) expiration
 *                          countdown timer should be reset to the table's TTL.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': Reset the expiration countdown
 *                          timer to the table's configured TTL.
 *                                  <li> 'false': Don't reset the timer;
 *                          expiration countdown will continue from where it
 *                          is, as if the table had not been accessed.
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'add_column_expression': When adding a
 *                          column, an optional expression to use for the new
 *                          column's values. Any valid expression may be used,
 *                          including one containing references to existing
 *                          columns in the same table.
 *                                  <li> 'strategy_definition': Optional
 *                          parameter for specifying the <a
 *                          href="../../../rm/concepts/#tier-strategies"
 *                          target="_top">tier strategy</a> for the table and
 *                          its columns when <code>action</code> is
 *                          <code>set_strategy_definition</code>, replacing the
 *                          existing tier strategy in its entirety.
 *                                  <li> 'index_type': Type of index to create,
 *                          when <code>action</code> is
 *                          <code>create_index</code>, or to delete, when
 *                          <code>action</code> is <code>delete_index</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'column': Create or delete a <a
 *                          href="../../../concepts/indexes/#column-index"
 *                          target="_top">column (attribute) index</a>.
 *                                  <li> 'chunk_skip': Create or delete a <a
 *                          href="../../../concepts/indexes/#chunk-skip-index"
 *                          target="_top">chunk skip index</a>.
 *                                  <li> 'geospatial': Create or delete a
 *                          geospatial index
 *                          </ul>
 *                          The default value is 'column'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table = function(table_name, action, value, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table(table_name, action, value, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        action: action,
        value: value,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/table", actual_request, callback);
};

/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../../concepts/indexes/#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_columns_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_columns_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_alterations: request.column_alterations,
        options: request.options
    };

    this.submit_request("/alter/table/columns", actual_request, callback);
};

/**
 * Apply various modifications to columns in a table, view.  The available
 * modifications include the following:
 * <p>
 * Create or delete an <a href="../../../concepts/indexes/#column-index"
 * target="_top">index</a> on a
 * particular column. This can speed up certain operations when using
 * expressions
 * containing equality or relational operators on indexed columns. This only
 * applies to tables.
 * <p>
 * Manage a table's columns--a column can be added, removed, or have its
 * <a href="../../../concepts/types/" target="_top">type and properties</a>
 * modified, including whether it is
 * <a href="../../../concepts/dictionary_encoding/" target="_top">dictionary
 * encoded</a> or not.
 *
 * @param {String} table_name  Table on which the operation will be performed.
 *                             Must be an existing table or view, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {Object[]} column_alterations  List of alter table add/delete/change
 *                                       column requests - all for the same
 *                                       table. Each request is a map that
 *                                       includes 'column_name', 'action' and
 *                                       the options specific for the action.
 *                                       Note that the same options as in alter
 *                                       table requests but in the same map as
 *                                       the column name and the action. For
 *                                       example:
 *                                       [{'column_name':'col_1','action':'change_column','rename_column':'col_2'},{'column_name':'col_1','action':'add_column',
 *                                       'type':'int','default_value':'1'}]
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_columns = function(table_name, column_alterations, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_columns(table_name, column_alterations, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_alterations: column_alterations,
        options: options
    };

    this.submit_request("/alter/table/columns", actual_request, callback);
};

/**
 * Updates (adds or changes) metadata for tables. The metadata key and
 * values must both be strings. This is an easy way to annotate whole tables
 * rather
 * than single records within tables.  Some examples of metadata are owner of
 * the
 * table, table creation timestamp etc.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_metadata_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_metadata_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        metadata_map: request.metadata_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/table/metadata", actual_request, callback);
};

/**
 * Updates (adds or changes) metadata for tables. The metadata key and
 * values must both be strings. This is an easy way to annotate whole tables
 * rather
 * than single records within tables.  Some examples of metadata are owner of
 * the
 * table, table creation timestamp etc.
 *
 * @param {String[]} table_names  Names of the tables whose metadata will be
 *                                updated, in [schema_name.]table_name format,
 *                                using standard <a
 *                                href="../../../concepts/tables/#table-name-resolution"
 *                                target="_top">name resolution rules</a>.  All
 *                                specified tables must exist, or an error will
 *                                be returned.
 * @param {Object} metadata_map  A map which contains the metadata of the
 *                               tables that are to be updated. Note that only
 *                               one map is provided for all the tables; so the
 *                               change will be applied to every table. If the
 *                               provided map is empty, then all existing
 *                               metadata for the table(s) will be cleared.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_metadata = function(table_names, metadata_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_metadata(table_names, metadata_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        metadata_map: metadata_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/table/metadata", actual_request, callback);
};

/**
 * Alters a table monitor previously created with
 * {@linkcode GPUdb#create_table_monitor}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_monitor_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_monitor_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        topic_id: request.topic_id,
        monitor_updates_map: request.monitor_updates_map,
        options: request.options
    };

    this.submit_request("/alter/tablemonitor", actual_request, callback);
};

/**
 * Alters a table monitor previously created with
 * {@linkcode GPUdb#create_table_monitor}.
 *
 * @param {String} topic_id  The topic ID returned by
 *                           {@linkcode GPUdb#create_table_monitor}.
 * @param {Object} monitor_updates_map  Map containing the properties of the
 *                                      table monitor to be updated. Error if
 *                                      empty.
 *                                      <ul>
 *                                              <li> 'schema_name': Updates the
 *                                      schema name.  If
 *                                      <code>schema_name</code>
 *                                      doesn't exist, an error will be thrown.
 *                                      If <code>schema_name</code> is empty,
 *                                      then the user's
 *                                      default schema will be used.
 *                                      </ul>
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_monitor = function(topic_id, monitor_updates_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_monitor(topic_id, monitor_updates_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        topic_id: topic_id,
        monitor_updates_map: monitor_updates_map,
        options: options
    };

    this.submit_request("/alter/tablemonitor", actual_request, callback);
};

/**
 * Alters properties of an exisiting
 * <a href="../../../rm/concepts/#storage-tiers" target="_top">tier</a> to
 * facilitate
 * <a href="../../../rm/concepts/" target="_top">resource management</a>.
 * <p>
 * To disable
 * <a href="../../../rm/concepts/#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>,
 * set both <code>high_watermark</code> and
 * <code>low_watermark</code> to 100.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_tier_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_tier_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/tier", actual_request, callback);
};

/**
 * Alters properties of an exisiting
 * <a href="../../../rm/concepts/#storage-tiers" target="_top">tier</a> to
 * facilitate
 * <a href="../../../rm/concepts/" target="_top">resource management</a>.
 * <p>
 * To disable
 * <a href="../../../rm/concepts/#watermark-based-eviction"
 * target="_top">watermark-based eviction</a>,
 * set both <code>high_watermark</code> and
 * <code>low_watermark</code> to 100.
 *
 * @param {String} name  Name of the tier to be altered. Must be an existing
 *                       tier group name.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'capacity': Maximum size in bytes this
 *                          tier may hold at once.
 *                                  <li> 'high_watermark': Threshold of usage
 *                          of this tier's resource that once exceeded, will
 *                          trigger watermark-based eviction from this tier.
 *                                  <li> 'low_watermark': Threshold of resource
 *                          usage that once fallen below after crossing the
 *                          <code>high_watermark</code>, will cease
 *                          watermark-based eviction from this tier.
 *                                  <li> 'persist': If <code>true</code> the
 *                          system configuration will be written to disk upon
 *                          successful application of this request. This will
 *                          commit the changes from this request and any
 *                          additional in-memory modifications.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_tier = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_tier(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/tier", actual_request, callback);
};

/**
 * Alters a user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_user_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_user_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        action: request.action,
        value: request.value,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/user", actual_request, callback);
};

/**
 * Alters a user.
 *
 * @param {String} name  Name of the user to be altered. Must be an existing
 *                       user.
 * @param {String} action  Modification operation to be applied to the user.
 *                         Supported values:
 *                         <ul>
 *                                 <li> 'set_password': Sets the password of
 *                         the user. The user must be an internal user.
 *                                 <li> 'set_resource_group': Sets the resource
 *                         group for an internal user. The resource group must
 *                         exist, otherwise, an empty string assigns the user
 *                         to the default resource group.
 *                                 <li> 'set_default_schema': Set the
 *                         default_schema for an internal user. An empty string
 *                         means the user will have no default schema.
 *                         </ul>
 * @param {String} value  The value of the modification, depending on
 *                        <code>action</code>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_user = function(name, action, value, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_user(name, action, value, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        action: action,
        value: value,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/user", actual_request, callback);
};

/**
 * Alters a video.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_video_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_video_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        path: request.path,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/video", actual_request, callback);
};

/**
 * Alters a video.
 *
 * @param {String} path  Fully-qualified <a href="../../../tools/kifs/"
 *                       target="_top">KiFS</a> path to the video to be
 *                       altered.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the video.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_video = function(path, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_video(path, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        path: path,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/video", actual_request, callback);
};

/**
 * Append (or insert) all records from a source table
 * (specified by <code>source_table_name</code>) to a particular target table
 * (specified by <code>table_name</code>). The field map
 * (specified by <code>field_map</code>) holds the user specified map of target
 * table
 * column names with their mapped source column names.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.append_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.append_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        source_table_name: request.source_table_name,
        field_map: request.field_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/append/records", actual_request, callback);
};

/**
 * Append (or insert) all records from a source table
 * (specified by <code>source_table_name</code>) to a particular target table
 * (specified by <code>table_name</code>). The field map
 * (specified by <code>field_map</code>) holds the user specified map of target
 * table
 * column names with their mapped source column names.
 *
 * @param {String} table_name  The table name for the records to be appended,
 *                             in [schema_name.]table_name format, using
 *                             standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table.
 * @param {String} source_table_name  The source table name to get records
 *                                    from, in [schema_name.]table_name format,
 *                                    using standard <a
 *                                    href="../../../concepts/tables/#table-name-resolution"
 *                                    target="_top">name resolution rules</a>.
 *                                    Must be an existing table name.
 * @param {Object} field_map  Contains the mapping of column names from the
 *                            target table (specified by
 *                            <code>table_name</code>) as the keys, and
 *                            corresponding column names or expressions (e.g.,
 *                            'col_name+1') from the source table (specified by
 *                            <code>source_table_name</code>). Must be existing
 *                            column names in source table and target table,
 *                            and their types must be matched. For details on
 *                            using expressions, see <a
 *                            href="../../../concepts/expressions/"
 *                            target="_top">Expressions</a>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'offset': A positive integer
 *                          indicating the number of initial results to skip
 *                          from <code>source_table_name</code>. Default is 0.
 *                          The minimum allowed value is 0. The maximum allowed
 *                          value is MAX_INT.  The default value is '0'.
 *                                  <li> 'limit': A positive integer indicating
 *                          the maximum number of results to be returned from
 *                          <code>source_table_name</code>. Or END_OF_SET
 *                          (-9999) to indicate that the max number of results
 *                          should be returned.  The default value is '-9999'.
 *                                  <li> 'expression': Optional filter
 *                          expression to apply to the
 *                          <code>source_table_name</code>.  The default value
 *                          is ''.
 *                                  <li> 'order_by': Comma-separated list of
 *                          the columns to be sorted by from source table
 *                          (specified by <code>source_table_name</code>),
 *                          e.g., 'timestamp asc, x desc'. The
 *                          <code>order_by</code> columns do not have to be
 *                          present in <code>field_map</code>.  The default
 *                          value is ''.
 *                                  <li> 'update_on_existing_pk': Specifies the
 *                          record collision policy for inserting the source
 *                          table records (specified by
 *                          <code>source_table_name</code>) into the target
 *                          table (specified by <code>table_name</code>) table
 *                          with a <a
 *                          href="../../../concepts/tables/#primary-keys"
 *                          target="_top">primary key</a>.  If set to
 *                          <code>true</code>, any existing target table record
 *                          with primary key values that match those of a
 *                          source table record being inserted will be replaced
 *                          by that new record.  If set to <code>false</code>,
 *                          any existing target table record with primary key
 *                          values that match those of a source table record
 *                          being inserted will remain unchanged and the new
 *                          record discarded.  If the specified table does not
 *                          have a primary key, then this option is ignored.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'truncate_strings': If set to
 *                          <code>true</code>, it allows inserting longer
 *                          strings into smaller charN string columns by
 *                          truncating the longer strings to fit.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.append_records = function(table_name, source_table_name, field_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.append_records(table_name, source_table_name, field_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        source_table_name: source_table_name,
        field_map: field_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/append/records", actual_request, callback);
};

/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_statistics_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_statistics_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: (request.table_name !== undefined && request.table_name !== null) ? request.table_name : "",
        column_name: (request.column_name !== undefined && request.column_name !== null) ? request.column_name : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/statistics", actual_request, callback);
};

/**
 * Clears statistics (cardinality, mean value, etc.) for a column in a
 * specified table.
 *
 * @param {String} table_name  Name of a table, in [schema_name.]table_name
 *                             format, using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>. Must be
 *                             an existing table.
 * @param {String} column_name  Name of the column in <code>table_name</code>
 *                              for which to clear statistics. The column must
 *                              be from an existing table. An empty string
 *                              clears statistics for all columns in the table.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_statistics = function(table_name, column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_statistics(table_name, column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: (table_name !== undefined && table_name !== null) ? table_name : "",
        column_name: (column_name !== undefined && column_name !== null) ? column_name : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/statistics", actual_request, callback);
};

/**
 * Clears (drops) one or all tables in the database cluster. The
 * operation is synchronous meaning that the table will be cleared before the
 * function returns. The response payload returns the status of the operation
 * along
 * with the name of the table that was cleared.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: (request.table_name !== undefined && request.table_name !== null) ? request.table_name : "",
        authorization: (request.authorization !== undefined && request.authorization !== null) ? request.authorization : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/table", actual_request, callback);
};

/**
 * Clears (drops) one or all tables in the database cluster. The
 * operation is synchronous meaning that the table will be cleared before the
 * function returns. The response payload returns the status of the operation
 * along
 * with the name of the table that was cleared.
 *
 * @param {String} table_name  Name of the table to be cleared, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>. Must be
 *                             an existing table. Empty string clears all
 *                             available tables, though this behavior is be
 *                             prevented by default via gpudb.conf parameter
 *                             'disable_clear_all'.
 * @param {String} authorization  No longer used. User can pass an empty
 *                                string.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>true</code> and if the table specified in
 *                          <code>table_name</code> does not exist no error is
 *                          returned. If <code>false</code> and if the table
 *                          specified in <code>table_name</code> does not exist
 *                          then an error is returned.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table = function(table_name, authorization, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table(table_name, authorization, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: (table_name !== undefined && table_name !== null) ? table_name : "",
        authorization: (authorization !== undefined && authorization !== null) ? authorization : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/table", actual_request, callback);
};

/**
 * Deactivates a table monitor previously created with
 * {@linkcode GPUdb#create_table_monitor}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_monitor_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_monitor_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        topic_id: request.topic_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/tablemonitor", actual_request, callback);
};

/**
 * Deactivates a table monitor previously created with
 * {@linkcode GPUdb#create_table_monitor}.
 *
 * @param {String} topic_id  The topic ID returned by
 *                           {@linkcode GPUdb#create_table_monitor}.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'keep_autogenerated_sink': If
 *                          <code>true</code>, the auto-generated <a
 *                          href="../../../concepts/data_sinks/"
 *                          target="_top">datasink</a> associated with this
 *                          monitor, if there is one, will be retained for
 *                          further use. If <code>false</code>, then the
 *                          auto-generated sink will be dropped if there are no
 *                          other monitors referencing it.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'clear_all_references': If
 *                          <code>true</code>, all references that share the
 *                          same <code>topic_id</code> will be cleared.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_monitor = function(topic_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_monitor(topic_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        topic_id: topic_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/tablemonitor", actual_request, callback);
};

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_trigger_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_trigger_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_id: request.trigger_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/trigger", actual_request, callback);
};

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 *
 * @param {String} trigger_id  ID for the trigger to be deactivated.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_trigger = function(trigger_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_trigger(trigger_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_id: trigger_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/trigger", actual_request, callback);
};

/**
 * Collect statistics for a column(s) in a specified table.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.collect_statistics_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.collect_statistics_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/collect/statistics", actual_request, callback);
};

/**
 * Collect statistics for a column(s) in a specified table.
 *
 * @param {String} table_name  Name of a table, in [schema_name.]table_name
 *                             format, using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table.
 * @param {String[]} column_names  List of one or more column names in
 *                                 <code>table_name</code> for which to collect
 *                                 statistics (cardinality, mean value, etc.).
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.collect_statistics = function(table_name, column_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.collect_statistics(table_name, column_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/collect/statistics", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.create_container_registry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_container_registry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        registry_name: request.registry_name,
        uri: request.uri,
        credential: request.credential,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/container/registry", actual_request, callback);
};

/**
 *
 * @param {String} registry_name
 * @param {String} uri
 * @param {String} credential
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'user_name': The default value is ''.
 *                                  <li> 'password': The default value is ''.
 *                                  <li> 'email': The default value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.create_container_registry = function(registry_name, uri, credential, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_container_registry(registry_name, uri, credential, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        registry_name: registry_name,
        uri: uri,
        credential: credential,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/container/registry", actual_request, callback);
};

/**
 * Create a new <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_credential_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_credential_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        credential_name: request.credential_name,
        type: request.type,
        identity: request.identity,
        secret: request.secret,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/credential", actual_request, callback);
};

/**
 * Create a new <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 *
 * @param {String} credential_name  Name of the credential to be created. Must
 *                                  contain only letters, digits, and
 *                                  underscores, and cannot begin with a digit.
 *                                  Must not match an existing credential name.
 * @param {String} type  Type of the credential to be created.
 *                       Supported values:
 *                       <ul>
 *                               <li> 'aws_access_key'
 *                               <li> 'aws_iam_role'
 *                               <li> 'azure_ad'
 *                               <li> 'azure_oauth'
 *                               <li> 'azure_sas'
 *                               <li> 'azure_storage_key'
 *                               <li> 'docker'
 *                               <li> 'gcs_service_account_id'
 *                               <li> 'gcs_service_account_keys'
 *                               <li> 'hdfs'
 *                               <li> 'jdbc'
 *                               <li> 'kafka'
 *                       </ul>
 * @param {String} identity  User of the credential to be created.
 * @param {String} secret  Password of the credential to be created.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_credential = function(credential_name, type, identity, secret, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_credential(credential_name, type, identity, secret, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        credential_name: credential_name,
        type: type,
        identity: identity,
        secret: secret,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/credential", actual_request, callback);
};

/**
 * Creates a <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>, which contains the
 * destination information for a data sink that is external to the database.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_datasink_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_datasink_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        destination: request.destination,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/datasink", actual_request, callback);
};

/**
 * Creates a <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>, which contains the
 * destination information for a data sink that is external to the database.
 *
 * @param {String} name  Name of the data sink to be created.
 * @param {String} destination  Destination for the output data in format
 *                              'destination_type://path[:port]'.
 *                              Supported destination types are 'http', 'https'
 *                              and 'kafka'.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'connection_timeout': Timeout in
 *                          seconds for connecting to this data sink
 *                                  <li> 'wait_timeout': Timeout in seconds for
 *                          waiting for a response from this data sink
 *                                  <li> 'credential': Name of the <a
 *                          href="../../../concepts/credentials/"
 *                          target="_top">credential</a> object to be used in
 *                          this data sink
 *                                  <li> 'kafka_topic_name': Name of the Kafka
 *                          topic to publish to if <code>destination</code> is
 *                          a Kafka broker
 *                                  <li> 'max_batch_size': Maximum number of
 *                          records per notification message.  The default
 *                          value is '1'.
 *                                  <li> 'max_message_size': Maximum size in
 *                          bytes of each notification message.  The default
 *                          value is '1000000'.
 *                                  <li> 'json_format': The desired format of
 *                          JSON encoded notifications message.
 *                          If <code>nested</code>, records are returned as an
 *                          array. Otherwise, only a single record per messages
 *                          is returned.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'flat'
 *                                  <li> 'nested'
 *                          </ul>
 *                          The default value is 'flat'.
 *                                  <li> 'jdbc_driver_jar_path': JDBC driver
 *                          jar file location
 *                                  <li> 'jdbc_driver_class_name': Name of the
 *                          JDBC driver class
 *                                  <li> 'skip_validation': Bypass validation
 *                          of connection to this data sink.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_datasink = function(name, destination, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_datasink(name, destination, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        destination: destination,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/datasink", actual_request, callback);
};

/**
 * Creates a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a>, which contains the
 * location and connection information for a data store that is external to the
 * database.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_datasource_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_datasource_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        location: request.location,
        user_name: request.user_name,
        password: request.password,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/datasource", actual_request, callback);
};

/**
 * Creates a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a>, which contains the
 * location and connection information for a data store that is external to the
 * database.
 *
 * @param {String} name  Name of the data source to be created.
 * @param {String} location  Location of the remote storage in
 *                           'storage_provider_type://[storage_path[:storage_port]]'
 *                           format.
 *                           Supported storage provider types are
 *                           'azure','gcs','hdfs','jdbc','kafka' and 's3'.
 * @param {String} user_name  Name of the remote system user; may be an empty
 *                            string
 * @param {String} password  Password for the remote system user; may be an
 *                           empty string
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'skip_validation': Bypass validation
 *                          of connection to remote source.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'connection_timeout': Timeout in
 *                          seconds for connecting to this storage provider
 *                                  <li> 'wait_timeout': Timeout in seconds for
 *                          reading from this storage provider
 *                                  <li> 'credential': Name of the Credential
 *                          object to be used in data source
 *                                  <li> 's3_bucket_name': Name of the Amazon
 *                          S3 bucket to use as the data source
 *                                  <li> 's3_region': Name of the Amazon S3
 *                          region where the given bucket is located
 *                                  <li> 's3_aws_role_arn': Amazon IAM Role ARN
 *                          which has required S3 permissions that can be
 *                          assumed for the given S3 IAM user
 *                                  <li> 's3_encryption_customer_algorithm':
 *                          Customer encryption algorithm used encrypting data
 *                                  <li> 's3_encryption_customer_key': Customer
 *                          encryption key to encrypt or decrypt data
 *                                  <li> 'hdfs_kerberos_keytab': Kerberos
 *                          keytab file location for the given HDFS user
 *                                  <li> 'hdfs_delegation_token': Delegation
 *                          token for the given HDFS user
 *                                  <li> 'hdfs_use_kerberos': Use kerberos
 *                          authentication for the given HDFS cluster
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'azure_storage_account_name': Name of
 *                          the Azure storage account to use as the data
 *                          source, this is valid only if tenant_id is
 *                          specified
 *                                  <li> 'azure_container_name': Name of the
 *                          Azure storage container to use as the data source
 *                                  <li> 'azure_tenant_id': Active Directory
 *                          tenant ID (or directory ID)
 *                                  <li> 'azure_sas_token': Shared access
 *                          signature token for Azure storage account to use as
 *                          the data source
 *                                  <li> 'azure_oauth_token': Oauth token to
 *                          access given storage container
 *                                  <li> 'gcs_bucket_name': Name of the Google
 *                          Cloud Storage bucket to use as the data source
 *                                  <li> 'gcs_project_id': Name of the Google
 *                          Cloud project to use as the data source
 *                                  <li> 'gcs_service_account_keys': Google
 *                          Cloud service account keys to use for
 *                          authenticating the data source
 *                                  <li> 'is_stream': To load from Azure/GCS/S3
 *                          as a stream continuously.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'kafka_topic_name': Name of the Kafka
 *                          topic to use as the data source
 *                                  <li> 'jdbc_driver_jar_path': JDBC driver
 *                          jar file location
 *                                  <li> 'jdbc_driver_class_name': Name of the
 *                          JDBC driver class
 *                                  <li> 'anonymous': Use anonymous connection
 *                          to storage provider--DEPRECATED: this is now the
 *                          default.  Specify use_managed_credentials for
 *                          non-anonymous connection.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'use_managed_credentials': When no
 *                          credentials are supplied, we use anonymous access
 *                          by default.  If this is set, we will use cloud
 *                          provider user settings.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'use_https': Use https to connect to
 *                          datasource if true, otherwise use http
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_datasource = function(name, location, user_name, password, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_datasource(name, location, user_name, password, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        location: location,
        user_name: user_name,
        password: password,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/datasource", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.create_delta_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_delta_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        delta_table_name: request.delta_table_name,
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/deltatable", actual_request, callback);
};

/**
 *
 * @param {String} delta_table_name
 * @param {String} table_name
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.create_delta_table = function(delta_table_name, table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_delta_table(delta_table_name, table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        delta_table_name: delta_table_name,
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/deltatable", actual_request, callback);
};

/**
 * Creates a new directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. The new
 * directory serves as a location in which the user can upload files using
 * {@linkcode GPUdb#upload_files}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_directory_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_directory_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        directory_name: request.directory_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/directory", actual_request, callback);
};

/**
 * Creates a new directory in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. The new
 * directory serves as a location in which the user can upload files using
 * {@linkcode GPUdb#upload_files}.
 *
 * @param {String} directory_name  Name of the directory in KiFS to be created.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_home_directory': When set, a
 *                          home directory is created for the user name
 *                          provided in the value. The
 *                          <code>directory_name</code> must be an empty string
 *                          in this case. The user must exist.
 *                                  <li> 'no_error_if_exists': If
 *                          <code>true</code>, does not return an error if the
 *                          directory already exists
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_directory = function(directory_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_directory(directory_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        directory_name: directory_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/directory", actual_request, callback);
};

/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        directed_graph: (request.directed_graph !== undefined && request.directed_graph !== null) ? request.directed_graph : true,
        nodes: request.nodes,
        edges: request.edges,
        weights: request.weights,
        restrictions: request.restrictions,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/graph", actual_request, callback);
};

/**
 * Creates a new graph network using given nodes, edges, weights, and
 * restrictions.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 *
 * @param {String} graph_name  Name of the graph resource to generate.
 * @param {Boolean} directed_graph  If set to <code>true</code>, the graph will
 *                                  be directed. If set to <code>false</code>,
 *                                  the graph will not be directed. Consult <a
 *                                  href="../../../graph_solver/network_graph_solver/#directed-graphs"
 *                                  target="_top">Directed Graphs</a> for more
 *                                  details.
 *                                  Supported values:
 *                                  <ul>
 *                                          <li> true
 *                                          <li> false
 *                                  </ul>
 *                                  The default value is true.
 * @param {String[]} nodes  Nodes represent fundamental topological units of a
 *                          graph.
 *                          Nodes must be specified using
 *                          <a
 *                          href="../../../graph_solver/network_graph_solver/#identifiers"
 *                          target="_top">identifiers</a>;
 *                          identifiers are grouped as
 *                          <a
 *                          href="../../../graph_solver/network_graph_solver/#id-combos"
 *                          target="_top">combinations</a>.
 *                          Identifiers can be used with existing column names,
 *                          e.g.,
 *                          'table.column AS NODE_ID', expressions, e.g.,
 *                          'ST_MAKEPOINT(column1, column2) AS NODE_WKTPOINT',
 *                          or constant values, e.g.,
 *                          '{9, 10, 11} AS NODE_ID'.
 *                          If using constant values in an identifier
 *                          combination, the number of values
 *                          specified must match across the combination.
 * @param {String[]} edges  Edges represent the required fundamental
 *                          topological unit of
 *                          a graph that typically connect nodes. Edges must be
 *                          specified using
 *                          <a
 *                          href="../../../graph_solver/network_graph_solver/#identifiers"
 *                          target="_top">identifiers</a>;
 *                          identifiers are grouped as
 *                          <a
 *                          href="../../../graph_solver/network_graph_solver/#id-combos"
 *                          target="_top">combinations</a>.
 *                          Identifiers can be used with existing column names,
 *                          e.g.,
 *                          'table.column AS EDGE_ID', expressions, e.g.,
 *                          'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME', or
 *                          constant values, e.g.,
 *                          "{'family', 'coworker'} AS EDGE_LABEL".
 *                          If using constant values in an identifier
 *                          combination, the number of values
 *                          specified must match across the combination.
 * @param {String[]} weights  Weights represent a method of informing the graph
 *                            solver of
 *                            the cost of including a given edge in a solution.
 *                            Weights must be specified
 *                            using
 *                            <a
 *                            href="../../../graph_solver/network_graph_solver/#identifiers"
 *                            target="_top">identifiers</a>;
 *                            identifiers are grouped as
 *                            <a
 *                            href="../../../graph_solver/network_graph_solver/#id-combos"
 *                            target="_top">combinations</a>.
 *                            Identifiers can be used with existing column
 *                            names, e.g.,
 *                            'table.column AS WEIGHTS_EDGE_ID', expressions,
 *                            e.g.,
 *                            'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED', or
 *                            constant values, e.g.,
 *                            '{4, 15} AS WEIGHTS_VALUESPECIFIED'.
 *                            If using constant values in an identifier
 *                            combination, the number of values specified
 *                            must match across the combination.
 * @param {String[]} restrictions  Restrictions represent a method of informing
 *                                 the graph
 *                                 solver which edges and/or nodes should be
 *                                 ignored for the solution. Restrictions
 *                                 must be specified using
 *                                 <a
 *                                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                                 target="_top">identifiers</a>;
 *                                 identifiers are grouped as
 *                                 <a
 *                                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                                 target="_top">combinations</a>.
 *                                 Identifiers can be used with existing column
 *                                 names, e.g.,
 *                                 'table.column AS RESTRICTIONS_EDGE_ID',
 *                                 expressions, e.g.,
 *                                 'column/2 AS RESTRICTIONS_VALUECOMPARED', or
 *                                 constant values, e.g.,
 *                                 '{0, 0, 0, 1} AS
 *                                 RESTRICTIONS_ONOFFCOMPARED'.
 *                                 If using constant values in an identifier
 *                                 combination, the number of values
 *                                 specified must match across the combination.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'merge_tolerance': If node geospatial
 *                          positions are input (e.g., WKTPOINT, X, Y),
 *                          determines the minimum separation allowed between
 *                          unique nodes. If nodes are within the tolerance of
 *                          each other, they will be merged as a single node.
 *                          The default value is '1.0E-5'.
 *                                  <li> 'recreate': If set to
 *                          <code>true</code> and the graph (using
 *                          <code>graph_name</code>) already exists, the graph
 *                          is deleted and recreated.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'save_persist': If set to
 *                          <code>true</code>, the graph will be saved in the
 *                          persist directory (see the <a
 *                          href="../../../config/#config-main-persistence"
 *                          target="_top">config reference</a> for more
 *                          information). If set to <code>false</code>, the
 *                          graph will be removed when the graph server is
 *                          shutdown.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'add_table_monitor': Adds a table
 *                          monitor to every table used in the creation of the
 *                          graph; this table monitor will trigger the graph to
 *                          update dynamically upon inserts to the source
 *                          table(s). Note that upon database restart, if
 *                          <code>save_persist</code> is also set to
 *                          <code>true</code>, the graph will be fully
 *                          reconstructed and the table monitors will be
 *                          reattached. For more details on table monitors, see
 *                          {@linkcode GPUdb#create_table_monitor}.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'graph_table': If specified, the
 *                          created graph is also created as a table with the
 *                          given name, in [schema_name.]table_name format,
 *                          using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a> and meeting
 *                          <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>.  The table
 *                          will have the following identifier columns:
 *                          'EDGE_ID', 'EDGE_NODE1_ID', 'EDGE_NODE2_ID'. If
 *                          left blank, no table is created.  The default value
 *                          is ''.
 *                                  <li> 'add_turns': Adds dummy 'pillowed'
 *                          edges around intersection nodes where there are
 *                          more than three edges so that additional weight
 *                          penalties can be imposed by the solve endpoints.
 *                          (increases the total number of edges).
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'is_partitioned':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'server_id': Indicates which graph
 *                          server(s) to send the request to. Default is to
 *                          send to the server with the most available memory.
 *                                  <li> 'use_rtree': Use an range tree
 *                          structure to accelerate and improve the accuracy of
 *                          snapping, especially to edges.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'label_delimiter': If provided the
 *                          label string will be split according to this
 *                          delimiter and each sub-string will be applied as a
 *                          separate label onto the specified edge.  The
 *                          default value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_graph = function(graph_name, directed_graph, nodes, edges, weights, restrictions, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_graph(graph_name, directed_graph, nodes, edges, weights, restrictions, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        directed_graph: (directed_graph !== undefined && directed_graph !== null) ? directed_graph : true,
        nodes: nodes,
        edges: edges,
        weights: weights,
        restrictions: restrictions,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/graph", actual_request, callback);
};

/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by
 * {@linkcode GPUdb#get_job}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_job_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_job_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        endpoint: request.endpoint,
        request_encoding: (request.request_encoding !== undefined && request.request_encoding !== null) ? request.request_encoding : "binary",
        data: request.data,
        data_str: request.data_str,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/job", actual_request, callback);
};

/**
 * Create a job which will run asynchronously. The response returns a job ID,
 * which can be used to query the status and result of the job. The status and
 * the result of the job upon completion can be requested by
 * {@linkcode GPUdb#get_job}.
 *
 * @param {String} endpoint  Indicates which endpoint to execute, e.g.
 *                           '/alter/table'.
 * @param {String} request_encoding  The encoding of the request payload for
 *                                   the job.
 *                                   Supported values:
 *                                   <ul>
 *                                           <li> 'binary'
 *                                           <li> 'json'
 *                                           <li> 'snappy'
 *                                   </ul>
 *                                   The default value is 'binary'.
 * @param {String} data  Binary-encoded payload for the job to be run
 *                       asynchronously.  The payload must contain the relevant
 *                       input parameters for the endpoint indicated in
 *                       <code>endpoint</code>.  Please see the documentation
 *                       for the appropriate endpoint to see what values must
 *                       (or can) be specified.  If this parameter is used,
 *                       then <code>request_encoding</code> must be
 *                       <code>binary</code> or <code>snappy</code>.
 * @param {String} data_str  JSON-encoded payload for the job to be run
 *                           asynchronously.  The payload must contain the
 *                           relevant input parameters for the endpoint
 *                           indicated in <code>endpoint</code>.  Please see
 *                           the documentation for the appropriate endpoint to
 *                           see what values must (or can) be specified.  If
 *                           this parameter is used, then
 *                           <code>request_encoding</code> must be
 *                           <code>json</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'remove_job_on_complete':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                                  <li> 'job_tag': Tag to use for submitted
 *                          job. The same tag could be used on backup cluster
 *                          to retrieve response for the job. Tags can use
 *                          letter, numbers, '_' and '-'
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_job = function(endpoint, request_encoding, data, data_str, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_job(endpoint, request_encoding, data, data_str, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        endpoint: endpoint,
        request_encoding: (request_encoding !== undefined && request_encoding !== null) ? request_encoding : "binary",
        data: data,
        data_str: data_str,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/job", actual_request, callback);
};

/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../../concepts/joins/"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../../concepts/joins/#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_join_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_join_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        join_table_name: request.join_table_name,
        table_names: request.table_names,
        column_names: request.column_names,
        expressions: (request.expressions !== undefined && request.expressions !== null) ? request.expressions : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/jointable", actual_request, callback);
};

/**
 * Creates a table that is the result of a SQL JOIN.
 * <p>
 * For join details and examples see: <a href="../../../concepts/joins/"
 * target="_top">Joins</a>.  For limitations, see <a
 * href="../../../concepts/joins/#limitations-cautions" target="_top">Join
 * Limitations and Cautions</a>.
 *
 * @param {String} join_table_name  Name of the join table to be created, in
 *                                  [schema_name.]table_name format, using
 *                                  standard <a
 *                                  href="../../../concepts/tables/#table-name-resolution"
 *                                  target="_top">name resolution rules</a> and
 *                                  meeting <a
 *                                  href="../../../concepts/tables/#table-naming-criteria"
 *                                  target="_top">table naming criteria</a>.
 * @param {String[]} table_names  The list of table names composing the join,
 *                                each in [schema_name.]table_name format,
 *                                using standard <a
 *                                href="../../../concepts/tables/#table-name-resolution"
 *                                target="_top">name resolution rules</a>.
 *                                Corresponds to a SQL statement FROM clause.
 * @param {String[]} column_names  List of member table columns or column
 *                                 expressions to be included in the join.
 *                                 Columns can be prefixed with
 *                                 'table_id.column_name', where 'table_id' is
 *                                 the table name or alias.  Columns can be
 *                                 aliased via the syntax 'column_name as
 *                                 alias'. Wild cards '*' can be used to
 *                                 include all columns across member tables or
 *                                 'table_id.*' for all of a single table's
 *                                 columns.  Columns and column expressions
 *                                 composing the join must be uniquely named or
 *                                 aliased--therefore, the '*' wild card cannot
 *                                 be used if column names aren't unique across
 *                                 all tables.
 * @param {String[]} expressions  An optional list of expressions to combine
 *                                and filter the joined tables.  Corresponds to
 *                                a SQL statement WHERE clause. For details
 *                                see: <a href="../../../concepts/expressions/"
 *                                target="_top">expressions</a>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>join_table_name</code>. This is
 *                          always allowed even if the caller does not have
 *                          permission to create tables. The generated name is
 *                          returned in <code>qualified_join_table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the join as part
 *                          of <code>join_table_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          join. If the schema is non-existent, it will be
 *                          automatically created.  The default value is ''.
 *                                  <li> 'max_query_dimensions': No longer
 *                          used.
 *                                  <li> 'optimize_lookups': Use more memory to
 *                          speed up the joining of tables.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the join table specified in
 *                          <code>join_table_name</code>.
 *                                  <li> 'view_id': view this projection is
 *                          part of.  The default value is ''.
 *                                  <li> 'no_count': Return a count of 0 for
 *                          the join table for logging and for
 *                          {@linkcode GPUdb#show_table}; optimization needed
 *                          for large overlapped equi-join stencils.  The
 *                          default value is 'false'.
 *                                  <li> 'chunk_size': Maximum number of
 *                          records per joined-chunk for this table. Defaults
 *                          to the gpudb.conf file chunk size
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_join_table = function(join_table_name, table_names, column_names, expressions, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_join_table(join_table_name, table_names, column_names, expressions, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        join_table_name: join_table_name,
        table_names: table_names,
        column_names: column_names,
        expressions: (expressions !== undefined && expressions !== null) ? expressions : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/jointable", actual_request, callback);
};

/**
 * Initiates the process of creating a materialized view, reserving the
 * view's name to prevent other views or tables from being created with that
 * name.
 * <p>
 * For materialized view details and examples, see
 * <a href="../../../concepts/materialized_views/" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains <code>view_id</code>, which is used to tag each
 * subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose
 * the view.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_materialized_view_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_materialized_view_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/materializedview", actual_request, callback);
};

/**
 * Initiates the process of creating a materialized view, reserving the
 * view's name to prevent other views or tables from being created with that
 * name.
 * <p>
 * For materialized view details and examples, see
 * <a href="../../../concepts/materialized_views/" target="_top">Materialized
 * Views</a>.
 * <p>
 * The response contains <code>view_id</code>, which is used to tag each
 * subsequent
 * operation (projection, union, aggregation, filter, or join) that will
 * compose
 * the view.
 *
 * @param {String} table_name  Name of the table to be created that is the
 *                             top-level table of the materialized view, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a> and
 *                             meeting <a
 *                             href="../../../concepts/tables/#table-naming-criteria"
 *                             target="_top">table naming criteria</a>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the materialized
 *                          view as part of <code>table_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema which is
 *                          to contain the newly created view. If the schema
 *                          provided is non-existent, it will be automatically
 *                          created.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the table specified in <code>table_name</code>.
 *                                  <li> 'persist': If <code>true</code>, then
 *                          the materialized view specified in
 *                          <code>table_name</code> will be persisted and will
 *                          not expire unless a <code>ttl</code> is specified.
 *                          If <code>false</code>, then the materialized view
 *                          will be an in-memory table and will expire unless a
 *                          <code>ttl</code> is specified otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'refresh_method': Method by which the
 *                          join can be refreshed when the data in underlying
 *                          member tables have changed.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'manual': Refresh only occurs when
 *                          manually requested by calling
 *                          {@linkcode GPUdb#alter_table} with an 'action' of
 *                          'refresh'
 *                                  <li> 'on_query': Refresh any time the view
 *                          is queried.
 *                                  <li> 'on_change': If possible,
 *                          incrementally refresh (refresh just those records
 *                          added) whenever an insert, update, delete or
 *                          refresh of input table is done.  A full refresh is
 *                          done if an incremental refresh is not possible.
 *                                  <li> 'periodic': Refresh table periodically
 *                          at rate specified by <code>refresh_period</code>
 *                          </ul>
 *                          The default value is 'manual'.
 *                                  <li> 'refresh_period': When
 *                          <code>refresh_method</code> is
 *                          <code>periodic</code>, specifies the period in
 *                          seconds at which refresh occurs
 *                                  <li> 'refresh_start_time': When
 *                          <code>refresh_method</code> is
 *                          <code>periodic</code>, specifies the first time at
 *                          which a refresh is to be done.  Value is a datetime
 *                          string with format 'YYYY-MM-DD HH:MM:SS'.
 *                                  <li> 'execute_as': User name to use to run
 *                          the refresh job
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_materialized_view = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_materialized_view(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/materializedview", actual_request, callback);
};

/**
 * Creates an instance (proc) of the
 * <a href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF) specified by the
 * given command, options, and files, and makes it available for execution.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: request.proc_name,
        execution_mode: (request.execution_mode !== undefined && request.execution_mode !== null) ? request.execution_mode : "distributed",
        files: (request.files !== undefined && request.files !== null) ? request.files : {},
        command: (request.command !== undefined && request.command !== null) ? request.command : "",
        args: (request.args !== undefined && request.args !== null) ? request.args : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/proc", actual_request, callback);
};

/**
 * Creates an instance (proc) of the
 * <a href="../../../concepts/udf/" target="_top">user-defined functions</a>
 * (UDF) specified by the
 * given command, options, and files, and makes it available for execution.
 *
 * @param {String} proc_name  Name of the proc to be created. Must not be the
 *                            name of a currently existing proc.
 * @param {String} execution_mode  The execution mode of the proc.
 *                                 Supported values:
 *                                 <ul>
 *                                         <li> 'distributed': Input table data
 *                                 will be divided into data
 *                                 segments that are distributed across all
 *                                 nodes in the cluster, and the proc
 *                                 command will be invoked once per data
 *                                 segment in parallel. Output table data
 *                                 from each invocation will be saved to the
 *                                 same node as the corresponding input
 *                                 data.
 *                                         <li> 'nondistributed': The proc
 *                                 command will be invoked only once per
 *                                 execution, and will not have direct access
 *                                 to any tables named as input or
 *                                 output table parameters in the call to
 *                                 {@linkcode GPUdb#execute_proc}.  It will,
 *                                 however, be able to access the database
 *                                 using native API calls.
 *                                 </ul>
 *                                 The default value is 'distributed'.
 * @param {Object} files  A map of the files that make up the proc. The keys of
 *                        the
 *                        map are file names, and the values are the binary
 *                        contents of the files. The
 *                        file names may include subdirectory names (e.g.
 *                        'subdir/file') but must not
 *                        resolve to a directory above the root for the proc.
 *                        Files may be loaded from existing files in KiFS.
 *                        Those file names should be
 *                        prefixed with the uri kifs:// and the values in the
 *                        map should be empty
 * @param {String} command  The command (excluding arguments) that will be
 *                          invoked when
 *                          the proc is executed. It will be invoked from the
 *                          directory containing the proc
 *                          <code>files</code> and may be any command that can
 *                          be resolved from that directory.
 *                          It need not refer to a file actually in that
 *                          directory; for example, it could be
 *                          'java' if the proc is a Java application; however,
 *                          any necessary external
 *                          programs must be preinstalled on every database
 *                          node. If the command refers to a
 *                          file in that directory, it must be preceded with
 *                          './' as per Linux convention.
 *                          If not specified, and exactly one file is provided
 *                          in <code>files</code>, that file
 *                          will be invoked.
 * @param {String[]} args  An array of command-line arguments that will be
 *                         passed to <code>command</code> when the proc is
 *                         executed.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'max_concurrency_per_node': The
 *                          maximum number of concurrent instances of the proc
 *                          that will be executed per node. 0 allows unlimited
 *                          concurrency.  The default value is '0'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_proc = function(proc_name, execution_mode, files, command, args, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_proc(proc_name, execution_mode, files, command, args, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: proc_name,
        execution_mode: (execution_mode !== undefined && execution_mode !== null) ? execution_mode : "distributed",
        files: (files !== undefined && files !== null) ? files : {},
        command: (command !== undefined && command !== null) ? command : "",
        args: (args !== undefined && args !== null) ? args : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/proc", actual_request, callback);
};

/**
 * Creates a new <a href="../../../concepts/projections/"
 * target="_top">projection</a> of
 * an existing table. A projection represents a subset of the columns
 * (potentially
 * including derived columns) of a table.
 * <p>
 * For projection details and examples, see
 * <a href="../../../concepts/projections/" target="_top">Projections</a>.  For
 * limitations, see
 * <a href="../../../concepts/projections/#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@linkcode GPUdb#get_records_by_column}.
 * <p>
 * A projection can be created with a different
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * than the source table.
 * By specifying <code>shard_key</code>, the projection will be sharded
 * according to the specified columns, regardless of how the source table is
 * sharded.  The source table can even be unsharded or replicated.
 * <p>
 * If <code>table_name</code> is empty, selection is performed against a
 * single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_projection_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_projection_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        projection_name: request.projection_name,
        column_names: request.column_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/projection", actual_request, callback);
};

/**
 * Creates a new <a href="../../../concepts/projections/"
 * target="_top">projection</a> of
 * an existing table. A projection represents a subset of the columns
 * (potentially
 * including derived columns) of a table.
 * <p>
 * For projection details and examples, see
 * <a href="../../../concepts/projections/" target="_top">Projections</a>.  For
 * limitations, see
 * <a href="../../../concepts/projections/#limitations-and-cautions"
 * target="_top">Projection Limitations and Cautions</a>.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@linkcode GPUdb#get_records_by_column}.
 * <p>
 * A projection can be created with a different
 * <a href="../../../concepts/tables/#shard-keys" target="_top">shard key</a>
 * than the source table.
 * By specifying <code>shard_key</code>, the projection will be sharded
 * according to the specified columns, regardless of how the source table is
 * sharded.  The source table can even be unsharded or replicated.
 * <p>
 * If <code>table_name</code> is empty, selection is performed against a
 * single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 *
 * @param {String} table_name  Name of the existing table on which the
 *                             projection is to be applied, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  An
 *                             empty table name creates a projection from a
 *                             single-row virtual table, where columns
 *                             specified should be constants or constant
 *                             expressions.
 * @param {String} projection_name  Name of the projection to be created, in
 *                                  [schema_name.]table_name format, using
 *                                  standard <a
 *                                  href="../../../concepts/tables/#table-name-resolution"
 *                                  target="_top">name resolution rules</a> and
 *                                  meeting <a
 *                                  href="../../../concepts/tables/#table-naming-criteria"
 *                                  target="_top">table naming criteria</a>.
 * @param {String[]} column_names  List of columns from <code>table_name</code>
 *                                 to be included in the projection. Can
 *                                 include derived columns. Can be specified as
 *                                 aliased via the syntax 'column_name as
 *                                 alias'.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>projection_name</code>. If
 *                          <code>persist</code> is <code>false</code> (or
 *                          unspecified), then this is always allowed even if
 *                          the caller does not have permission to create
 *                          tables. The generated name is returned in
 *                          <code>qualified_projection_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the projection as
 *                          part of <code>projection_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          projection. If the schema is non-existent, it will
 *                          be automatically created.  The default value is ''.
 *                                  <li> 'expression': An optional filter <a
 *                          href="../../../concepts/expressions/"
 *                          target="_top">expression</a> to be applied to the
 *                          source table prior to the projection.  The default
 *                          value is ''.
 *                                  <li> 'is_replicated': If <code>true</code>
 *                          then the projection will be replicated even if the
 *                          source table is not.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'limit': The number of records to
 *                          keep.  The default value is ''.
 *                                  <li> 'order_by': Comma-separated list of
 *                          the columns to be sorted by; e.g. 'timestamp asc, x
 *                          desc'.  The columns specified must be present in
 *                          <code>column_names</code>.  If any alias is given
 *                          for any column name, the alias must be used, rather
 *                          than the original column name.  The default value
 *                          is ''.
 *                                  <li> 'chunk_size': Indicates the number of
 *                          records per chunk to be used for this projection.
 *                                  <li> 'create_indexes': Comma-separated list
 *                          of columns on which to create indexes on the
 *                          projection.  The columns specified must be present
 *                          in <code>column_names</code>.  If any alias is
 *                          given for any column name, the alias must be used,
 *                          rather than the original column name.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the projection specified in
 *                          <code>projection_name</code>.
 *                                  <li> 'shard_key': Comma-separated list of
 *                          the columns to be sharded on; e.g. 'column1,
 *                          column2'.  The columns specified must be present in
 *                          <code>column_names</code>.  If any alias is given
 *                          for any column name, the alias must be used, rather
 *                          than the original column name.  The default value
 *                          is ''.
 *                                  <li> 'persist': If <code>true</code>, then
 *                          the projection specified in
 *                          <code>projection_name</code> will be persisted and
 *                          will not expire unless a <code>ttl</code> is
 *                          specified.   If <code>false</code>, then the
 *                          projection will be an in-memory table and will
 *                          expire unless a <code>ttl</code> is specified
 *                          otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'preserve_dict_encoding': If
 *                          <code>true</code>, then columns that were dict
 *                          encoded in the source table will be dict encoded in
 *                          the projection.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'retain_partitions': Determines
 *                          whether the created projection will retain the
 *                          partitioning scheme from the source table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'view_id': ID of view of which this
 *                          projection is a member.  The default value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_projection = function(table_name, projection_name, column_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_projection(table_name, projection_name, column_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        projection_name: projection_name,
        column_names: column_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/projection", actual_request, callback);
};

/**
 * Creates a new resource group to facilitate resource management.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_resource_group_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_resource_group_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        tier_attributes: (request.tier_attributes !== undefined && request.tier_attributes !== null) ? request.tier_attributes : {},
        ranking: request.ranking,
        adjoining_resource_group: (request.adjoining_resource_group !== undefined && request.adjoining_resource_group !== null) ? request.adjoining_resource_group : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/resourcegroup", actual_request, callback);
};

/**
 * Creates a new resource group to facilitate resource management.
 *
 * @param {String} name  Name of the group to be created. Must contain only
 *                       letters, digits, and underscores, and cannot begin
 *                       with a digit. Must not match existing resource group
 *                       name.
 * @param {Object} tier_attributes  Optional map containing tier names and
 *                                  their respective attribute group limits.
 *                                  The only valid attribute limit that can be
 *                                  set is max_memory (in bytes) for the VRAM &
 *                                  RAM tiers.
 *                                  For instance, to set max VRAM capacity to
 *                                  1GB and max RAM capacity to 10GB, use:
 *                                  {'VRAM':{'max_memory':'1000000000'},
 *                                  'RAM':{'max_memory':'10000000000'}}
 *                                  <ul>
 *                                          <li> 'max_memory': Maximum amount
 *                                  of memory usable in the given tier at one
 *                                  time for this group.
 *                                  </ul>
 * @param {String} ranking  Indicates the relative ranking among existing
 *                          resource groups where this new resource group will
 *                          be placed.  When using <code>before</code> or
 *                          <code>after</code>, specify which resource group
 *                          this one will be inserted before or after in
 *                          <code>adjoining_resource_group</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'first'
 *                                  <li> 'last'
 *                                  <li> 'before'
 *                                  <li> 'after'
 *                          </ul>
 * @param {String} adjoining_resource_group  If <code>ranking</code> is
 *                                           <code>before</code> or
 *                                           <code>after</code>, this field
 *                                           indicates the resource group
 *                                           before or after which the current
 *                                           group will be placed; otherwise,
 *                                           leave blank.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'max_cpu_concurrency': Maximum number
 *                          of simultaneous threads that will be used to
 *                          execute a request for this group.
 *                                  <li> 'max_data': Maximum amount of
 *                          cumulative ram usage regardless of tier status for
 *                          this group.
 *                                  <li> 'max_scheduling_priority': Maximum
 *                          priority of a scheduled task for this group.
 *                                  <li> 'max_tier_priority': Maximum priority
 *                          of a tiered object for this group.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_resource_group = function(name, tier_attributes, ranking, adjoining_resource_group, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_resource_group(name, tier_attributes, ranking, adjoining_resource_group, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        tier_attributes: (tier_attributes !== undefined && tier_attributes !== null) ? tier_attributes : {},
        ranking: ranking,
        adjoining_resource_group: (adjoining_resource_group !== undefined && adjoining_resource_group !== null) ? adjoining_resource_group : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/resourcegroup", actual_request, callback);
};

/**
 * Creates a new role.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/role", actual_request, callback);
};

/**
 * Creates a new role.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String} name  Name of the role to be created. Must contain only
 *                       lowercase letters, digits, and underscores, and cannot
 *                       begin with a digit. Must not be the same name as an
 *                       existing user or role.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'resource_group': Name of an existing
 *                          resource group to associate with this user
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_role = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_role(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/role", actual_request, callback);
};

/**
 * Creates a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>. Schemas are containers for tables and views.
 * Multiple tables and views can be defined with the same name in different
 * schemas.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_schema_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_schema_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: request.schema_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/schema", actual_request, callback);
};

/**
 * Creates a SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>. Schemas are containers for tables and views.
 * Multiple tables and views can be defined with the same name in different
 * schemas.
 *
 * @param {String} schema_name  Name of the schema to be created.  Has the same
 *                              naming restrictions as <a
 *                              href="../../../concepts/tables/"
 *                              target="_top">tables</a>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_exists': If
 *                          <code>true</code>, prevents an error from occurring
 *                          if the schema already exists.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_schema = function(schema_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_schema(schema_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: schema_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/schema", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.create_state_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_state_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        input_table_name: request.input_table_name,
        init_table_name: request.init_table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/statetable", actual_request, callback);
};

/**
 *
 * @param {String} table_name
 * @param {String} input_table_name
 * @param {String} init_table_name
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.create_state_table = function(table_name, input_table_name, init_table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_state_table(table_name, input_table_name, init_table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        input_table_name: input_table_name,
        init_table_name: init_table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/statetable", actual_request, callback);
};

/**
 * Creates a new table. If a new table is being created,
 * the type of the table is given by <code>type_id</code>, which must be the ID
 * of
 * a currently registered type (i.e. one created via
 * {@linkcode GPUdb#create_type}).
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../../concepts/tables/#replication" target="_top">replicated</a>
 * distribution scheme,
 * or be assigned: <a href="../../../concepts/tables/#foreign-keys"
 * target="_top">foreign keys</a> to
 * other tables, a <a href="../../../concepts/tables/#partitioning"
 * target="_top">partitioning</a>
 * scheme, and/or a <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        type_id: request.type_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/table", actual_request, callback);
};

/**
 * Creates a new table. If a new table is being created,
 * the type of the table is given by <code>type_id</code>, which must be the ID
 * of
 * a currently registered type (i.e. one created via
 * {@linkcode GPUdb#create_type}).
 * <p>
 * A table may optionally be designated to use a
 * <a href="../../../concepts/tables/#replication" target="_top">replicated</a>
 * distribution scheme,
 * or be assigned: <a href="../../../concepts/tables/#foreign-keys"
 * target="_top">foreign keys</a> to
 * other tables, a <a href="../../../concepts/tables/#partitioning"
 * target="_top">partitioning</a>
 * scheme, and/or a <a href="../../../rm/concepts/#tier-strategies"
 * target="_top">tier strategy</a>.
 *
 * @param {String} table_name  Name of the table to be created, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a> and
 *                             meeting <a
 *                             href="../../../concepts/tables/#table-naming-criteria"
 *                             target="_top">table naming criteria</a>. Error
 *                             for requests with existing table of the same
 *                             name and type ID may be suppressed by using the
 *                             <code>no_error_if_exists</code> option.
 * @param {String} type_id  ID of a currently registered type. All objects
 *                          added to the newly created table will be of this
 *                          type.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_exists': If
 *                          <code>true</code>, prevents an error from occurring
 *                          if the table already exists and is of the given
 *                          type.  If a table with the same ID but a different
 *                          type exists, it is still an error.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>table_name</code>. If
 *                          <code>is_result_table</code> is <code>true</code>,
 *                          then this is always allowed even if the caller does
 *                          not have permission to create tables. The generated
 *                          name is returned in
 *                          <code>qualified_table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema as part of
 *                          <code>table_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema which is
 *                          to contain the newly created table. If the schema
 *                          is non-existent, it will be automatically created.
 *                                  <li> 'is_collection': [DEPRECATED--please
 *                          use {@linkcode GPUdb#create_schema} to create a
 *                          schema instead]  Indicates whether to create a
 *                          schema instead of a table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'disallow_homogeneous_tables': No
 *                          longer supported; value will be ignored.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'is_replicated': Affects the <a
 *                          href="../../../concepts/tables/#distribution"
 *                          target="_top">distribution scheme</a> for the
 *                          table's data.  If <code>true</code> and the given
 *                          type has no explicit <a
 *                          href="../../../concepts/tables/#shard-key"
 *                          target="_top">shard key</a> defined, the table will
 *                          be <a href="../../../concepts/tables/#replication"
 *                          target="_top">replicated</a>.  If
 *                          <code>false</code>, the table will be <a
 *                          href="../../../concepts/tables/#sharding"
 *                          target="_top">sharded</a> according to the shard
 *                          key specified in the given <code>type_id</code>, or
 *                          <a href="../../../concepts/tables/#random-sharding"
 *                          target="_top">randomly sharded</a>, if no shard key
 *                          is specified.  Note that a type containing a shard
 *                          key cannot be used to create a replicated table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'foreign_keys': Semicolon-separated
 *                          list of <a
 *                          href="../../../concepts/tables/#foreign-keys"
 *                          target="_top">foreign keys</a>, of the format
 *                          '(source_column_name [, ...]) references
 *                          target_table_name(primary_key_column_name [, ...])
 *                          [as foreign_key_name]'.
 *                                  <li> 'foreign_shard_key': Foreign shard key
 *                          of the format 'source_column references
 *                          shard_by_column from
 *                          target_table(primary_key_column)'.
 *                                  <li> 'partition_type': <a
 *                          href="../../../concepts/tables/#partitioning"
 *                          target="_top">Partitioning</a> scheme to use.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'RANGE': Use <a
 *                          href="../../../concepts/tables/#partitioning-by-range"
 *                          target="_top">range partitioning</a>.
 *                                  <li> 'INTERVAL': Use <a
 *                          href="../../../concepts/tables/#partitioning-by-interval"
 *                          target="_top">interval partitioning</a>.
 *                                  <li> 'LIST': Use <a
 *                          href="../../../concepts/tables/#partitioning-by-list"
 *                          target="_top">list partitioning</a>.
 *                                  <li> 'HASH': Use <a
 *                          href="../../../concepts/tables/#partitioning-by-hash"
 *                          target="_top">hash partitioning</a>.
 *                                  <li> 'SERIES': Use <a
 *                          href="../../../concepts/tables/#partitioning-by-series"
 *                          target="_top">series partitioning</a>.
 *                          </ul>
 *                                  <li> 'partition_keys': Comma-separated list
 *                          of partition keys, which are the columns or column
 *                          expressions by which records will be assigned to
 *                          partitions defined by
 *                          <code>partition_definitions</code>.
 *                                  <li> 'partition_definitions':
 *                          Comma-separated list of partition definitions,
 *                          whose format depends on the choice of
 *                          <code>partition_type</code>.  See <a
 *                          href="../../../concepts/tables/#partitioning-by-range"
 *                          target="_top">range partitioning</a>, <a
 *                          href="../../../concepts/tables/#partitioning-by-interval"
 *                          target="_top">interval partitioning</a>, <a
 *                          href="../../../concepts/tables/#partitioning-by-list"
 *                          target="_top">list partitioning</a>, <a
 *                          href="../../../concepts/tables/#partitioning-by-hash"
 *                          target="_top">hash partitioning</a>, or <a
 *                          href="../../../concepts/tables/#partitioning-by-series"
 *                          target="_top">series partitioning</a> for example
 *                          formats.
 *                                  <li> 'is_automatic_partition': If
 *                          <code>true</code>, a new partition will be created
 *                          for values which don't fall into an existing
 *                          partition.  Currently only supported for <a
 *                          href="../../../concepts/tables/#partitioning-by-list"
 *                          target="_top">list partitions</a>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the table specified in <code>table_name</code>.
 *                                  <li> 'chunk_size': Indicates the number of
 *                          records per chunk to be used for this table.
 *                                  <li> 'is_result_table': Indicates whether
 *                          the table is a <a
 *                          href="../../../concepts/tables_memory_only/"
 *                          target="_top">memory-only table</a>. A result table
 *                          cannot contain columns with store_only or
 *                          text_search <a
 *                          href="../../../concepts/types/#data-handling"
 *                          target="_top">data-handling</a> or that are <a
 *                          href="../../../concepts/types/#primitive-types"
 *                          target="_top">non-charN strings</a>, and it will
 *                          not be retained if the server is restarted.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'strategy_definition': The <a
 *                          href="../../../rm/concepts/#tier-strategies"
 *                          target="_top">tier strategy</a> for the table and
 *                          its columns.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table = function(table_name, type_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table(table_name, type_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        type_id: type_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/table", actual_request, callback);
};

/**
 * Creates a new <a href="../../../concepts/external_tables/"
 * target="_top">external table</a>, which is a
 * local database object whose source data is located externally to the
 * database.  The source data can
 * be located either in <a href="../../../tools/kifs/" target="_top">KiFS</a>;
 * on the cluster, accessible to the database; or remotely, accessible via a
 * pre-defined external <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.
 * <p>
 * The external table can have its structure defined explicitly, via
 * <code>create_table_options</code>,
 * which contains many of the options from {@linkcode GPUdb#create_table}; or
 * defined implicitly, inferred
 * from the source data.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_external_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_external_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        filepaths: request.filepaths,
        modify_columns: (request.modify_columns !== undefined && request.modify_columns !== null) ? request.modify_columns : {},
        create_table_options: (request.create_table_options !== undefined && request.create_table_options !== null) ? request.create_table_options : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/table/external", actual_request, callback);
};

/**
 * Creates a new <a href="../../../concepts/external_tables/"
 * target="_top">external table</a>, which is a
 * local database object whose source data is located externally to the
 * database.  The source data can
 * be located either in <a href="../../../tools/kifs/" target="_top">KiFS</a>;
 * on the cluster, accessible to the database; or remotely, accessible via a
 * pre-defined external <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.
 * <p>
 * The external table can have its structure defined explicitly, via
 * <code>create_table_options</code>,
 * which contains many of the options from {@linkcode GPUdb#create_table}; or
 * defined implicitly, inferred
 * from the source data.
 *
 * @param {String} table_name  Name of the table to be created, in
 *                             [schema_name.]table_name format, using
 *                             standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a> and
 *                             meeting
 *                             <a
 *                             href="../../../concepts/tables/#table-naming-criteria"
 *                             target="_top">table naming criteria</a>.
 * @param {String[]} filepaths  A list of file paths from which data will be
 *                              sourced;
 *                              For paths in <a href="../../../tools/kifs/"
 *                              target="_top">KiFS</a>, use the uri prefix of
 *                              kifs:// followed by the path to
 *                              a file or directory. File matching by prefix is
 *                              supported, e.g. kifs://dir/file would match
 *                              dir/file_1
 *                              and dir/file_2. When prefix matching is used,
 *                              the path must start with a full, valid KiFS
 *                              directory name.
 *                              If an external data source is specified in
 *                              <code>datasource_name</code>, these file
 *                              paths must resolve to accessible files at that
 *                              data source location. Prefix matching is
 *                              supported.
 *                              If the data source is hdfs, prefixes must be
 *                              aligned with directories, i.e. partial file
 *                              names will not match.
 *                              If no data source is specified, the files are
 *                              assumed to be local to the database and must
 *                              all be
 *                              accessible to the gpudb user, residing on the
 *                              path (or relative to the path) specified by the
 *                              external files directory in the Kinetica
 *                              <a
 *                              href="../../../config/#config-main-external-files"
 *                              target="_top">configuration file</a>. Wildcards
 *                              (*) can be used to
 *                              specify a group of files.  Prefix matching is
 *                              supported, the prefixes must be aligned with
 *                              directories.
 *                              If the first path ends in .tsv, the text
 *                              delimiter will be defaulted to a tab character.
 *                              If the first path ends in .psv, the text
 *                              delimiter will be defaulted to a pipe character
 *                              (|).
 * @param {Object} modify_columns  Not implemented yet
 * @param {Object} create_table_options  Options from
 *                                       {@linkcode GPUdb#create_table},
 *                                       allowing the structure of the table to
 *                                       be defined independently of the data
 *                                       source
 *                                       <ul>
 *                                               <li> 'type_id': ID of a
 *                                       currently registered <a
 *                                       href="../../../concepts/types/"
 *                                       target="_top">type</a>.  The default
 *                                       value is ''.
 *                                               <li> 'no_error_if_exists': If
 *                                       <code>true</code>,
 *                                       prevents an error from occurring if
 *                                       the table already exists and is of the
 *                                       given type.  If a table with
 *                                       the same name but a different type
 *                                       exists, it is still an error.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'is_replicated': Affects
 *                                       the <a
 *                                       href="../../../concepts/tables/#distribution"
 *                                       target="_top">distribution scheme</a>
 *                                       for the table's data.  If
 *                                       <code>true</code> and the
 *                                       given table has no explicit <a
 *                                       href="../../../concepts/tables/#shard-key"
 *                                       target="_top">shard key</a> defined,
 *                                       the
 *                                       table will be <a
 *                                       href="../../../concepts/tables/#replication"
 *                                       target="_top">replicated</a>.  If
 *                                       <code>false</code>, the table will be
 *                                       <a
 *                                       href="../../../concepts/tables/#sharding"
 *                                       target="_top">sharded</a> according to
 *                                       the shard key specified in the
 *                                       given <code>type_id</code>, or
 *                                       <a
 *                                       href="../../../concepts/tables/#random-sharding"
 *                                       target="_top">randomly sharded</a>, if
 *                                       no shard key is specified.
 *                                       Note that a type containing a shard
 *                                       key cannot be used to create a
 *                                       replicated table.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'foreign_keys':
 *                                       Semicolon-separated list of
 *                                       <a
 *                                       href="../../../concepts/tables/#foreign-keys"
 *                                       target="_top">foreign keys</a>, of the
 *                                       format
 *                                       '(source_column_name [, ...])
 *                                       references
 *                                       target_table_name(primary_key_column_name
 *                                       [, ...]) [as foreign_key_name]'.
 *                                               <li> 'foreign_shard_key':
 *                                       Foreign shard key of the format
 *                                       'source_column references
 *                                       shard_by_column from
 *                                       target_table(primary_key_column)'.
 *                                               <li> 'partition_type': <a
 *                                       href="../../../concepts/tables/#partitioning"
 *                                       target="_top">Partitioning</a> scheme
 *                                       to use.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'RANGE': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-range"
 *                                       target="_top">range partitioning</a>.
 *                                               <li> 'INTERVAL': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-interval"
 *                                       target="_top">interval
 *                                       partitioning</a>.
 *                                               <li> 'LIST': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitioning</a>.
 *                                               <li> 'HASH': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-hash"
 *                                       target="_top">hash partitioning</a>.
 *                                               <li> 'SERIES': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-series"
 *                                       target="_top">series partitioning</a>.
 *                                       </ul>
 *                                               <li> 'partition_keys':
 *                                       Comma-separated list of partition
 *                                       keys, which are the columns or
 *                                       column expressions by which records
 *                                       will be assigned to partitions defined
 *                                       by
 *                                       <code>partition_definitions</code>.
 *                                               <li> 'partition_definitions':
 *                                       Comma-separated list of partition
 *                                       definitions, whose format depends
 *                                       on the choice of
 *                                       <code>partition_type</code>.  See
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-range"
 *                                       target="_top">range partitioning</a>,
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-interval"
 *                                       target="_top">interval
 *                                       partitioning</a>,
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitioning</a>,
 *                                       or
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-hash"
 *                                       target="_top">hash partitioning</a>
 *                                       for example formats.
 *                                               <li> 'is_automatic_partition':
 *                                       If <code>true</code>,
 *                                       a new partition will be created for
 *                                       values which don't fall into an
 *                                       existing partition.  Currently
 *                                       only supported for <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitions</a>.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'ttl': Sets the <a
 *                                       href="../../../concepts/ttl/"
 *                                       target="_top">TTL</a> of the table
 *                                       specified in <code>table_name</code>.
 *                                               <li> 'chunk_size': Indicates
 *                                       the number of records per chunk to be
 *                                       used for this table.
 *                                               <li> 'is_result_table':
 *                                       Indicates whether the table is a
 *                                       <a
 *                                       href="../../../concepts/tables_memory_only/"
 *                                       target="_top">memory-only table</a>. A
 *                                       result table cannot contain
 *                                       columns with store_only or text_search
 *                                       <a
 *                                       href="../../../concepts/types/#data-handling"
 *                                       target="_top">data-handling</a> or
 *                                       that are
 *                                       <a
 *                                       href="../../../concepts/types/#primitive-types"
 *                                       target="_top">non-charN strings</a>,
 *                                       and it will not be retained if
 *                                       the server is restarted.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'strategy_definition':
 *                                       The <a
 *                                       href="../../../rm/concepts/#tier-strategies"
 *                                       target="_top">tier strategy</a>
 *                                       for the table and its columns.
 *                                       </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'bad_record_table_name': Optional name
 *                          of a table to which records that were rejected are
 *                          written.  The bad-record-table has the following
 *                          columns: line_number (long), line_rejected
 *                          (string), error_message (string).
 *                                  <li> 'bad_record_table_limit': A positive
 *                          integer indicating the maximum number of records
 *                          that can be  written to the bad-record-table.
 *                          Default value is 10000
 *                                  <li> 'bad_record_table_limit_per_input':
 *                          For subscriptions: A positive integer indicating
 *                          the maximum number of records that can be written
 *                          to the bad-record-table per file/payload. Default
 *                          value will be 'bad_record_table_limit' and total
 *                          size of the table per rank is limited to
 *                          'bad_record_table_limit'
 *                                  <li> 'batch_size': Internal tuning
 *                          parameter--number of records per batch when
 *                          inserting data.
 *                                  <li> 'column_formats': For each target
 *                          column specified, applies the column-property-bound
 *                          format to the source data
 *                          loaded into that column.  Each column format will
 *                          contain a mapping of one or more of its column
 *                          properties to an appropriate format for each
 *                          property.  Currently supported column properties
 *                          include date, time, & datetime. The parameter value
 *                          must be formatted as a JSON string of maps of
 *                          column names to maps of column properties to their
 *                          corresponding column formats, e.g.,
 *                          '{ "order_date" : { "date" : "%Y.%m.%d" },
 *                          "order_time" : { "time" : "%H:%M:%S" } }'.
 *                          See <code>default_column_formats</code> for valid
 *                          format syntax.
 *                                  <li> 'columns_to_load': Specifies a
 *                          comma-delimited list of columns from the source
 *                          data to
 *                          load.  If more than one file is being loaded, this
 *                          list applies to all files.
 *                          Column numbers can be specified discretely or as a
 *                          range.  For example, a value of '5,7,1..3' will
 *                          insert values from the fifth column in the source
 *                          data into the first column in the target table,
 *                          from the seventh column in the source data into the
 *                          second column in the target table, and from the
 *                          first through third columns in the source data into
 *                          the third through fifth columns in the target
 *                          table.
 *                          If the source data contains a header, column names
 *                          matching the file header names may be provided
 *                          instead of column numbers.  If the target table
 *                          doesn't exist, the table will be created with the
 *                          columns in this order.  If the target table does
 *                          exist with columns in a different order than the
 *                          source data, this list can be used to match the
 *                          order of the target table.  For example, a value of
 *                          'C, B, A' will create a three column table with
 *                          column C, followed by column B, followed by column
 *                          A; or will insert those fields in that order into a
 *                          table created with columns in that order.  If
 *                          the target table exists, the column names must
 *                          match the source data field names for a
 *                          name-mapping
 *                          to be successful.
 *                                  <li> 'columns_to_skip': Specifies a
 *                          comma-delimited list of columns from the source
 *                          data to
 *                          skip.  Mutually exclusive to columns_to_load.
 *                                  <li> 'datasource_name': Name of an existing
 *                          external data source from which data file(s)
 *                          specified in <code>filepaths</code> will be loaded
 *                                  <li> 'default_column_formats': Specifies
 *                          the default format to be applied to source data
 *                          loaded
 *                          into columns with the corresponding column
 *                          property.  Currently supported column properties
 *                          include
 *                          date, time, & datetime.  This default
 *                          column-property-bound format can be overridden by
 *                          specifying a
 *                          column property & format for a given target column
 *                          in <code>column_formats</code>. For
 *                          each specified annotation, the format will apply to
 *                          all columns with that annotation unless a custom
 *                          <code>column_formats</code> for that annotation is
 *                          specified.
 *                          The parameter value must be formatted as a JSON
 *                          string that is a map of column properties to their
 *                          respective column formats, e.g., '{ "date" :
 *                          "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column
 *                          formats are specified as a string of control
 *                          characters and plain text. The supported control
 *                          characters are 'Y', 'm', 'd', 'H', 'M', 'S', and
 *                          's', which follow the Linux 'strptime()'
 *                          specification, as well as 's', which specifies
 *                          seconds and fractional seconds (though the
 *                          fractional
 *                          component will be truncated past milliseconds).
 *                          Formats for the 'date' annotation must include the
 *                          'Y', 'm', and 'd' control characters. Formats for
 *                          the 'time' annotation must include the 'H', 'M',
 *                          and either 'S' or 's' (but not both) control
 *                          characters. Formats for the 'datetime' annotation
 *                          meet both the 'date' and 'time' control character
 *                          requirements. For example, '{"datetime" : "%m/%d/%Y
 *                          %H:%M:%S" }' would be used to interpret text
 *                          as "05/04/2000 12:12:11"
 *                                  <li> 'error_handling': Specifies how errors
 *                          should be handled upon insertion.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'permissive': Records with missing
 *                          columns are populated with nulls if possible;
 *                          otherwise, the malformed records are skipped.
 *                                  <li> 'ignore_bad_records': Malformed
 *                          records are skipped.
 *                                  <li> 'abort': Stops current insertion and
 *                          aborts entire operation when an error is
 *                          encountered.  Primary key collisions are considered
 *                          abortable errors in this mode.
 *                          </ul>
 *                          The default value is 'abort'.
 *                                  <li> 'external_table_type': Specifies
 *                          whether the external table holds a local copy of
 *                          the external data.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'materialized': Loads a copy of the
 *                          external data into the database, refreshed on
 *                          demand
 *                                  <li> 'logical': External data will not be
 *                          loaded into the database; the data will be
 *                          retrieved from the source upon servicing each query
 *                          against the external table
 *                          </ul>
 *                          The default value is 'materialized'.
 *                                  <li> 'file_type': Specifies the type of the
 *                          file(s) whose records will be inserted.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'avro': Avro file format
 *                                  <li> 'delimited_text': Delimited text file
 *                          format; e.g., CSV, TSV, PSV, etc.
 *                                  <li> 'json': Json file format
 *                                  <li> 'parquet': Apache Parquet file format
 *                                  <li> 'shapefile': ShapeFile file format
 *                          </ul>
 *                          The default value is 'delimited_text'.
 *                                  <li> 'ingestion_mode': Whether to do a full
 *                          load, dry run, or perform a type inference on the
 *                          source data.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'full': Run a type inference on the
 *                          source data (if needed) and ingest
 *                                  <li> 'dry_run': Does not load data, but
 *                          walks through the source data and determines the
 *                          number of valid records, taking into account the
 *                          current mode of <code>error_handling</code>.
 *                                  <li> 'type_inference_only': Infer the type
 *                          of the source data and return, without ingesting
 *                          any data.  The inferred type is returned in the
 *                          response.
 *                          </ul>
 *                          The default value is 'full'.
 *                                  <li> 'kafka_group_id': The group id to be
 *                          used consuming data from a kakfa topic (valid only
 *                          for kafka datasource subscriptions).
 *                                  <li> 'loading_mode': Scheme for
 *                          distributing the extraction and loading of data
 *                          from the source data file(s). This option applies
 *                          only when loading files that are local to the
 *                          database
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'head': The head node loads all data.
 *                          All files must be available to the head node.
 *                                  <li> 'distributed_shared': The head node
 *                          coordinates loading data by worker
 *                          processes across all nodes from shared files
 *                          available to all workers.
 *                          NOTE:
 *                          Instead of existing on a shared source, the files
 *                          can be duplicated on a source local to each host
 *                          to improve performance, though the files must
 *                          appear as the same data set from the perspective of
 *                          all hosts performing the load.
 *                                  <li> 'distributed_local': A single worker
 *                          process on each node loads all files
 *                          that are available to it. This option works best
 *                          when each worker loads files from its own file
 *                          system, to maximize performance. In order to avoid
 *                          data duplication, either each worker performing
 *                          the load needs to have visibility to a set of files
 *                          unique to it (no file is visible to more than
 *                          one node) or the target table needs to have a
 *                          primary key (which will allow the worker to
 *                          automatically deduplicate data).
 *                          NOTE:
 *                          If the target table doesn't exist, the table
 *                          structure will be determined by the head node. If
 *                          the
 *                          head node has no files local to it, it will be
 *                          unable to determine the structure and the request
 *                          will fail.
 *                          If the head node is configured to have no worker
 *                          processes, no data strictly accessible to the head
 *                          node will be loaded.
 *                          </ul>
 *                          The default value is 'head'.
 *                                  <li> 'local_time_offset': For Avro local
 *                          timestamp columns
 *                                  <li> 'num_tasks_per_rank': Optional: number
 *                          of tasks for reading file per rank. Default will be
 *                          external_file_reader_num_tasks
 *                                  <li> 'poll_interval': If <code>true</code>,
 *                          the number of seconds between attempts to load
 *                          external files into the table.  If zero, polling
 *                          will be continuous as long as data is found.  If no
 *                          data is found, the interval will steadily increase
 *                          to a maximum of 60 seconds.
 *                                  <li> 'primary_keys': Optional: comma
 *                          separated list of column names, to set as primary
 *                          keys, when not specified in the type.  The default
 *                          value is ''.
 *                                  <li> 'refresh_method': Method by which the
 *                          table can be refreshed from its source data.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'manual': Refresh only occurs when
 *                          manually requested by invoking the refresh action
 *                          of {@linkcode GPUdb#alter_table} on this table.
 *                                  <li> 'on_start': Refresh table on database
 *                          startup and when manually requested by invoking the
 *                          refresh action of {@linkcode GPUdb#alter_table}
 *                          on this table.
 *                          </ul>
 *                          The default value is 'manual'.
 *                                  <li> 'shard_keys': Optional: comma
 *                          separated list of column names, to set as primary
 *                          keys, when not specified in the type.  The default
 *                          value is ''.
 *                                  <li> 'skip_lines': Skip number of lines
 *                          from begining of file.
 *                                  <li> 'subscribe': Continuously poll the
 *                          data source to check for new data and load it into
 *                          the table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'table_insert_mode': Optional:
 *                          table_insert_mode. When inserting records from
 *                          multiple files: if table_per_file then insert from
 *                          each file into a new table. Currently supported
 *                          only for shapefiles.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'single'
 *                                  <li> 'table_per_file'
 *                          </ul>
 *                          The default value is 'single'.
 *                                  <li> 'text_comment_string': Specifies the
 *                          character string that should be interpreted as a
 *                          comment line
 *                          prefix in the source data.  All lines in the data
 *                          starting with the provided string are ignored.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '#'.
 *                                  <li> 'text_delimiter': Specifies the
 *                          character delimiting field values in the source
 *                          data
 *                          and field names in the header (if present).
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          ','.
 *                                  <li> 'text_escape_character': Specifies the
 *                          character that is used to escape other characters
 *                          in
 *                          the source data.
 *                          An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by
 *                          an escape character will be interpreted as the
 *                          ASCII bell, backspace, form feed, line feed,
 *                          carriage return, horizontal tab, & vertical tab,
 *                          respectively.  For example, the escape character
 *                          followed by an 'n' will be interpreted as a newline
 *                          within a field value.
 *                          The escape character can also be used to escape the
 *                          quoting character, and will be treated as an
 *                          escape character whether it is within a quoted
 *                          field value or not.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.
 *                                  <li> 'text_has_header': Indicates whether
 *                          the source data contains a header row.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'text_header_property_delimiter':
 *                          Specifies the delimiter for
 *                          <a
 *                          href="../../../concepts/types/#column-properties"
 *                          target="_top">column properties</a> in the header
 *                          row (if
 *                          present).  Cannot be set to same value as
 *                          <code>text_delimiter</code>.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '|'.
 *                                  <li> 'text_null_string': Specifies the
 *                          character string that should be interpreted as a
 *                          null
 *                          value in the source data.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '\\N'.
 *                                  <li> 'text_quote_character': Specifies the
 *                          character that should be interpreted as a field
 *                          value
 *                          quoting character in the source data.  The
 *                          character must appear at beginning and end of field
 *                          value
 *                          to take effect.  Delimiters within quoted fields
 *                          are treated as literals and not delimiters.  Within
 *                          a quoted field, two consecutive quote characters
 *                          will be interpreted as a single literal quote
 *                          character, effectively escaping it.  To not have a
 *                          quote character, specify an empty string.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '"'.
 *                                  <li> 'text_search_columns': Add
 *                          'text_search' property to internally inferenced
 *                          string columns. Comma seperated list of column
 *                          names or '*' for all columns. To add text_search
 *                          property only to string columns of minimum size,
 *                          set also the option 'text_search_min_column_length'
 *                                  <li> 'text_search_min_column_length': Set
 *                          minimum column size. Used only when
 *                          'text_search_columns' has a value.
 *                                  <li> 'truncate_table': If set to
 *                          <code>true</code>, truncates the table specified by
 *                          <code>table_name</code> prior to loading the
 *                          file(s).
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'type_inference_mode': optimize type
 *                          inference for:
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'accuracy': scans all data to get
 *                          exactly-typed & sized columns for all data present
 *                                  <li> 'speed': picks the widest possible
 *                          column types so that 'all' values will fit with
 *                          minimum data scanned
 *                          </ul>
 *                          The default value is 'speed'.
 *                                  <li> 'remote_query': Remote SQL query from
 *                          which data will be sourced
 *                                  <li> 'remote_query_filter_column': Name of
 *                          column to be used for splitting the query into
 *                          multiple sub-queries.  The default value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_external = function(table_name, filepaths, modify_columns, create_table_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_external(table_name, filepaths, modify_columns, create_table_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        filepaths: filepaths,
        modify_columns: (modify_columns !== undefined && modify_columns !== null) ? modify_columns : {},
        create_table_options: (create_table_options !== undefined && create_table_options !== null) ? create_table_options : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/table/external", actual_request, callback);
};

/**
 * Creates a monitor that watches for a single table modification event
 * type (insert, update, or delete) on a particular table (identified by
 * <code>table_name</code>) and forwards event notifications to subscribers via
 * ZMQ.
 * After this call completes, subscribe to the returned <code>topic_id</code>
 * on the
 * ZMQ table monitor port (default 9002). Each time an operation of the given
 * type
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using <code>type_schema</code>. The monitor will continue to run (regardless
 * of
 * whether or not there are any subscribers) until deactivated with
 * {@linkcode GPUdb#clear_table_monitor}.
 * <p>
 * For more information on table monitors, see
 * <a href="../../../concepts/table_monitors/" target="_top">Table
 * Monitors</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_monitor_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_monitor_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/tablemonitor", actual_request, callback);
};

/**
 * Creates a monitor that watches for a single table modification event
 * type (insert, update, or delete) on a particular table (identified by
 * <code>table_name</code>) and forwards event notifications to subscribers via
 * ZMQ.
 * After this call completes, subscribe to the returned <code>topic_id</code>
 * on the
 * ZMQ table monitor port (default 9002). Each time an operation of the given
 * type
 * on the table completes, a multipart message is published for that topic; the
 * first part contains only the topic ID, and each subsequent part contains one
 * binary-encoded Avro object that corresponds to the event and can be decoded
 * using <code>type_schema</code>. The monitor will continue to run (regardless
 * of
 * whether or not there are any subscribers) until deactivated with
 * {@linkcode GPUdb#clear_table_monitor}.
 * <p>
 * For more information on table monitors, see
 * <a href="../../../concepts/table_monitors/" target="_top">Table
 * Monitors</a>.
 *
 * @param {String} table_name  Name of the table to monitor, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'event': Type of modification event on
 *                          the target table to be monitored by this table
 *                          monitor.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'insert': Get notifications of new
 *                          record insertions. The new row images are forwarded
 *                          to the subscribers.
 *                                  <li> 'update': Get notifications of update
 *                          operations. The modified row count information is
 *                          forwarded to the subscribers.
 *                                  <li> 'delete': Get notifications of delete
 *                          operations. The deleted row count information is
 *                          forwarded to the subscribers.
 *                          </ul>
 *                          The default value is 'insert'.
 *                                  <li> 'monitor_id': ID to to use for this
 *                          monitor instead of a randomly generated one
 *                                  <li> 'datasink_name': Name of an existing
 *                          <a href="../../../concepts/data_sinks/"
 *                          target="_top">data sink</a> to send change data
 *                          notifications to
 *                                  <li> 'destination': Destination for the
 *                          output data in format
 *                          'destination_type://path[:port]'. Supported
 *                          destination types are 'http', 'https' and 'kafka'.
 *                                  <li> 'kafka_topic_name': Name of the Kafka
 *                          topic to publish to if <code>destination</code> in
 *                          <code>options</code> is specified and is a Kafka
 *                          broker
 *                                  <li> 'increasing_column': Column on
 *                          subscribed table that will increase for new records
 *                          (e.g., TIMESTAMP).
 *                                  <li> 'expression': Filter expression to
 *                          limit records for notification
 *                                  <li> 'refresh_method': Method controlling
 *                          when the table monitor reports changes to the
 *                          <code>table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'on_change': Report changes as they
 *                          occur.
 *                                  <li> 'periodic': Report changes
 *                          periodically at rate specified by
 *                          <code>refresh_period</code>.
 *                          </ul>
 *                          The default value is 'on_change'.
 *                                  <li> 'refresh_period': When
 *                          <code>refresh_method</code> is
 *                          <code>periodic</code>, specifies the period in
 *                          seconds at which changes are reported.
 *                                  <li> 'refresh_start_time': When
 *                          <code>refresh_method</code> is
 *                          <code>periodic</code>, specifies the first time at
 *                          which changes are reported.  Value is a datetime
 *                          string with format 'YYYY-MM-DD HH:MM:SS'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_monitor = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_monitor(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/tablemonitor", actual_request, callback);
};

/**
 * Sets up an area trigger mechanism for two column_names for one or
 * more tables. (This function is essentially the two-dimensional version of
 * {@linkcode GPUdb#create_trigger_by_range}.) Once the trigger has been
 * activated, any
 * record added to the listed tables(s) via {@linkcode GPUdb#insert_records}
 * with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001'
 * but able to be retrieved via {@linkcode GPUdb#show_system_status}) for any
 * listening
 * client to collect. Active triggers can be cancelled by using the
 * {@linkcode GPUdb#clear_trigger} endpoint or by clearing all relevant
 * tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_area_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_area_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request.request_id,
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        x_vector: request.x_vector,
        y_column_name: request.y_column_name,
        y_vector: request.y_vector,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/trigger/byarea", actual_request, callback);
};

/**
 * Sets up an area trigger mechanism for two column_names for one or
 * more tables. (This function is essentially the two-dimensional version of
 * {@linkcode GPUdb#create_trigger_by_range}.) Once the trigger has been
 * activated, any
 * record added to the listed tables(s) via {@linkcode GPUdb#insert_records}
 * with the
 * chosen columns' values falling within the specified region will trip the
 * trigger. All such records will be queued at the trigger port (by default
 * '9001'
 * but able to be retrieved via {@linkcode GPUdb#show_system_status}) for any
 * listening
 * client to collect. Active triggers can be cancelled by using the
 * {@linkcode GPUdb#clear_trigger} endpoint or by clearing all relevant
 * tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 *
 * @param {String} request_id  User-created ID for the trigger. The ID can be
 *                             alphanumeric, contain symbols, and must contain
 *                             at least one character.
 * @param {String[]} table_names  Names of the tables on which the trigger will
 *                                be activated and maintained, each in
 *                                [schema_name.]table_name format, using
 *                                standard <a
 *                                href="../../../concepts/tables/#table-name-resolution"
 *                                target="_top">name resolution rules</a>.
 * @param {String} x_column_name  Name of a numeric column on which the trigger
 *                                is activated. Usually 'x' for geospatial data
 *                                points.
 * @param {Number[]} x_vector  The respective coordinate values for the region
 *                             on which the trigger is activated. This usually
 *                             translates to the x-coordinates of a geospatial
 *                             region.
 * @param {String} y_column_name  Name of a second numeric column on which the
 *                                trigger is activated. Usually 'y' for
 *                                geospatial data points.
 * @param {Number[]} y_vector  The respective coordinate values for the region
 *                             on which the trigger is activated. This usually
 *                             translates to the y-coordinates of a geospatial
 *                             region. Must be the same length as xvals.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_area = function(request_id, table_names, x_column_name, x_vector, y_column_name, y_vector, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_area(request_id, table_names, x_column_name, x_vector, y_column_name, y_vector, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request_id,
        table_names: table_names,
        x_column_name: x_column_name,
        x_vector: x_vector,
        y_column_name: y_column_name,
        y_vector: y_vector,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/trigger/byarea", actual_request, callback);
};

/**
 * Sets up a simple range trigger for a column_name for one or more
 * tables. Once the trigger has been activated, any record added to the listed
 * tables(s) via {@linkcode GPUdb#insert_records} with the chosen
 * column_name's value
 * falling within the specified range will trip the trigger. All such records
 * will
 * be queued at the trigger port (by default '9001' but able to be retrieved
 * via
 * {@linkcode GPUdb#show_system_status}) for any listening client to collect.
 * Active
 * triggers can be cancelled by using the {@linkcode GPUdb#clear_trigger}
 * endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request.request_id,
        table_names: request.table_names,
        column_name: request.column_name,
        min: request.min,
        max: request.max,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/trigger/byrange", actual_request, callback);
};

/**
 * Sets up a simple range trigger for a column_name for one or more
 * tables. Once the trigger has been activated, any record added to the listed
 * tables(s) via {@linkcode GPUdb#insert_records} with the chosen
 * column_name's value
 * falling within the specified range will trip the trigger. All such records
 * will
 * be queued at the trigger port (by default '9001' but able to be retrieved
 * via
 * {@linkcode GPUdb#show_system_status}) for any listening client to collect.
 * Active
 * triggers can be cancelled by using the {@linkcode GPUdb#clear_trigger}
 * endpoint or by
 * clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure
 * of the trigger activation.
 *
 * @param {String} request_id  User-created ID for the trigger. The ID can be
 *                             alphanumeric, contain symbols, and must contain
 *                             at least one character.
 * @param {String[]} table_names  Tables on which the trigger will be active,
 *                                each in [schema_name.]table_name format,
 *                                using standard <a
 *                                href="../../../concepts/tables/#table-name-resolution"
 *                                target="_top">name resolution rules</a>.
 * @param {String} column_name  Name of a numeric column_name on which the
 *                              trigger is activated.
 * @param {Number} min  The lower bound (inclusive) for the trigger range.
 * @param {Number} max  The upper bound (inclusive) for the trigger range.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_range = function(request_id, table_names, column_name, min, max, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_range(request_id, table_names, column_name, min, max, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request_id,
        table_names: table_names,
        column_name: column_name,
        min: min,
        max: max,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/trigger/byrange", actual_request, callback);
};

/**
 * Creates a new type describing the layout of a table. The type definition is
 * a JSON string describing the fields (i.e. columns) of the type. Each field
 * consists of a name and a data type. Supported data types are: double, float,
 * int, long, string, and bytes. In addition, one or more properties can be
 * specified for each column which customize the memory usage and query
 * availability of that column.  Note that some properties are mutually
 * exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are
 * <code>data</code> and <code>store_only</code>.
 * <p>
 * A single <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../../concepts/tables/#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key column value (or set of values for the key columns,
 * if using a composite primary key). When
 * [inserting]{@linkcode GPUdb#insert_records} data into a table with a
 * primary key, depending on the parameters in the request, incoming objects
 * with primary key values that match existing objects will either overwrite
 * (i.e. update) the existing object or will be skipped and not added into the
 * set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_definition: request.type_definition,
        label: request.label,
        properties: (request.properties !== undefined && request.properties !== null) ? request.properties : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/type", actual_request, callback);
};

/**
 * Creates a new type describing the layout of a table. The type definition is
 * a JSON string describing the fields (i.e. columns) of the type. Each field
 * consists of a name and a data type. Supported data types are: double, float,
 * int, long, string, and bytes. In addition, one or more properties can be
 * specified for each column which customize the memory usage and query
 * availability of that column.  Note that some properties are mutually
 * exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are
 * <code>data</code> and <code>store_only</code>.
 * <p>
 * A single <a href="../../../concepts/tables/#primary-keys"
 * target="_top">primary key</a> and/or single <a
 * href="../../../concepts/tables/#shard-keys" target="_top">shard key</a> can
 * be set across one or more columns. If a primary key is specified, then a
 * uniqueness constraint is enforced, in that only a single object can exist
 * with a given primary key column value (or set of values for the key columns,
 * if using a composite primary key). When
 * [inserting]{@linkcode GPUdb#insert_records} data into a table with a
 * primary key, depending on the parameters in the request, incoming objects
 * with primary key values that match existing objects will either overwrite
 * (i.e. update) the existing object or will be skipped and not added into the
 * set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 *
 * @param {String} type_definition  a JSON string describing the columns of the
 *                                  type to be registered.
 * @param {String} label  A user-defined description string which can be used
 *                        to differentiate between tables and types with
 *                        otherwise identical schemas.
 * @param {Object} properties  Each key-value pair specifies the properties to
 *                             use for a given column where the key is the
 *                             column name.  All keys used must be relevant
 *                             column names for the given table.  Specifying
 *                             any property overrides the default properties
 *                             for that column (which is based on the column's
 *                             data type).
 *                             Valid values are:
 *                             <ul>
 *                                     <li> 'data': Default property for all
 *                             numeric and string type columns; makes the
 *                             column available for GPU queries.
 *                                     <li> 'text_search': Valid only for
 *                             select 'string' columns. Enables full text
 *                             search--see <a
 *                             href="../../../concepts/full_text_search/"
 *                             target="_top">Full Text Search</a> for details
 *                             and applicable string column types. Can be set
 *                             independently of <code>data</code> and
 *                             <code>store_only</code>.
 *                                     <li> 'store_only': Persist the column
 *                             value but do not make it available to queries
 *                             (e.g. {@linkcode GPUdb#filter})-i.e. it is
 *                             mutually exclusive to the <code>data</code>
 *                             property. Any 'bytes' type column must have a
 *                             <code>store_only</code> property. This property
 *                             reduces system memory usage.
 *                                     <li> 'disk_optimized': Works in
 *                             conjunction with the <code>data</code> property
 *                             for string columns. This property reduces system
 *                             disk usage by disabling reverse string lookups.
 *                             Queries like {@linkcode GPUdb#filter},
 *                             {@linkcode GPUdb#filter_by_list}, and
 *                             {@linkcode GPUdb#filter_by_value} work as
 *                             usual but {@linkcode GPUdb#aggregate_unique}
 *                             and {@linkcode GPUdb#aggregate_group_by} are
 *                             not allowed on columns with this property.
 *                                     <li> 'timestamp': Valid only for 'long'
 *                             columns. Indicates that this field represents a
 *                             timestamp and will be provided in milliseconds
 *                             since the Unix epoch: 00:00:00 Jan 1 1970.
 *                             Dates represented by a timestamp must fall
 *                             between the year 1000 and the year 2900.
 *                                     <li> 'ulong': Valid only for 'string'
 *                             columns.  It represents an unsigned long integer
 *                             data type. The string can only be interpreted as
 *                             an unsigned long data type with minimum value of
 *                             zero, and maximum value of 18446744073709551615.
 *                                     <li> 'uuid': Valid only for 'string'
 *                             columns.  It represents an uuid data type.
 *                             Internally, it is stored as a 128-bit integer.
 *                                     <li> 'decimal': Valid only for 'string'
 *                             columns.  It represents a SQL type NUMERIC(19,
 *                             4) data type.  There can be up to 15 digits
 *                             before the decimal point and up to four digits
 *                             in the fractional part.  The value can be
 *                             positive or negative (indicated by a minus sign
 *                             at the beginning).  This property is mutually
 *                             exclusive with the <code>text_search</code>
 *                             property.
 *                                     <li> 'date': Valid only for 'string'
 *                             columns.  Indicates that this field represents a
 *                             date and will be provided in the format
 *                             'YYYY-MM-DD'.  The allowable range is 1000-01-01
 *                             through 2900-01-01.  This property is mutually
 *                             exclusive with the <code>text_search</code>
 *                             property.
 *                                     <li> 'time': Valid only for 'string'
 *                             columns.  Indicates that this field represents a
 *                             time-of-day and will be provided in the format
 *                             'HH:MM:SS.mmm'.  The allowable range is
 *                             00:00:00.000 through 23:59:59.999.  This
 *                             property is mutually exclusive with the
 *                             <code>text_search</code> property.
 *                                     <li> 'datetime': Valid only for 'string'
 *                             columns.  Indicates that this field represents a
 *                             datetime and will be provided in the format
 *                             'YYYY-MM-DD HH:MM:SS.mmm'.  The allowable range
 *                             is 1000-01-01 00:00:00.000 through 2900-01-01
 *                             23:59:59.999.  This property is mutually
 *                             exclusive with the <code>text_search</code>
 *                             property.
 *                                     <li> 'char1': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 1 character.
 *                                     <li> 'char2': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 2 characters.
 *                                     <li> 'char4': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 4 characters.
 *                                     <li> 'char8': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 8 characters.
 *                                     <li> 'char16': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 16 characters.
 *                                     <li> 'char32': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 32 characters.
 *                                     <li> 'char64': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 64 characters.
 *                                     <li> 'char128': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 128 characters.
 *                                     <li> 'char256': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns. Strings with this property must
 *                             be no longer than 256 characters.
 *                                     <li> 'int8': This property provides
 *                             optimized memory and query performance for int
 *                             columns. Ints with this property must be between
 *                             -128 and +127 (inclusive)
 *                                     <li> 'int16': This property provides
 *                             optimized memory and query performance for int
 *                             columns. Ints with this property must be between
 *                             -32768 and +32767 (inclusive)
 *                                     <li> 'ipv4': This property provides
 *                             optimized memory, disk and query performance for
 *                             string columns representing IPv4 addresses (i.e.
 *                             192.168.1.1). Strings with this property must be
 *                             of the form: A.B.C.D where A, B, C and D are in
 *                             the range of 0-255.
 *                                     <li> 'wkt': Valid only for 'string' and
 *                             'bytes' columns. Indicates that this field
 *                             contains geospatial geometry objects in
 *                             Well-Known Text (WKT) or Well-Known Binary (WKB)
 *                             format.
 *                                     <li> 'primary_key': This property
 *                             indicates that this column will be part of (or
 *                             the entire) <a
 *                             href="../../../concepts/tables/#primary-keys"
 *                             target="_top">primary key</a>.
 *                                     <li> 'shard_key': This property
 *                             indicates that this column will be part of (or
 *                             the entire) <a
 *                             href="../../../concepts/tables/#shard-keys"
 *                             target="_top">shard key</a>.
 *                                     <li> 'nullable': This property indicates
 *                             that this column is nullable.  However, setting
 *                             this property is insufficient for making the
 *                             column nullable.  The user must declare the type
 *                             of the column as a union between its regular
 *                             type and 'null' in the avro schema for the
 *                             record type in <code>type_definition</code>.
 *                             For example, if a column is of type integer and
 *                             is nullable, then the entry for the column in
 *                             the avro schema must be: ['int', 'null'].
 *                             The C++, C#, Java, and Python APIs have built-in
 *                             convenience for bypassing setting the avro
 *                             schema by hand.  For those languages, one can
 *                             use this property as usual and not have to worry
 *                             about the avro schema for the record.
 *                                     <li> 'dict': This property indicates
 *                             that this column should be <a
 *                             href="../../../concepts/dictionary_encoding/"
 *                             target="_top">dictionary encoded</a>. It can
 *                             only be used in conjunction with restricted
 *                             string (charN), int, long or date columns.
 *                             Dictionary encoding is best for columns where
 *                             the cardinality (the number of unique values) is
 *                             expected to be low. This property can save a
 *                             large amount of memory.
 *                                     <li> 'init_with_now': For 'date',
 *                             'time', 'datetime', or 'timestamp' column types,
 *                             replace empty strings and invalid timestamps
 *                             with 'NOW()' upon insert.
 *                                     <li> 'init_with_uuid': For 'uuid' type,
 *                             replace empty strings and invalid UUID values
 *                             with randomly-generated UUIDs upon insert.
 *                             </ul>
 *                             The default value is an empty dict ( {} ).
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_type = function(type_definition, label, properties, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_type(type_definition, label, properties, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_definition: type_definition,
        label: label,
        properties: (properties !== undefined && properties !== null) ? properties : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/type", actual_request, callback);
};

/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../../concepts/unions/" target="_top">Union</a>.  For limitations,
 * see <a href="../../../concepts/unions/#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../../concepts/intersect/" target="_top">Intersect</a>.  For
 * limitations, see <a href="../../../concepts/intersect/#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../../concepts/except/" target="_top">Except</a>.  For
 * limitations, see <a href="../../../concepts/except/#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a href="../../../concepts/filtered_views/"
 * target="_top">filtered views</a> on a single table, creates a single
 * filtered view containing all of the unique records across all of the given
 * filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_union_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_union_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        table_names: request.table_names,
        input_column_names: request.input_column_names,
        output_column_names: request.output_column_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/union", actual_request, callback);
};

/**
 * Merges data from one or more tables with comparable data types into a new
 * table.
 * <p>
 * The following merges are supported:
 * <p>
 * UNION (DISTINCT/ALL) - For data set union details and examples, see <a
 * href="../../../concepts/unions/" target="_top">Union</a>.  For limitations,
 * see <a href="../../../concepts/unions/#limitations-and-cautions"
 * target="_top">Union Limitations and Cautions</a>.
 * <p>
 * INTERSECT (DISTINCT/ALL) - For data set intersection details and examples,
 * see <a href="../../../concepts/intersect/" target="_top">Intersect</a>.  For
 * limitations, see <a href="../../../concepts/intersect/#limitations"
 * target="_top">Intersect Limitations</a>.
 * <p>
 * EXCEPT (DISTINCT/ALL) - For data set subtraction details and examples, see
 * <a href="../../../concepts/except/" target="_top">Except</a>.  For
 * limitations, see <a href="../../../concepts/except/#limitations"
 * target="_top">Except Limitations</a>.
 * <p>
 * MERGE VIEWS - For a given set of <a href="../../../concepts/filtered_views/"
 * target="_top">filtered views</a> on a single table, creates a single
 * filtered view containing all of the unique records across all of the given
 * filtered data sets.
 * <p>
 * Non-charN 'string' and 'bytes' column types cannot be merged, nor can
 * columns marked as <a href="../../../concepts/types/#data-handling"
 * target="_top">store-only</a>.
 *
 * @param {String} table_name  Name of the table to be created, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a> and
 *                             meeting <a
 *                             href="../../../concepts/tables/#table-naming-criteria"
 *                             target="_top">table naming criteria</a>.
 * @param {String[]} table_names  The list of table names to merge, in
 *                                [schema_name.]table_name format, using
 *                                standard <a
 *                                href="../../../concepts/tables/#table-name-resolution"
 *                                target="_top">name resolution rules</a>.
 *                                Must contain the names of one or more
 *                                existing tables.
 * @param {String[][]} input_column_names  The list of columns from each of the
 *                                         corresponding input tables.
 * @param {String[]} output_column_names  The list of names of the columns to
 *                                        be stored in the output table.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>table_name</code>. If
 *                          <code>persist</code> is <code>false</code> (or
 *                          unspecified), then this is always allowed even if
 *                          the caller does not have permission to create
 *                          tables. The generated name is returned in
 *                          <code>qualified_table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the projection as
 *                          part of <code>table_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of the schema for the
 *                          output table. If the schema provided is
 *                          non-existent, it will be automatically created.
 *                          The default value is ''.
 *                                  <li> 'mode': If <code>merge_views</code>,
 *                          then this operation will merge the provided views.
 *                          All <code>table_names</code> must be views from the
 *                          same underlying base table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'union_all': Retains all rows from the
 *                          specified tables.
 *                                  <li> 'union': Retains all unique rows from
 *                          the specified tables (synonym for
 *                          <code>union_distinct</code>).
 *                                  <li> 'union_distinct': Retains all unique
 *                          rows from the specified tables.
 *                                  <li> 'except': Retains all unique rows from
 *                          the first table that do not appear in the second
 *                          table (only works on 2 tables).
 *                                  <li> 'except_all': Retains all
 *                          rows(including duplicates) from the first table
 *                          that do not appear in the second table (only works
 *                          on 2 tables).
 *                                  <li> 'intersect': Retains all unique rows
 *                          that appear in both of the specified tables (only
 *                          works on 2 tables).
 *                                  <li> 'intersect_all': Retains all
 *                          rows(including duplicates) that appear in both of
 *                          the specified tables (only works on 2 tables).
 *                                  <li> 'merge_views': Merge two or more views
 *                          (or views of views) of the same base data set into
 *                          a new view. If this mode is selected
 *                          <code>input_column_names</code> AND
 *                          <code>output_column_names</code> must be empty. The
 *                          resulting view would match the results of a SQL OR
 *                          operation, e.g., if filter 1 creates a view using
 *                          the expression 'x = 20' and filter 2 creates a view
 *                          using the expression 'x <= 10', then the merge
 *                          views operation creates a new view using the
 *                          expression 'x = 20 OR x <= 10'.
 *                          </ul>
 *                          The default value is 'union_all'.
 *                                  <li> 'chunk_size': Indicates the number of
 *                          records per chunk to be used for this output table.
 *                                  <li> 'create_indexes': Comma-separated list
 *                          of columns on which to create indexes on the output
 *                          table.  The columns specified must be present in
 *                          <code>output_column_names</code>.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the output table specified in
 *                          <code>table_name</code>.
 *                                  <li> 'persist': If <code>true</code>, then
 *                          the output table specified in
 *                          <code>table_name</code> will be persisted and will
 *                          not expire unless a <code>ttl</code> is specified.
 *                          If <code>false</code>, then the output table will
 *                          be an in-memory table and will expire unless a
 *                          <code>ttl</code> is specified otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'view_id': ID of view of which this
 *                          output table is a member.  The default value is ''.
 *                                  <li> 'force_replicated': If
 *                          <code>true</code>, then the output table specified
 *                          in <code>table_name</code> will be replicated even
 *                          if the source tables are not.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_union = function(table_name, table_names, input_column_names, output_column_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_union(table_name, table_names, input_column_names, output_column_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        table_names: table_names,
        input_column_names: input_column_names,
        output_column_names: output_column_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/union", actual_request, callback);
};

/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_user_external_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_user_external_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/user/external", actual_request, callback);
};

/**
 * Creates a new external user (a user whose credentials are managed by an
 * external LDAP).
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String} name  Name of the user to be created. Must exactly match the
 *                       user's name in the external LDAP, prefixed with a @.
 *                       Must not be the same name as an existing user.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_home_directory': when true, a
 *                          home directory in KiFS is created for this user
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_user_external = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_user_external(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/user/external", actual_request, callback);
};

/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_user_internal_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_user_internal_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        password: request.password,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/user/internal", actual_request, callback);
};

/**
 * Creates a new internal user (a user whose credentials are managed by the
 * database system).
 *
 * @param {String} name  Name of the user to be created. Must contain only
 *                       lowercase letters, digits, and underscores, and cannot
 *                       begin with a digit. Must not be the same name as an
 *                       existing user or role.
 * @param {String} password  Initial password of the user to be created. May be
 *                           an empty string for no password.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'resource_group': Name of an existing
 *                          resource group to associate with this user
 *                                  <li> 'default_schema': default schema
 *                          associate with this user
 *                                  <li> 'create_home_directory': when true, a
 *                          home directory in KiFS is created for this user
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_user_internal = function(name, password, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_user_internal(name, password, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        password: password,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/user/internal", actual_request, callback);
};

/**
 * Creates a job to generate a sequence of raster images that visualize data
 * over a specified time.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_video_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_video_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        attribute: request.attribute,
        begin: request.begin,
        duration_seconds: request.duration_seconds,
        end: request.end,
        frames_per_second: request.frames_per_second,
        style: request.style,
        path: request.path,
        style_parameters: request.style_parameters,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/video", actual_request, callback);
};

/**
 * Creates a job to generate a sequence of raster images that visualize data
 * over a specified time.
 *
 * @param {String} attribute  The animated attribute to map to the video's
 *                            frames. Must be present in the LAYERS specified
 *                            for the visualization. This is often a
 *                            time-related field but may be any numeric type.
 * @param {String} begin  The start point for the video. Accepts an expression
 *                        evaluable over the <code>attribute</code>.
 * @param {Number} duration_seconds  Seconds of video to produce
 * @param {String} end  The end point for the video. Accepts an expression
 *                      evaluable over the <code>attribute</code>.
 * @param {Number} frames_per_second  The presentation frame rate of the
 *                                    encoded video in frames per second.
 * @param {String} style  The name of the visualize mode; should correspond to
 *                        the schema used for the <code>style_parameters</code>
 *                        field.
 *                        Supported values:
 *                        <ul>
 *                                <li> 'chart'
 *                                <li> 'raster'
 *                                <li> 'classbreak'
 *                                <li> 'contour'
 *                                <li> 'heatmap'
 *                                <li> 'labels'
 *                        </ul>
 * @param {String} path  Fully-qualified <a href="../../../tools/kifs/"
 *                       target="_top">KiFS</a> path.  Write access is
 *                       required. A file must not exist at that path, unless
 *                       <code>replace_if_exists</code> is <code>true</code>.
 * @param {String} style_parameters  A string containing the JSON-encoded
 *                                   visualize request.  Must correspond to the
 *                                   visualize mode specified in the
 *                                   <code>style</code> field.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the video.
 *                                  <li> 'window': Specified using the
 *                          data-type corresponding to the
 *                          <code>attribute</code>. For a window of size W, a
 *                          video frame rendered for time t will visualize data
 *                          in the interval [t-W,t]. The minimum window size is
 *                          the interval between successive frames.  The
 *                          minimum value is the default.  If a value less than
 *                          the minimum value is specified, it is replaced with
 *                          the minimum window size.  Larger values will make
 *                          changes throughout the video appear more smooth
 *                          while smaller values will capture fast variations
 *                          in the data.
 *                                  <li> 'no_error_if_exists': If
 *                          <code>true</code>, does not return an error if the
 *                          video already exists.  Ignored if
 *                          <code>replace_if_exists</code> is
 *                          <code>true</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'false'
 *                                  <li> 'true'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'replace_if_exists': If
 *                          <code>true</code>, deletes any existing video with
 *                          the same path before creating a new video.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'false'
 *                                  <li> 'true'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_video = function(attribute, begin, duration_seconds, end, frames_per_second, style, path, style_parameters, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_video(attribute, begin, duration_seconds, end, frames_per_second, style, path, style_parameters, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        attribute: attribute,
        begin: begin,
        duration_seconds: duration_seconds,
        end: end,
        frames_per_second: frames_per_second,
        style: style,
        path: path,
        style_parameters: style_parameters,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/video", actual_request, callback);
};

/**
 * Deletes a directory from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_directory_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_directory_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        directory_name: request.directory_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/directory", actual_request, callback);
};

/**
 * Deletes a directory from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 *
 * @param {String} directory_name  Name of the directory in KiFS to be deleted.
 *                                 The directory must contain no files, unless
 *                                 <code>recursive</code> is <code>true</code>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'recursive': If <code>true</code>,
 *                          will delete directory and all files residing in it.
 *                          If false, directory must be empty for deletion.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>true</code>, no error is returned if
 *                          specified directory does not exist
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_directory = function(directory_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_directory(directory_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        directory_name: directory_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/directory", actual_request, callback);
};

/**
 * Deletes one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_files_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_files_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        file_names: request.file_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/files", actual_request, callback);
};

/**
 * Deletes one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 *
 * @param {String[]} file_names  An array of names of files to be deleted.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>true</code>, no error is returned if a
 *                          specified file does not exist
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_files = function(file_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_files(file_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        file_names: file_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/files", actual_request, callback);
};

/**
 * Deletes an existing graph from the graph server and/or persist.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/graph", actual_request, callback);
};

/**
 * Deletes an existing graph from the graph server and/or persist.
 *
 * @param {String} graph_name  Name of the graph to be deleted.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'delete_persist': If set to
 *                          <code>true</code>, the graph is removed from the
 *                          server and persist. If set to <code>false</code>,
 *                          the graph is removed from the server but is left in
 *                          persist. The graph can be reloaded from persist if
 *                          it is recreated with the same 'graph_name'.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'server_id': Indicates which graph
 *                          server(s) to send the request to. Default is to
 *                          send to get information about all the servers.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_graph = function(graph_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_graph(graph_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/graph", actual_request, callback);
};

/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: request.proc_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/proc", actual_request, callback);
};

/**
 * Deletes a proc. Any currently running instances of the proc will be killed.
 *
 * @param {String} proc_name  Name of the proc to be deleted. Must be the name
 *                            of a currently existing proc.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_proc = function(proc_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_proc(proc_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: proc_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/proc", actual_request, callback);
};

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more
 * <code>expressions</code> (matching multiple records), a single record
 * identified by <code>record_id</code> options, or all records when using
 * <code>delete_all_records</code>.  Note that the three selection criteria are
 * mutually exclusive.  This operation cannot be run on a view.  The operation
 * is synchronous meaning that a response will not be available until the
 * request is completely processed and all the matching records are deleted.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        expressions: request.expressions,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/records", actual_request, callback);
};

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more
 * <code>expressions</code> (matching multiple records), a single record
 * identified by <code>record_id</code> options, or all records when using
 * <code>delete_all_records</code>.  Note that the three selection criteria are
 * mutually exclusive.  This operation cannot be run on a view.  The operation
 * is synchronous meaning that a response will not be available until the
 * request is completely processed and all the matching records are deleted.
 *
 * @param {String} table_name  Name of the table from which to delete records,
 *                             in [schema_name.]table_name format, using
 *                             standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>. Must
 *                             contain the name of an existing table; not
 *                             applicable to views.
 * @param {String[]} expressions  A list of the actual predicates, one for each
 *                                select; format should follow the guidelines
 *                                provided <a
 *                                href="../../../concepts/expressions/"
 *                                target="_top">here</a>. Specifying one or
 *                                more <code>expressions</code> is mutually
 *                                exclusive to specifying
 *                                <code>record_id</code> in the
 *                                <code>options</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'global_expression': An optional
 *                          global expression to reduce the search space of the
 *                          <code>expressions</code>.  The default value is ''.
 *                                  <li> 'record_id': A record ID identifying a
 *                          single record, obtained at the time of
 *                          [insertion of the record]{@linkcode GPUdb#insert_records}
 *                          or by calling
 *                          {@linkcode GPUdb#get_records_from_collection}
 *                          with the *return_record_ids* option. This option
 *                          cannot be used to delete records from <a
 *                          href="../../../concepts/tables/#replication"
 *                          target="_top">replicated</a> tables.
 *                                  <li> 'delete_all_records': If set to
 *                          <code>true</code>, all records in the table will be
 *                          deleted. If set to <code>false</code>, then the
 *                          option is effectively ignored.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_records = function(table_name, expressions, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_records(table_name, expressions, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        expressions: expressions,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/records", actual_request, callback);
};

/**
 * Deletes a resource group.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_resource_group_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_resource_group_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/resourcegroup", actual_request, callback);
};

/**
 * Deletes a resource group.
 *
 * @param {String} name  Name of the resource group to be deleted.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'cascade_delete': If
 *                          <code>true</code>, delete any existing entities
 *                          owned by this group. Otherwise this request will
 *                          return an error of any such entities exist.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_resource_group = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_resource_group(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/resourcegroup", actual_request, callback);
};

/**
 * Deletes an existing role.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/role", actual_request, callback);
};

/**
 * Deletes an existing role.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String} name  Name of the role to be deleted. Must be an existing
 *                       role.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_role = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_role(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/role", actual_request, callback);
};

/**
 * Deletes an existing user.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_user_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_user_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/user", actual_request, callback);
};

/**
 * Deletes an existing user.
 * <p>
 * <b>Note:</b> This method should be used for on-premise deployments only.
 * <p>
 *
 * @param {String} name  Name of the user to be deleted. Must be an existing
 *                       user.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_user = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_user(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/user", actual_request, callback);
};

/**
 * Downloads one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.download_files_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.download_files_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        file_names: request.file_names,
        read_offsets: request.read_offsets,
        read_lengths: request.read_lengths,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/download/files", actual_request, callback);
};

/**
 * Downloads one or more files from <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 *
 * @param {String[]} file_names  An array of the file names to download from
 *                               KiFS. The full path must be provided.
 * @param {Number[]} read_offsets  An array of starting byte offsets from which
 *                                 to read each
 *                                 respective file in <code>file_names</code>.
 *                                 Must either be empty or the same length
 *                                 as <code>file_names</code>. If empty, files
 *                                 are downloaded in their entirety. If not
 *                                 empty, <code>read_lengths</code> must also
 *                                 not be empty.
 * @param {Number[]} read_lengths  Array of number of bytes to read from each
 *                                 respective file
 *                                 in <code>file_names</code>. Must either be
 *                                 empty or the same length as
 *                                 <code>file_names</code>. If empty, files are
 *                                 downloaded in their entirety. If not
 *                                 empty, <code>read_offsets</code> must also
 *                                 not be empty.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'file_encoding': Encoding to be
 *                          applied to the output file data. When using JSON
 *                          serialization it is recommended to specify this as
 *                          <code>base64</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'base64': Apply base64 encoding to the
 *                          output file data.
 *                                  <li> 'none': Do not apply any encoding to
 *                          the output file data.
 *                          </ul>
 *                          The default value is 'none'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.download_files = function(file_names, read_offsets, read_lengths, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.download_files(file_names, read_offsets, read_lengths, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        file_names: file_names,
        read_offsets: read_offsets,
        read_lengths: read_lengths,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/download/files", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.drop_container_registry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_container_registry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        registry_name: request.registry_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/drop/container/registry", actual_request, callback);
};

/**
 *
 * @param {String} registry_name
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.drop_container_registry = function(registry_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_container_registry(registry_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        registry_name: registry_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/drop/container/registry", actual_request, callback);
};

/**
 * Drop an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.drop_credential_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_credential_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        credential_name: request.credential_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/drop/credential", actual_request, callback);
};

/**
 * Drop an existing <a href="../../../concepts/credentials/"
 * target="_top">credential</a>.
 *
 * @param {String} credential_name  Name of the credential to be dropped. Must
 *                                  be an existing credential.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.drop_credential = function(credential_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_credential(credential_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        credential_name: credential_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/drop/credential", actual_request, callback);
};

/**
 * Drops an existing <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>.
 * <p>
 * By default, if any <a href="../../../concepts/table_monitors"
 * target="_top">table monitors</a> use this
 * sink as a destination, the request will be blocked unless option
 * <code>clear_table_monitors</code> is
 * <code>true</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.drop_datasink_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_datasink_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/drop/datasink", actual_request, callback);
};

/**
 * Drops an existing <a href="../../../concepts/data_sinks/" target="_top">data
 * sink</a>.
 * <p>
 * By default, if any <a href="../../../concepts/table_monitors"
 * target="_top">table monitors</a> use this
 * sink as a destination, the request will be blocked unless option
 * <code>clear_table_monitors</code> is
 * <code>true</code>.
 *
 * @param {String} name  Name of the data sink to be dropped. Must be an
 *                       existing data sink.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'clear_table_monitors': If
 *                          <code>true</code>, any <a
 *                          href="../../../concepts/table_monitors/"
 *                          target="_top">table monitors</a> that use this data
 *                          sink will be cleared.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.drop_datasink = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_datasink(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/drop/datasink", actual_request, callback);
};

/**
 * Drops an existing <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.  Any external
 * tables that depend on the data source must be dropped before it can be
 * dropped.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.drop_datasource_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_datasource_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/drop/datasource", actual_request, callback);
};

/**
 * Drops an existing <a href="../../../concepts/data_sources/"
 * target="_top">data source</a>.  Any external
 * tables that depend on the data source must be dropped before it can be
 * dropped.
 *
 * @param {String} name  Name of the data source to be dropped. Must be an
 *                       existing data source.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.drop_datasource = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_datasource(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/drop/datasource", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.drop_model_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_model_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_name: request.model_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/drop/model", actual_request, callback);
};

/**
 *
 * @param {String} model_name
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.drop_model = function(model_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_model(model_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_name: model_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/drop/model", actual_request, callback);
};

/**
 * Drops an existing SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in <code>schema_name</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.drop_schema_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_schema_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: request.schema_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/drop/schema", actual_request, callback);
};

/**
 * Drops an existing SQL-style <a href="../../../concepts/schemas/"
 * target="_top">schema</a>, specified in <code>schema_name</code>.
 *
 * @param {String} schema_name  Name of the schema to be dropped. Must be an
 *                              existing schema.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>true</code> and if the schema specified in
 *                          <code>schema_name</code> does not exist, no error
 *                          is returned. If <code>false</code> and if the
 *                          schema specified in <code>schema_name</code> does
 *                          not exist, then an error is returned.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'cascade': If <code>true</code>, all
 *                          tables within the schema will be dropped. If
 *                          <code>false</code>, the schema will be dropped only
 *                          if empty.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.drop_schema = function(schema_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.drop_schema(schema_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: schema_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/drop/schema", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.evaluate_model_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.evaluate_model_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_name: request.model_name,
        replicas: request.replicas,
        deployment_mode: request.deployment_mode,
        source_table: request.source_table,
        destination_table: request.destination_table,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/evaluate/model", actual_request, callback);
};

/**
 *
 * @param {String} model_name
 * @param {Number} replicas
 * @param {String} deployment_mode
 * @param {String} source_table
 * @param {String} destination_table
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.evaluate_model = function(model_name, replicas, deployment_mode, source_table, destination_table, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.evaluate_model(model_name, replicas, deployment_mode, source_table, destination_table, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_name: model_name,
        replicas: replicas,
        deployment_mode: deployment_mode,
        source_table: source_table,
        destination_table: destination_table,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/evaluate/model", actual_request, callback);
};

/**
 * Executes a proc. This endpoint is asynchronous and does not wait for
 * the proc to complete before returning.
 * <p>
 * If the proc being executed is distributed, <code>input_table_names</code> &
 * <code>input_column_names</code> may be passed to the proc to use for reading
 * data,
 * and <code>output_table_names</code> may be passed to the proc to use for
 * writing
 * data.
 * <p>
 * If the proc being executed is non-distributed, these table parameters will
 * be
 * ignored.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.execute_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.execute_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: request.proc_name,
        params: (request.params !== undefined && request.params !== null) ? request.params : {},
        bin_params: (request.bin_params !== undefined && request.bin_params !== null) ? request.bin_params : {},
        input_table_names: (request.input_table_names !== undefined && request.input_table_names !== null) ? request.input_table_names : [],
        input_column_names: (request.input_column_names !== undefined && request.input_column_names !== null) ? request.input_column_names : {},
        output_table_names: (request.output_table_names !== undefined && request.output_table_names !== null) ? request.output_table_names : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/execute/proc", actual_request, callback);
};

/**
 * Executes a proc. This endpoint is asynchronous and does not wait for
 * the proc to complete before returning.
 * <p>
 * If the proc being executed is distributed, <code>input_table_names</code> &
 * <code>input_column_names</code> may be passed to the proc to use for reading
 * data,
 * and <code>output_table_names</code> may be passed to the proc to use for
 * writing
 * data.
 * <p>
 * If the proc being executed is non-distributed, these table parameters will
 * be
 * ignored.
 *
 * @param {String} proc_name  Name of the proc to execute. Must be the name of
 *                            a currently existing proc.
 * @param {Object} params  A map containing named parameters to pass to the
 *                         proc. Each key/value pair specifies the name of a
 *                         parameter and its value.
 * @param {Object} bin_params  A map containing named binary parameters to pass
 *                             to the proc. Each key/value pair specifies the
 *                             name of a parameter and its value.
 * @param {String[]} input_table_names  Names of the tables containing data to
 *                                      be passed to the
 *                                      proc. Each name specified must be the
 *                                      name of a currently existing table, in
 *                                      [schema_name.]table_name format, using
 *                                      standard
 *                                      <a
 *                                      href="../../../concepts/tables/#table-name-resolution"
 *                                      target="_top">name resolution
 *                                      rules</a>.
 *                                      If no table names are specified, no
 *                                      data will be passed to the proc.  This
 *                                      parameter is ignored if the proc has a
 *                                      non-distributed execution mode.
 * @param {Object} input_column_names  Map of table names from
 *                                     <code>input_table_names</code> to lists
 *                                     of names of columns from those tables
 *                                     that will be passed to the proc. Each
 *                                     column name specified must be the name
 *                                     of an existing column in the
 *                                     corresponding table. If a table name
 *                                     from <code>input_table_names</code> is
 *                                     not
 *                                     included, all columns from that table
 *                                     will be passed to the proc.  This
 *                                     parameter is ignored if the proc has a
 *                                     non-distributed execution mode.
 * @param {String[]} output_table_names  Names of the tables to which output
 *                                       data from the proc will
 *                                       be written, each in
 *                                       [schema_name.]table_name format, using
 *                                       standard
 *                                       <a
 *                                       href="../../../concepts/tables/#table-name-resolution"
 *                                       target="_top">name resolution
 *                                       rules</a>
 *                                       and meeting <a
 *                                       href="../../../concepts/tables/#table-naming-criteria"
 *                                       target="_top">table naming
 *                                       criteria</a>.
 *                                       If a specified table does not exist,
 *                                       it will automatically be created with
 *                                       the
 *                                       same schema as the corresponding table
 *                                       (by order) from
 *                                       <code>input_table_names</code>,
 *                                       excluding any primary and shard keys.
 *                                       If a specified
 *                                       table is a non-persistent result
 *                                       table, it must not have primary or
 *                                       shard keys.
 *                                       If no table names are specified, no
 *                                       output data can be returned from the
 *                                       proc.
 *                                       This parameter is ignored if the proc
 *                                       has a non-distributed execution mode.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'cache_input': A comma-delimited list
 *                          of table names from <code>input_table_names</code>
 *                          from which input data will be cached for use in
 *                          subsequent calls to
 *                          {@linkcode GPUdb#execute_proc} with the
 *                          <code>use_cached_input</code> option. Cached input
 *                          data will be retained until the proc status is
 *                          cleared with the
 *                          [clear_complete]{@linkcode GPUdb#show_proc_status}
 *                          option of {@linkcode GPUdb#show_proc_status} and
 *                          all proc instances using the cached data have
 *                          completed.  The default value is ''.
 *                                  <li> 'use_cached_input': A comma-delimited
 *                          list of run IDs (as returned from prior calls to
 *                          {@linkcode GPUdb#execute_proc}) of running or
 *                          completed proc instances from which input data
 *                          cached using the <code>cache_input</code> option
 *                          will be used. Cached input data will not be used
 *                          for any tables specified in
 *                          <code>input_table_names</code>, but data from all
 *                          other tables cached for the specified run IDs will
 *                          be passed to the proc. If the same table was cached
 *                          for multiple specified run IDs, the cached data
 *                          from the first run ID specified in the list that
 *                          includes that table will be used.  The default
 *                          value is ''.
 *                                  <li> 'run_tag': A string that, if not
 *                          empty, can be used in subsequent calls to
 *                          {@linkcode GPUdb#show_proc_status} or
 *                          {@linkcode GPUdb#kill_proc} to identify the proc
 *                          instance.  The default value is ''.
 *                                  <li> 'max_output_lines': The maximum number
 *                          of lines of output from stdout and stderr to return
 *                          via {@linkcode GPUdb#show_proc_status}. If the
 *                          number of lines output exceeds the maximum, earlier
 *                          lines are discarded.  The default value is '100'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.execute_proc = function(proc_name, params, bin_params, input_table_names, input_column_names, output_table_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.execute_proc(proc_name, params, bin_params, input_table_names, input_column_names, output_table_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: proc_name,
        params: (params !== undefined && params !== null) ? params : {},
        bin_params: (bin_params !== undefined && bin_params !== null) ? bin_params : {},
        input_table_names: (input_table_names !== undefined && input_table_names !== null) ? input_table_names : [],
        input_column_names: (input_column_names !== undefined && input_column_names !== null) ? input_column_names : {},
        output_table_names: (output_table_names !== undefined && output_table_names !== null) ? output_table_names : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/execute/proc", actual_request, callback);
};

/**
 * Execute a SQL statement (query, DML, or DDL).
 * <p>
 * See <a href="../../../sql/" target="_top">SQL Support</a> for the complete
 * set of supported SQL commands.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.execute_sql_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.execute_sql_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        statement: request.statement,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : -9999,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        request_schema_str: (request.request_schema_str !== undefined && request.request_schema_str !== null) ? request.request_schema_str : "",
        data: (request.data !== undefined && request.data !== null) ? request.data : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    var self = this;
    this.submit_request("/execute/sql", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Execute a SQL statement (query, DML, or DDL).
 * <p>
 * See <a href="../../../sql/" target="_top">SQL Support</a> for the complete
 * set of supported SQL commands.
 *
 * @param {String} statement  SQL statement (query, DML, or DDL) to be executed
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned, or
 *                        END_OF_SET (-9999) to indicate that the maximum
 *                        number of results allowed by the server should be
 *                        returned.  The number of records returned will never
 *                        exceed the server's own limit, defined by the
 *                        <a href="../../../config/#config-main-general"
 *                        target="_top">max_get_records_size</a> parameter in
 *                        the server configuration.
 *                        Use <code>has_more_records</code> to see if more
 *                        records exist in the result to be fetched, and
 *                        <code>offset</code> & <code>limit</code> to request
 *                        subsequent pages of results.
 * @param {String} request_schema_str  Avro schema of <code>data</code>.
 * @param {String[]} data  An array of binary-encoded data for the records to
 *                         be binded to the SQL query.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'parallel_execution': If
 *                          <code>false</code>, disables the parallel step
 *                          execution of the given query.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'cost_based_optimization': If
 *                          <code>false</code>, disables the cost-based
 *                          optimization of the given query.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'plan_cache': If <code>false</code>,
 *                          disables plan caching for the given query.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'rule_based_optimization': If
 *                          <code>false</code>, disables rule-based rewrite
 *                          optimizations for the given query
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'results_caching': If
 *                          <code>false</code>, disables caching of the results
 *                          of the given query
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'paging_table': When empty or the
 *                          specified paging table not exists, the system will
 *                          create a paging table and return when query output
 *                          has more records than the user asked. If the paging
 *                          table exists in the system, the records from the
 *                          paging table are returned without evaluating the
 *                          query.
 *                                  <li> 'paging_table_ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the paging table.
 *                                  <li> 'distributed_joins': If
 *                          <code>true</code>, enables the use of distributed
 *                          joins in servicing the given query.  Any query
 *                          requiring a distributed join will succeed, though
 *                          hints can be used in the query to change the
 *                          distribution of the source data to allow the query
 *                          to succeed.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'distributed_operations': If
 *                          <code>true</code>, enables the use of distributed
 *                          operations in servicing the given query.  Any query
 *                          requiring a distributed join will succeed, though
 *                          hints can be used in the query to change the
 *                          distribution of the source data to allow the query
 *                          to succeed.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'ssq_optimization': If
 *                          <code>false</code>, scalar subqueries will be
 *                          translated into joins
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'late_materialization': If
 *                          <code>true</code>, Joins/Filters results  will
 *                          always be materialized ( saved to result tables
 *                          format)
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the intermediate result tables used in query
 *                          execution.
 *                                  <li> 'update_on_existing_pk': Can be used
 *                          to customize behavior when the updated primary key
 *                          value already exists as described in
 *                          {@linkcode GPUdb#insert_records}.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'preserve_dict_encoding': If
 *                          <code>true</code>, then columns that were dict
 *                          encoded in the source table will be dict encoded in
 *                          the projection table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'validate_change_column': When
 *                          changing a column using alter table, validate the
 *                          change before applying it. If <code>true</code>,
 *                          then validate all values. A value too large (or too
 *                          long) for the new type will prevent any change. If
 *                          <code>false</code>, then when a value is too large
 *                          or long, it will be truncated.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'prepare_mode': If <code>true</code>,
 *                          compiles a query into an execution plan and saves
 *                          it in query cache. Query execution is not performed
 *                          and an empty response will be returned to user
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.execute_sql = function(statement, offset, limit, request_schema_str, data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.execute_sql(statement, offset, limit, request_schema_str, data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        statement: statement,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : -9999,
        encoding: "json",
        request_schema_str: (request_schema_str !== undefined && request_schema_str !== null) ? request_schema_str : "",
        data: (data !== undefined && data !== null) ? data : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    var self = this;
    this.submit_request("/execute/sql", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Exports records from source table to  specified target table in an external
 * database
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.export_records_to_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.export_records_to_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        remote_query: request.remote_query,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/export/records/totable", actual_request, callback);
};

/**
 * Exports records from source table to  specified target table in an external
 * database
 *
 * @param {String} table_name  Name of the table from which the data will be
 *                             exported to remote database, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} remote_query  Parameterized insert query to export gpudb
 *                               table data into remote database
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'batch_size': Batch size, which
 *                          determines how many rows to export per round trip.
 *                                  <li> 'datasink_name': Name of an existing
 *                          external data sink to which table name specified in
 *                          <code>table_name</code> will be exported
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.export_records_to_table = function(table_name, remote_query, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.export_records_to_table(table_name, remote_query, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        remote_query: remote_query,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/export/records/totable", actual_request, callback);
};

/**
 * Filters data based on the specified expression.  The results are
 * stored in a <a href="../../../concepts/filtered_views/" target="_top">result
 * set</a> with the
 * given <code>view_name</code>.
 * <p>
 * For details see <a href="../../../concepts/expressions/"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        expression: request.expression,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter", actual_request, callback);
};

/**
 * Filters data based on the specified expression.  The results are
 * stored in a <a href="../../../concepts/filtered_views/" target="_top">result
 * set</a> with the
 * given <code>view_name</code>.
 * <p>
 * For details see <a href="../../../concepts/expressions/"
 * target="_top">Expressions</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 *
 * @param {String} table_name  Name of the table to filter, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  This
 *                             may be the name of a table or a view (when
 *                             chaining queries).
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} expression  The select expression to filter the specified
 *                             table.  For details see <a
 *                             href="../../../concepts/expressions/"
 *                             target="_top">Expressions</a>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema is non-existent,
 *                          it will be automatically created.
 *                                  <li> 'view_id': view this filtered-view is
 *                          part of.  The default value is ''.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the view specified in <code>view_name</code>.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter = function(table_name, view_name, expression, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter(table_name, view_name, expression, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        expression: expression,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter", actual_request, callback);
};

/**
 * Calculates which objects from a table are within a named area of
 * interest (NAI/polygon). The operation is synchronous, meaning that a
 * response
 * will not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input NAI restriction specification is created
 * with
 * the name <code>view_name</code> passed in as part of the input.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_area_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_area_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        x_vector: request.x_vector,
        y_column_name: request.y_column_name,
        y_vector: request.y_vector,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byarea", actual_request, callback);
};

/**
 * Calculates which objects from a table are within a named area of
 * interest (NAI/polygon). The operation is synchronous, meaning that a
 * response
 * will not be returned until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input NAI restriction specification is created
 * with
 * the name <code>view_name</code> passed in as part of the input.
 *
 * @param {String} table_name  Name of the table to filter, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  This
 *                             may be the name of a table or a view (when
 *                             chaining queries).
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} x_column_name  Name of the column containing the x values to
 *                                be filtered.
 * @param {Number[]} x_vector  List of x coordinates of the vertices of the
 *                             polygon representing the area to be filtered.
 * @param {String} y_column_name  Name of the column containing the y values to
 *                                be filtered.
 * @param {Number[]} y_vector  List of y coordinates of the vertices of the
 *                             polygon representing the area to be filtered.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema provided is
 *                          non-existent, it will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_area = function(table_name, view_name, x_column_name, x_vector, y_column_name, y_vector, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_area(table_name, view_name, x_column_name, x_vector, y_column_name, y_vector, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        x_vector: x_vector,
        y_column_name: y_column_name,
        y_vector: y_vector,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byarea", actual_request, callback);
};

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a named area of interest (NAI/polygon). The operation is synchronous,
 * meaning
 * that a response will not be returned until all the matching objects are
 * fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input NAI restriction specification
 * is
 * created with the name <code>view_name</code> passed in as part of the input.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_area_geometry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_area_geometry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        x_vector: request.x_vector,
        y_vector: request.y_vector,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byarea/geometry", actual_request, callback);
};

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a named area of interest (NAI/polygon). The operation is synchronous,
 * meaning
 * that a response will not be returned until all the matching objects are
 * fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input NAI restriction specification
 * is
 * created with the name <code>view_name</code> passed in as part of the input.
 *
 * @param {String} table_name  Name of the table to filter, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  This
 *                             may be the name of a table or a view (when
 *                             chaining queries).
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} column_name  Name of the geospatial geometry column to be
 *                              filtered.
 * @param {Number[]} x_vector  List of x coordinates of the vertices of the
 *                             polygon representing the area to be filtered.
 * @param {Number[]} y_vector  List of y coordinates of the vertices of the
 *                             polygon representing the area to be filtered.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  The schema for the newly
 *                          created view. If the schema is non-existent, it
 *                          will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_area_geometry = function(table_name, view_name, column_name, x_vector, y_vector, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_area_geometry(table_name, view_name, column_name, x_vector, y_vector, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        x_vector: x_vector,
        y_vector: y_vector,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byarea/geometry", actual_request, callback);
};

/**
 * Calculates how many objects within the given table lie in a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not
 * be returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a
 * <code>view_name</code> is
 * passed in as part of the input payload.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_box_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_box_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        y_column_name: request.y_column_name,
        min_y: request.min_y,
        max_y: request.max_y,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bybox", actual_request, callback);
};

/**
 * Calculates how many objects within the given table lie in a
 * rectangular box. The operation is synchronous, meaning that a response will
 * not
 * be returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a
 * <code>view_name</code> is
 * passed in as part of the input payload.
 *
 * @param {String} table_name  Name of the table on which the bounding box
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} x_column_name  Name of the column on which to perform the
 *                                bounding box query. Must be a valid numeric
 *                                column.
 * @param {Number} min_x  Lower bound for the column chosen by
 *                        <code>x_column_name</code>.  Must be less than or
 *                        equal to <code>max_x</code>.
 * @param {Number} max_x  Upper bound for <code>x_column_name</code>.  Must be
 *                        greater than or equal to <code>min_x</code>.
 * @param {String} y_column_name  Name of a column on which to perform the
 *                                bounding box query. Must be a valid numeric
 *                                column.
 * @param {Number} min_y  Lower bound for <code>y_column_name</code>. Must be
 *                        less than or equal to <code>max_y</code>.
 * @param {Number} max_y  Upper bound for <code>y_column_name</code>. Must be
 *                        greater than or equal to <code>min_y</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema is non-existent,
 *                          it will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_box = function(table_name, view_name, x_column_name, min_x, max_x, y_column_name, min_y, max_y, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_box(table_name, view_name, x_column_name, min_x, max_x, y_column_name, min_y, max_y, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        min_x: min_x,
        max_x: max_x,
        y_column_name: y_column_name,
        min_y: min_y,
        max_y: max_y,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bybox", actual_request, callback);
};

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a rectangular box. The operation is synchronous, meaning that a response
 * will
 * not be returned until all the objects are fully available. The response
 * payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a
 * <code>view_name</code> is
 * passed in as part of the input payload.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_box_geometry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_box_geometry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bybox/geometry", actual_request, callback);
};

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a rectangular box. The operation is synchronous, meaning that a response
 * will
 * not be returned until all the objects are fully available. The response
 * payload
 * provides the count of the resulting set. A new resultant set which satisfies
 * the
 * input NAI restriction specification is also created when a
 * <code>view_name</code> is
 * passed in as part of the input payload.
 *
 * @param {String} table_name  Name of the table on which the bounding box
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>. Must be
 *                             an existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} column_name  Name of the geospatial geometry column to be
 *                              filtered.
 * @param {Number} min_x  Lower bound for the x-coordinate of the rectangular
 *                        box.  Must be less than or equal to
 *                        <code>max_x</code>.
 * @param {Number} max_x  Upper bound for the x-coordinate of the rectangular
 *                        box.  Must be greater than or equal to
 *                        <code>min_x</code>.
 * @param {Number} min_y  Lower bound for the y-coordinate of the rectangular
 *                        box. Must be less than or equal to
 *                        <code>max_y</code>.
 * @param {Number} max_y  Upper bound for the y-coordinate of the rectangular
 *                        box. Must be greater than or equal to
 *                        <code>min_y</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema provided is
 *                          non-existent, it will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_box_geometry = function(table_name, view_name, column_name, min_x, max_x, min_y, max_y, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_box_geometry(table_name, view_name, column_name, min_x, max_x, min_y, max_y, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bybox/geometry", actual_request, callback);
};

/**
 * Applies a geometry filter against a geospatial geometry column in a
 * given table or view. The filtering geometry is provided by
 * <code>input_wkt</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_geometry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_geometry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        input_wkt: (request.input_wkt !== undefined && request.input_wkt !== null) ? request.input_wkt : "",
        operation: request.operation,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bygeometry", actual_request, callback);
};

/**
 * Applies a geometry filter against a geospatial geometry column in a
 * given table or view. The filtering geometry is provided by
 * <code>input_wkt</code>.
 *
 * @param {String} table_name  Name of the table on which the filter by
 *                             geometry will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table or view containing a
 *                             geospatial geometry column.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} column_name  Name of the column to be used in the filter.
 *                              Must be a geospatial geometry column.
 * @param {String} input_wkt  A geometry in WKT format that will be used to
 *                            filter the objects in <code>table_name</code>.
 * @param {String} operation  The geometric filtering operation to perform
 *                            Supported values:
 *                            <ul>
 *                                    <li> 'contains': Matches records that
 *                            contain the given WKT in <code>input_wkt</code>,
 *                            i.e. the given WKT is within the bounds of a
 *                            record's geometry.
 *                                    <li> 'crosses': Matches records that
 *                            cross the given WKT.
 *                                    <li> 'disjoint': Matches records that are
 *                            disjoint from the given WKT.
 *                                    <li> 'equals': Matches records that are
 *                            the same as the given WKT.
 *                                    <li> 'intersects': Matches records that
 *                            intersect the given WKT.
 *                                    <li> 'overlaps': Matches records that
 *                            overlap the given WKT.
 *                                    <li> 'touches': Matches records that
 *                            touch the given WKT.
 *                                    <li> 'within': Matches records that are
 *                            within the given WKT.
 *                            </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema provided is
 *                          non-existent, it will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_geometry = function(table_name, view_name, column_name, input_wkt, operation, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_geometry(table_name, view_name, column_name, input_wkt, operation, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        input_wkt: (input_wkt !== undefined && input_wkt !== null) ? input_wkt : "",
        operation: operation,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bygeometry", actual_request, callback);
};

/**
 * Calculates which records from a table have values in the given list
 * for the corresponding column. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input filter specification is also created if a
 * <code>view_name</code> is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by
 * list query with the column map
 * {"x":["10.1", "2.3"], "y":["0.0", "-31.5", "42.0"]} will return
 * the count of all data points whose x and y values match both in the
 * respective
 * x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x = 2.3 and y = -31.5", etc.
 * However, a record with "x = 10.1 and y = -31.5" or "x = 2.3 and y = 0.0"
 * would not be returned because the values in the given lists do not
 * correspond.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_list_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_list_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_values_map: request.column_values_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bylist", actual_request, callback);
};

/**
 * Calculates which records from a table have values in the given list
 * for the corresponding column. The operation is synchronous, meaning that a
 * response will not be returned until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set
 * (view) which satisfies the input filter specification is also created if a
 * <code>view_name</code> is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by
 * list query with the column map
 * {"x":["10.1", "2.3"], "y":["0.0", "-31.5", "42.0"]} will return
 * the count of all data points whose x and y values match both in the
 * respective
 * x- and y-lists, e.g., "x = 10.1 and y = 0.0", "x = 2.3 and y = -31.5", etc.
 * However, a record with "x = 10.1 and y = -31.5" or "x = 2.3 and y = 0.0"
 * would not be returned because the values in the given lists do not
 * correspond.
 *
 * @param {String} table_name  Name of the table to filter, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  This
 *                             may be the name of a table or a view (when
 *                             chaining queries).
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {Object} column_values_map  List of values for the corresponding
 *                                    column in the table
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema provided is
 *                          non-existent, it will be automatically created.
 *                                  <li> 'filter_mode': String indicating the
 *                          filter mode, either 'in_list' or 'not_in_list'.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'in_list': The filter will match all
 *                          items that are in the provided list(s).
 *                                  <li> 'not_in_list': The filter will match
 *                          all items that are not in the provided list(s).
 *                          </ul>
 *                          The default value is 'in_list'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_list = function(table_name, view_name, column_values_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_list(table_name, view_name, column_values_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_values_map: column_values_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bylist", actual_request, callback);
};

/**
 * Calculates which objects from a table lie within a circle with the
 * given radius and center point (i.e. circular NAI). The operation is
 * synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a <code>view_name</code> is passed in as
 * part of
 * the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on
 * either side of the circle (if the track goes beyond the circle) will be
 * included
 * in the result.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_radius_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_radius_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        x_center: request.x_center,
        y_column_name: request.y_column_name,
        y_center: request.y_center,
        radius: request.radius,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byradius", actual_request, callback);
};

/**
 * Calculates which objects from a table lie within a circle with the
 * given radius and center point (i.e. circular NAI). The operation is
 * synchronous,
 * meaning that a response will not be returned until all the objects are fully
 * available. The response payload provides the count of the resulting set. A
 * new
 * resultant set (view) which satisfies the input circular NAI restriction
 * specification is also created if a <code>view_name</code> is passed in as
 * part of
 * the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on
 * either side of the circle (if the track goes beyond the circle) will be
 * included
 * in the result.
 *
 * @param {String} table_name  Name of the table on which the filter by radius
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} x_column_name  Name of the column to be used for the
 *                                x-coordinate (the longitude) of the center.
 * @param {Number} x_center  Value of the longitude of the center. Must be
 *                           within [-180.0, 180.0].
 * @param {String} y_column_name  Name of the column to be used for the
 *                                y-coordinate-the latitude-of the center.
 * @param {Number} y_center  Value of the latitude of the center. Must be
 *                           within [-90.0, 90.0].
 * @param {Number} radius  The radius of the circle within which the search
 *                         will be performed. Must be a non-zero positive
 *                         value. It is in meters; so, for example, a value of
 *                         '42000' means 42 km.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema which is
 *                          to contain the newly created view. If the schema is
 *                          non-existent, it will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_radius = function(table_name, view_name, x_column_name, x_center, y_column_name, y_center, radius, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_radius(table_name, view_name, x_column_name, x_center, y_column_name, y_center, radius, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        x_center: x_center,
        y_column_name: y_column_name,
        y_center: y_center,
        radius: radius,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byradius", actual_request, callback);
};

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a circle with the given radius and center point (i.e. circular NAI). The
 * operation is synchronous, meaning that a response will not be returned until
 * all
 * the objects are fully available. The response payload provides the count of
 * the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI
 * restriction specification is also created if a <code>view_name</code> is
 * passed in
 * as part of the request.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_radius_geometry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_radius_geometry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        x_center: request.x_center,
        y_center: request.y_center,
        radius: request.radius,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byradius/geometry", actual_request, callback);
};

/**
 * Calculates which geospatial geometry objects from a table intersect
 * a circle with the given radius and center point (i.e. circular NAI). The
 * operation is synchronous, meaning that a response will not be returned until
 * all
 * the objects are fully available. The response payload provides the count of
 * the
 * resulting set. A new resultant set (view) which satisfies the input circular
 * NAI
 * restriction specification is also created if a <code>view_name</code> is
 * passed in
 * as part of the request.
 *
 * @param {String} table_name  Name of the table on which the filter by radius
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} column_name  Name of the geospatial geometry column to be
 *                              filtered.
 * @param {Number} x_center  Value of the longitude of the center. Must be
 *                           within [-180.0, 180.0].
 * @param {Number} y_center  Value of the latitude of the center. Must be
 *                           within [-90.0, 90.0].
 * @param {Number} radius  The radius of the circle within which the search
 *                         will be performed. Must be a non-zero positive
 *                         value. It is in meters; so, for example, a value of
 *                         '42000' means 42 km.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema provided is
 *                          non-existent, it will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_radius_geometry = function(table_name, view_name, column_name, x_center, y_center, radius, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_radius_geometry(table_name, view_name, column_name, x_center, y_center, radius, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        x_center: x_center,
        y_center: y_center,
        radius: radius,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byradius/geometry", actual_request, callback);
};

/**
 * Calculates which objects from a table have a column that is within
 * the given bounds. An object from the table identified by
 * <code>table_name</code> is
 * added to the view <code>view_name</code> if its column is within
 * [<code>lower_bound</code>, <code>upper_bound</code>] (inclusive). The
 * operation is
 * synchronous. The response provides a count of the number of objects which
 * passed
 * the bound filter.  Although this functionality can also be accomplished with
 * the
 * standard filter function, it is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        lower_bound: request.lower_bound,
        upper_bound: request.upper_bound,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byrange", actual_request, callback);
};

/**
 * Calculates which objects from a table have a column that is within
 * the given bounds. An object from the table identified by
 * <code>table_name</code> is
 * added to the view <code>view_name</code> if its column is within
 * [<code>lower_bound</code>, <code>upper_bound</code>] (inclusive). The
 * operation is
 * synchronous. The response provides a count of the number of objects which
 * passed
 * the bound filter.  Although this functionality can also be accomplished with
 * the
 * standard filter function, it is more efficient.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 *
 * @param {String} table_name  Name of the table on which the filter by range
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} column_name  Name of a column on which the operation would
 *                              be applied.
 * @param {Number} lower_bound  Value of the lower bound (inclusive).
 * @param {Number} upper_bound  Value of the upper bound (inclusive).
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema is non-existent,
 *                          it will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_range = function(table_name, view_name, column_name, lower_bound, upper_bound, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_range(table_name, view_name, column_name, lower_bound, upper_bound, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        lower_bound: lower_bound,
        upper_bound: upper_bound,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byrange", actual_request, callback);
};

/**
 * Filters objects matching all points of the given track (works only
 * on track type data).  It allows users to specify a particular track to find
 * all
 * other points in the table that fall within specified ranges (spatial and
 * temporal) of all points of the given track. Additionally, the user can
 * specify
 * another track to see if the two intersect (or go close to each other within
 * the
 * specified ranges). The user also has the flexibility of using different
 * metrics
 * for the spatial distance calculation: Euclidean (flat geometry) or Great
 * Circle
 * (spherical geometry to approximate the Earth's surface distances). The
 * filtered
 * points are stored in a newly created result set. The return value of the
 * function is the number of points in the resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        track_id: request.track_id,
        target_track_ids: request.target_track_ids,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byseries", actual_request, callback);
};

/**
 * Filters objects matching all points of the given track (works only
 * on track type data).  It allows users to specify a particular track to find
 * all
 * other points in the table that fall within specified ranges (spatial and
 * temporal) of all points of the given track. Additionally, the user can
 * specify
 * another track to see if the two intersect (or go close to each other within
 * the
 * specified ranges). The user also has the flexibility of using different
 * metrics
 * for the spatial distance calculation: Euclidean (flat geometry) or Great
 * Circle
 * (spherical geometry to approximate the Earth's surface distances). The
 * filtered
 * points are stored in a newly created result set. The return value of the
 * function is the number of points in the resultant set (view).
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all the objects are fully available.
 *
 * @param {String} table_name  Name of the table on which the filter by track
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>. Must be
 *                             a currently existing table with a <a
 *                             href="../../../geospatial/geo_objects/"
 *                             target="_top">track</a> present.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} track_id  The ID of the track which will act as the
 *                           filtering points. Must be an existing track within
 *                           the given table.
 * @param {String[]} target_track_ids  Up to one track ID to intersect with the
 *                                     "filter" track. If any provided, it must
 *                                     be an valid track ID within the given
 *                                     set.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema is non-existent,
 *                          it will be automatically created.
 *                                  <li> 'spatial_radius': A positive number
 *                          passed as a string representing the radius of the
 *                          search area centered around each track point's
 *                          geospatial coordinates. The value is interpreted in
 *                          meters. Required parameter.
 *                                  <li> 'time_radius': A positive number
 *                          passed as a string representing the maximum
 *                          allowable time difference between the timestamps of
 *                          a filtered object and the given track's points. The
 *                          value is interpreted in seconds. Required
 *                          parameter.
 *                                  <li> 'spatial_distance_metric': A string
 *                          representing the coordinate system to use for the
 *                          spatial search criteria. Acceptable values are
 *                          'euclidean' and 'great_circle'. Optional parameter;
 *                          default is 'euclidean'.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'euclidean'
 *                                  <li> 'great_circle'
 *                          </ul>
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_series = function(table_name, view_name, track_id, target_track_ids, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_series(table_name, view_name, track_id, target_track_ids, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        track_id: track_id,
        target_track_ids: target_track_ids,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byseries", actual_request, callback);
};

/**
 * Calculates which objects from a table or view match a string
 * expression for the given string columns. Setting
 * <code>case_sensitive</code> can modify case sensitivity in matching
 * for all modes except <code>search</code>. For
 * <code>search</code> mode details and limitations, see
 * <a href="../../../concepts/full_text_search/" target="_top">Full Text
 * Search</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_string_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_string_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        expression: request.expression,
        mode: request.mode,
        column_names: request.column_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bystring", actual_request, callback);
};

/**
 * Calculates which objects from a table or view match a string
 * expression for the given string columns. Setting
 * <code>case_sensitive</code> can modify case sensitivity in matching
 * for all modes except <code>search</code>. For
 * <code>search</code> mode details and limitations, see
 * <a href="../../../concepts/full_text_search/" target="_top">Full Text
 * Search</a>.
 *
 * @param {String} table_name  Name of the table on which the filter operation
 *                             will be performed, in [schema_name.]table_name
 *                             format, using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table or view.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} expression  The expression with which to filter the table.
 * @param {String} mode  The string filtering mode to apply. See below for
 *                       details.
 *                       Supported values:
 *                       <ul>
 *                               <li> 'search': Full text search query with
 *                       wildcards and boolean operators. Note that for this
 *                       mode, no column can be specified in
 *                       <code>column_names</code>; all string columns of the
 *                       table that have text search enabled will be searched.
 *                               <li> 'equals': Exact whole-string match
 *                       (accelerated).
 *                               <li> 'contains': Partial substring match (not
 *                       accelerated).  If the column is a string type
 *                       (non-charN) and the number of records is too large, it
 *                       will return 0.
 *                               <li> 'starts_with': Strings that start with
 *                       the given expression (not accelerated). If the column
 *                       is a string type (non-charN) and the number of records
 *                       is too large, it will return 0.
 *                               <li> 'regex': Full regular expression search
 *                       (not accelerated). If the column is a string type
 *                       (non-charN) and the number of records is too large, it
 *                       will return 0.
 *                       </ul>
 * @param {String[]} column_names  List of columns on which to apply the
 *                                 filter. Ignored for <code>search</code>
 *                                 mode.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema is non-existent,
 *                          it will be automatically created.
 *                                  <li> 'case_sensitive': If
 *                          <code>false</code> then string filtering will
 *                          ignore case. Does not apply to <code>search</code>
 *                          mode.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_string = function(table_name, view_name, expression, mode, column_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_string(table_name, view_name, expression, mode, column_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        expression: expression,
        mode: mode,
        column_names: column_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bystring", actual_request, callback);
};

/**
 * Filters objects in one table based on objects in another table. The
 * user must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which
 * the filter will be created); the column names need not be the same. If a
 * <code>view_name</code> is specified, then the filtered objects will then be
 * put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will
 * not be returned until all objects are fully available in the result view.
 * The
 * return value contains the count (i.e. the size) of the resulting view.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        source_table_name: request.source_table_name,
        source_table_column_name: request.source_table_column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bytable", actual_request, callback);
};

/**
 * Filters objects in one table based on objects in another table. The
 * user must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which
 * the filter will be created); the column names need not be the same. If a
 * <code>view_name</code> is specified, then the filtered objects will then be
 * put in a
 * newly created view. The operation is synchronous, meaning that a response
 * will
 * not be returned until all objects are fully available in the result view.
 * The
 * return value contains the count (i.e. the size) of the resulting view.
 *
 * @param {String} table_name  Name of the table whose data will be filtered,
 *                             in [schema_name.]table_name format, using
 *                             standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {String} column_name  Name of the column by whose value the data will
 *                              be filtered from the table designated by
 *                              <code>table_name</code>.
 * @param {String} source_table_name  Name of the table whose data will be
 *                                    compared against in the table called
 *                                    <code>table_name</code>, in
 *                                    [schema_name.]table_name format, using
 *                                    standard <a
 *                                    href="../../../concepts/tables/#table-name-resolution"
 *                                    target="_top">name resolution rules</a>.
 *                                    Must be an existing table.
 * @param {String} source_table_column_name  Name of the column in the
 *                                           <code>source_table_name</code>
 *                                           whose values will be used as the
 *                                           filter for table
 *                                           <code>table_name</code>. Must be a
 *                                           geospatial geometry column if in
 *                                           'spatial' mode; otherwise, Must
 *                                           match the type of the
 *                                           <code>column_name</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema is non-existent,
 *                          it will be automatically created.
 *                                  <li> 'filter_mode': String indicating the
 *                          filter mode, either <code>in_table</code> or
 *                          <code>not_in_table</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'in_table'
 *                                  <li> 'not_in_table'
 *                          </ul>
 *                          The default value is 'in_table'.
 *                                  <li> 'mode': Mode - should be either
 *                          <code>spatial</code> or <code>normal</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'normal'
 *                                  <li> 'spatial'
 *                          </ul>
 *                          The default value is 'normal'.
 *                                  <li> 'buffer': Buffer size, in meters. Only
 *                          relevant for <code>spatial</code> mode.  The
 *                          default value is '0'.
 *                                  <li> 'buffer_method': Method used to buffer
 *                          polygons.  Only relevant for <code>spatial</code>
 *                          mode.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'normal'
 *                                  <li> 'geos': Use geos 1 edge per corner
 *                          algorithm
 *                          </ul>
 *                          The default value is 'normal'.
 *                                  <li> 'max_partition_size': Maximum number
 *                          of points in a partition. Only relevant for
 *                          <code>spatial</code> mode.  The default value is
 *                          '0'.
 *                                  <li> 'max_partition_score': Maximum number
 *                          of points * edges in a partition. Only relevant for
 *                          <code>spatial</code> mode.  The default value is
 *                          '8000000'.
 *                                  <li> 'x_column_name': Name of column
 *                          containing x value of point being filtered in
 *                          <code>spatial</code> mode.  The default value is
 *                          'x'.
 *                                  <li> 'y_column_name': Name of column
 *                          containing y value of point being filtered in
 *                          <code>spatial</code> mode.  The default value is
 *                          'y'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_table = function(table_name, view_name, column_name, source_table_name, source_table_column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_table(table_name, view_name, column_name, source_table_name, source_table_column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        source_table_name: source_table_name,
        source_table_column_name: source_table_column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bytable", actual_request, callback);
};

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String
 * or a Double valued column and a desired value for the column on which the
 * filter
 * is performed. The operation is synchronous, meaning that a response will not
 * be
 * returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new result view which satisfies
 * the
 * input filter restriction specification is also created with a view name
 * passed
 * in as part of the input payload.  Although this functionality can also be
 * accomplished with the standard filter function, it is more efficient.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_value_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_value_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        is_string: request.is_string,
        value: (request.value !== undefined && request.value !== null) ? request.value : 0,
        value_str: (request.value_str !== undefined && request.value_str !== null) ? request.value_str : "",
        column_name: request.column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byvalue", actual_request, callback);
};

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String
 * or a Double valued column and a desired value for the column on which the
 * filter
 * is performed. The operation is synchronous, meaning that a response will not
 * be
 * returned until all the objects are fully available. The response payload
 * provides the count of the resulting set. A new result view which satisfies
 * the
 * input filter restriction specification is also created with a view name
 * passed
 * in as part of the input payload.  Although this functionality can also be
 * accomplished with the standard filter function, it is more efficient.
 *
 * @param {String} table_name  Name of an existing table on which to perform
 *                             the calculation, in [schema_name.]table_name
 *                             format, using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a> and
 *                            meeting <a
 *                            href="../../../concepts/tables/#table-naming-criteria"
 *                            target="_top">table naming criteria</a>.  Must
 *                            not be an already existing table or view.
 * @param {Boolean} is_string  Indicates whether the value being searched for
 *                             is string or numeric.
 * @param {Number} value  The value to search for.
 * @param {String} value_str  The string value to search for.
 * @param {String} column_name  Name of a column on which the filter by value
 *                              would be applied.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>view_name</code>. This is always
 *                          allowed even if the caller does not have permission
 *                          to create tables. The generated name is returned in
 *                          <code>qualified_view_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the view as part
 *                          of <code>view_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created view. If the schema is non-existent,
 *                          it will be automatically created.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_value = function(table_name, view_name, is_string, value, value_str, column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_value(table_name, view_name, is_string, value, value_str, column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        is_string: is_string,
        value: (value !== undefined && value !== null) ? value : 0,
        value_str: (value_str !== undefined && value_str !== null) ? value_str : "",
        column_name: column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byvalue", actual_request, callback);
};

/**
 * Get the status and result of asynchronously running job.  See the
 * {@linkcode GPUdb#create_job} for starting an asynchronous job.  Some
 * fields of the response are filled only after the submitted job has finished
 * execution.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_job_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_job_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        job_id: request.job_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/job", actual_request, callback);
};

/**
 * Get the status and result of asynchronously running job.  See the
 * {@linkcode GPUdb#create_job} for starting an asynchronous job.  Some
 * fields of the response are filled only after the submitted job has finished
 * execution.
 *
 * @param {Number} job_id  A unique identifier for the job whose status and
 *                         result is to be fetched.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'job_tag': Job tag returned in call to
 *                          create the job
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_job = function(job_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_job(job_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        job_id: job_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/job", actual_request, callback);
};

/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and
 * <code>limit</code> parameters.  Note that when paging through a table, if
 * the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : -9999,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    var self = this;
    this.submit_request("/get/records", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a given table, optionally filtered by an
 * expression and/or sorted by a column. This operation can be performed on
 * tables
 * and views. Records can be returned encoded as binary, json, or geojson.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and
 * <code>limit</code> parameters.  Note that when paging through a table, if
 * the table
 * (or the underlying table in case of a view) is updated (records are
 * inserted,
 * deleted or modified) the records retrieved may differ between calls based on
 * the
 * updates applied.
 *
 * @param {String} table_name  Name of the table or view from which the records
 *                             will be fetched, in [schema_name.]table_name
 *                             format, using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned, or
 *                        END_OF_SET (-9999) to indicate that the maximum
 *                        number of results allowed by the server should be
 *                        returned.  The number of records returned will never
 *                        exceed the server's own limit, defined by the
 *                        <a href="../../../config/#config-main-general"
 *                        target="_top">max_get_records_size</a> parameter in
 *                        the server configuration.
 *                        Use <code>has_more_records</code> to see if more
 *                        records exist in the result to be fetched, and
 *                        <code>offset</code> & <code>limit</code> to request
 *                        subsequent pages of results.
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'expression': Optional filter
 *                          expression to apply to the table.
 *                                  <li> 'fast_index_lookup': Indicates if
 *                          indexes should be used to perform the lookup for a
 *                          given expression if possible. Only applicable if
 *                          there is no sorting, the expression contains only
 *                          equivalence comparisons based on existing tables
 *                          indexes and the range of requested values is from
 *                          [0 to END_OF_SET].
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'sort_by': Optional column that the
 *                          data should be sorted by. Empty by default (i.e. no
 *                          sorting is applied).
 *                                  <li> 'sort_order': String indicating how
 *                          the returned values should be sorted - ascending or
 *                          descending. If sort_order is provided, sort_by has
 *                          to be provided.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'ascending'
 *                                  <li> 'descending'
 *                          </ul>
 *                          The default value is 'ascending'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records = function(table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records(table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : -9999,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    var self = this;
    this.submit_request("/get/records", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * For a given table, retrieves the values from the requested
 * column(s). Maps of column name to the array of values as well as the column
 * data
 * type are returned. This endpoint supports pagination with the
 * <code>offset</code>
 * and <code>limit</code> parameters.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@linkcode GPUdb#create_projection}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a
 * view) is modified (records are inserted, updated, or deleted) during a call
 * to
 * the endpoint, the records or values retrieved may differ between calls based
 * on
 * the type of the update, e.g., the contiguity across pages cannot be relied
 * upon.
 * <p>
 * If <code>table_name</code> is empty, selection is performed against a
 * single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_column_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_column_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : -9999,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    var self = this;
    this.submit_request("/get/records/bycolumn", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * For a given table, retrieves the values from the requested
 * column(s). Maps of column name to the array of values as well as the column
 * data
 * type are returned. This endpoint supports pagination with the
 * <code>offset</code>
 * and <code>limit</code> parameters.
 * <p>
 * <a href="../../../concepts/window/" target="_top">Window functions</a>,
 * which can perform
 * operations like moving averages, are available through this endpoint as well
 * as
 * {@linkcode GPUdb#create_projection}.
 * <p>
 * When using pagination, if the table (or the underlying table in the case of
 * a
 * view) is modified (records are inserted, updated, or deleted) during a call
 * to
 * the endpoint, the records or values retrieved may differ between calls based
 * on
 * the type of the update, e.g., the contiguity across pages cannot be relied
 * upon.
 * <p>
 * If <code>table_name</code> is empty, selection is performed against a
 * single-row
 * virtual table.  This can be useful in executing temporal
 * (<a href="../../../concepts/expressions/#date-time-functions"
 * target="_top">NOW()</a>), identity
 * (<a href="../../../concepts/expressions/#user-security-functions"
 * target="_top">USER()</a>), or
 * constant-based functions
 * (<a href="../../../concepts/expressions/#scalar-functions"
 * target="_top">GEODIST(-77.11, 38.88, -71.06, 42.36)</a>).
 * <p>
 * The response is returned as a dynamic schema. For details see:
 * <a href="../../../api/concepts/#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {String} table_name  Name of the table or view on which this
 *                             operation will be performed, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  An
 *                             empty table name retrieves one record from a
 *                             single-row virtual table, where columns
 *                             specified should be constants or constant
 *                             expressions.
 * @param {String[]} column_names  The list of column values to retrieve.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned, or
 *                        END_OF_SET (-9999) to indicate that the maximum
 *                        number of results allowed by the server should be
 *                        returned.  The number of records returned will never
 *                        exceed the server's own limit, defined by the
 *                        <a href="../../../config/#config-main-general"
 *                        target="_top">max_get_records_size</a> parameter in
 *                        the server configuration.
 *                        Use <code>has_more_records</code> to see if more
 *                        records exist in the result to be fetched, and
 *                        <code>offset</code> & <code>limit</code> to request
 *                        subsequent pages of results.
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'expression': Optional filter
 *                          expression to apply to the table.
 *                                  <li> 'sort_by': Optional column that the
 *                          data should be sorted by. Used in conjunction with
 *                          <code>sort_order</code>. The <code>order_by</code>
 *                          option can be used in lieu of <code>sort_by</code>
 *                          / <code>sort_order</code>.  The default value is
 *                          ''.
 *                                  <li> 'sort_order': String indicating how
 *                          the returned values should be sorted -
 *                          <code>ascending</code> or <code>descending</code>.
 *                          If <code>sort_order</code> is provided,
 *                          <code>sort_by</code> has to be provided.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'ascending'
 *                                  <li> 'descending'
 *                          </ul>
 *                          The default value is 'ascending'.
 *                                  <li> 'order_by': Comma-separated list of
 *                          the columns to be sorted by as well as the sort
 *                          direction, e.g., 'timestamp asc, x desc'.  The
 *                          default value is ''.
 *                                  <li> 'convert_wkts_to_wkbs': If
 *                          <code>true</code>, then WKT string columns will be
 *                          returned as WKB bytes.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_column = function(table_name, column_names, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_column(table_name, column_names, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : -9999,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    var self = this;
    this.submit_request("/get/records/bycolumn", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Retrieves the complete series/track records from the given
 * <code>world_table_name</code> based on the partial track information
 * contained in
 * the <code>table_name</code>.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and
 * <code>limit</code> parameters.
 * <p>
 * In contrast to {@linkcode GPUdb#get_records} this returns records grouped
 * by
 * series/track. So if <code>offset</code> is 0 and <code>limit</code> is 5
 * this operation
 * would return the first 5 series/tracks in <code>table_name</code>. Each
 * series/track
 * will be returned sorted by their TIMESTAMP column.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        world_table_name: request.world_table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 250,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    var self = this;
    this.submit_request("/get/records/byseries", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.list_records_json);
            delete data.list_records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves the complete series/track records from the given
 * <code>world_table_name</code> based on the partial track information
 * contained in
 * the <code>table_name</code>.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and
 * <code>limit</code> parameters.
 * <p>
 * In contrast to {@linkcode GPUdb#get_records} this returns records grouped
 * by
 * series/track. So if <code>offset</code> is 0 and <code>limit</code> is 5
 * this operation
 * would return the first 5 series/tracks in <code>table_name</code>. Each
 * series/track
 * will be returned sorted by their TIMESTAMP column.
 *
 * @param {String} table_name  Name of the table or view for which
 *                             series/tracks will be fetched, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String} world_table_name  Name of the table containing the complete
 *                                   series/track information to be returned
 *                                   for the tracks present in the
 *                                   <code>table_name</code>, in
 *                                   [schema_name.]table_name format, using
 *                                   standard <a
 *                                   href="../../../concepts/tables/#table-name-resolution"
 *                                   target="_top">name resolution rules</a>.
 *                                   Typically this is used when retrieving
 *                                   series/tracks from a view (which contains
 *                                   partial series/tracks) but the user wants
 *                                   to retrieve the entire original
 *                                   series/tracks. Can be blank.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         series/tracks to skip (useful for paging through the
 *                         results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        series/tracks to be returned. Or END_OF_SET (-9999)
 *                        to indicate that the max number of results should be
 *                        returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_series = function(table_name, world_table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_series(table_name, world_table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        world_table_name: world_table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : 250,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    var self = this;
    this.submit_request("/get/records/byseries", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.list_records_json);
            delete data.list_records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@linkcode GPUdb#delete_records}.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and
 * <code>limit</code> parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_from_collection_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_from_collection_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : -9999,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    var self = this;
    this.submit_request("/get/records/fromcollection", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a collection. The operation can optionally
 * return the record IDs which can be used in certain queries such as
 * {@linkcode GPUdb#delete_records}.
 * <p>
 * This operation supports paging through the data via the <code>offset</code>
 * and
 * <code>limit</code> parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from
 * join views using this operation.
 * (DEPRECATED)
 *
 * @param {String} table_name  Name of the collection or table from which
 *                             records are to be retrieved, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing collection or table.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned, or
 *                        END_OF_SET (-9999) to indicate that the maximum
 *                        number of results allowed by the server should be
 *                        returned.  The number of records returned will never
 *                        exceed the server's own limit, defined by the
 *                        <a href="../../../config/#config-main-general"
 *                        target="_top">max_get_records_size</a> parameter in
 *                        the server configuration.
 *                        Use <code>offset</code> & <code>limit</code> to
 *                        request subsequent pages of results.
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'return_record_ids': If
 *                          <code>true</code> then return the internal record
 *                          ID along with each returned record.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'expression': Optional filter
 *                          expression to apply to the table.  The default
 *                          value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_from_collection = function(table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_from_collection(table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : -9999,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    var self = this;
    this.submit_request("/get/records/fromcollection", actual_request, function(err, data) {
        if (err === null) {
            data.data = self.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.get_vectortile_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_vectortile_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        column_names: request.column_names,
        layers: request.layers,
        tile_x: request.tile_x,
        tile_y: request.tile_y,
        zoom: request.zoom,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/vectortile", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String[]} column_names
 * @param {Object} layers
 * @param {Number} tile_x
 * @param {Number} tile_y
 * @param {Number} zoom
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.get_vectortile = function(table_names, column_names, layers, tile_x, tile_y, zoom, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_vectortile(table_names, column_names, layers, tile_x, tile_y, zoom, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        column_names: column_names,
        layers: layers,
        tile_x: tile_x,
        tile_y: tile_y,
        zoom: zoom,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/vectortile", actual_request, callback);
};

/**
 * Grant user or role the specified permission on the specified object.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        principal: (request.principal !== undefined && request.principal !== null) ? request.principal : "",
        object: request.object,
        object_type: request.object_type,
        permission: request.permission,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/grant/permission", actual_request, callback);
};

/**
 * Grant user or role the specified permission on the specified object.
 *
 * @param {String} principal  Name of the user or role for which the permission
 *                            is being granted.  Must be an existing user or
 *                            role.
 * @param {String} object  Name of object permission is being granted to.  It
 *                         is recommended to use a fully-qualified name when
 *                         possible.
 * @param {String} object_type  The type of object being granted to
 *                              Supported values:
 *                              <ul>
 *                                      <li> 'credential': Credential
 *                                      <li> 'datasink': Data Sink
 *                                      <li> 'datasource': Data Source
 *                                      <li> 'directory': KIFS File Directory
 *                                      <li> 'graph': A Graph object
 *                                      <li> 'proc': UDF Procedure
 *                                      <li> 'schema': Schema
 *                                      <li> 'sql_proc': SQL Procedure
 *                                      <li> 'system': System-level access
 *                                      <li> 'table': Database Table
 *                                      <li> 'table_monitor': Table monitor
 *                              </ul>
 * @param {String} permission  Permission being granted.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'admin': Full read/write and
 *                             administrative access on the object.
 *                                     <li> 'connect': Connect access on the
 *                             given data source or data sink.
 *                                     <li> 'delete': Delete rows from tables.
 *                                     <li> 'execute': Ability to Execute the
 *                             Procedure object.
 *                                     <li> 'insert': Insert access to tables.
 *                                     <li> 'read': Ability to read, list and
 *                             use the object.
 *                                     <li> 'update': Update access to the
 *                             table.
 *                                     <li> 'user_admin': Access to administer
 *                             users and roles that do not have system_admin
 *                             permission.
 *                                     <li> 'write': Access to write, change
 *                             and delete objects.
 *                             </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'columns': Apply table security to
 *                          these columns, comma-separated.  The default value
 *                          is ''.
 *                                  <li> 'filter_expression': Optional filter
 *                          expression to apply to this grant.  Only rows that
 *                          match the filter will be affected.  The default
 *                          value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission = function(principal, object, object_type, permission, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission(principal, object, object_type, permission, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        principal: (principal !== undefined && principal !== null) ? principal : "",
        object: object,
        object_type: object_type,
        permission: permission,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/grant/permission", actual_request, callback);
};

/**
 * Grants a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_credential_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_credential_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        credential_name: request.credential_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/grant/permission/credential", actual_request, callback);
};

/**
 * Grants a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> to a user or role.
 *
 * @param {String} name  Name of the user or role to which the permission will
 *                       be granted. Must be an existing user or role.
 * @param {String} permission  Permission to grant to the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'credential_admin': Full read/write
 *                             and administrative access on the credential.
 *                                     <li> 'credential_read': Ability to read
 *                             and use the credential.
 *                             </ul>
 * @param {String} credential_name  Name of the credential on which the
 *                                  permission will be granted. Must be an
 *                                  existing credential, or an empty string to
 *                                  grant access on all credentials.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_credential = function(name, permission, credential_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_credential(name, permission, credential_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        credential_name: credential_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/grant/permission/credential", actual_request, callback);
};

/**
 * Grants a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_datasource_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_datasource_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        datasource_name: request.datasource_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/grant/permission/datasource", actual_request, callback);
};

/**
 * Grants a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission to a user or role.
 *
 * @param {String} name  Name of the user or role to which the permission will
 *                       be granted. Must be an existing user or role.
 * @param {String} permission  Permission to grant to the user or role
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'connect': Connect access on the
 *                             given data source
 *                             </ul>
 * @param {String} datasource_name  Name of the data source on which the
 *                                  permission will be granted. Must be an
 *                                  existing data source, or an empty string to
 *                                  grant permission on all data sources.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_datasource = function(name, permission, datasource_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_datasource(name, permission, datasource_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        datasource_name: datasource_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/grant/permission/datasource", actual_request, callback);
};

/**
 * Grants a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_directory_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_directory_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        directory_name: request.directory_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/grant/permission/directory", actual_request, callback);
};

/**
 * Grants a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission to a user or role.
 *
 * @param {String} name  Name of the user or role to which the permission will
 *                       be granted. Must be an existing user or role.
 * @param {String} permission  Permission to grant to the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'directory_read': For files in the
 *                             directory, access to list files, download files,
 *                             or use files in server side functions
 *                                     <li> 'directory_write': Access to upload
 *                             files to, or delete files from, the directory. A
 *                             user or role with write access automatically has
 *                             read access
 *                             </ul>
 * @param {String} directory_name  Name of the KiFS directory to which the
 *                                 permission grants access. An empty directory
 *                                 name grants access to all KiFS directories
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_directory = function(name, permission, directory_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_directory(name, permission, directory_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        directory_name: directory_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/grant/permission/directory", actual_request, callback);
};

/**
 * Grants a proc-level permission to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        proc_name: request.proc_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/grant/permission/proc", actual_request, callback);
};

/**
 * Grants a proc-level permission to a user or role.
 *
 * @param {String} name  Name of the user or role to which the permission will
 *                       be granted. Must be an existing user or role.
 * @param {String} permission  Permission to grant to the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'proc_execute': Execute access to
 *                             the proc.
 *                             </ul>
 * @param {String} proc_name  Name of the proc to which the permission grants
 *                            access. Must be an existing proc, or an empty
 *                            string to grant access to all procs.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_proc = function(name, permission, proc_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_proc(name, permission, proc_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        proc_name: proc_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/grant/permission/proc", actual_request, callback);
};

/**
 * Grants a system-level permission to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_system_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_system_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/grant/permission/system", actual_request, callback);
};

/**
 * Grants a system-level permission to a user or role.
 *
 * @param {String} name  Name of the user or role to which the permission will
 *                       be granted. Must be an existing user or role.
 * @param {String} permission  Permission to grant to the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'system_admin': Full access to all
 *                             data and system functions.
 *                                     <li> 'system_user_admin': Access to
 *                             administer users and roles that do not have
 *                             system_admin permission.
 *                                     <li> 'system_write': Read and write
 *                             access to all tables.
 *                                     <li> 'system_read': Read-only access to
 *                             all tables.
 *                             </ul>
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_system = function(name, permission, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_system(name, permission, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/grant/permission/system", actual_request, callback);
};

/**
 * Grants a table-level permission to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        table_name: request.table_name,
        filter_expression: (request.filter_expression !== undefined && request.filter_expression !== null) ? request.filter_expression : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/grant/permission/table", actual_request, callback);
};

/**
 * Grants a table-level permission to a user or role.
 *
 * @param {String} name  Name of the user or role to which the permission will
 *                       be granted. Must be an existing user or role.
 * @param {String} permission  Permission to grant to the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'table_admin': Full read/write and
 *                             administrative access to the table.
 *                                     <li> 'table_insert': Insert access to
 *                             the table.
 *                                     <li> 'table_update': Update access to
 *                             the table.
 *                                     <li> 'table_delete': Delete access to
 *                             the table.
 *                                     <li> 'table_read': Read access to the
 *                             table.
 *                             </ul>
 * @param {String} table_name  Name of the table to which the permission grants
 *                             access, in [schema_name.]table_name format,
 *                             using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table, view, or schema. If a
 *                             schema, the permission also applies to tables
 *                             and views in the schema.
 * @param {String} filter_expression  Optional filter expression to apply to
 *                                    this grant.  Only rows that match the
 *                                    filter will be affected.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'columns': Apply security to these
 *                          columns, comma-separated.  The default value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_permission_table = function(name, permission, table_name, filter_expression, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_permission_table(name, permission, table_name, filter_expression, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        table_name: table_name,
        filter_expression: (filter_expression !== undefined && filter_expression !== null) ? filter_expression : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/grant/permission/table", actual_request, callback);
};

/**
 * Grants membership in a role to a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        role: request.role,
        member: request.member,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/grant/role", actual_request, callback);
};

/**
 * Grants membership in a role to a user or role.
 *
 * @param {String} role  Name of the role in which membership will be granted.
 *                       Must be an existing role.
 * @param {String} member  Name of the user or role that will be granted
 *                         membership in <code>role</code>. Must be an existing
 *                         user or role.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.grant_role = function(role, member, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.grant_role(role, member, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        role: role,
        member: member,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/grant/role", actual_request, callback);
};

/**
 * Checks if the specified user has the specified permission on the specified
 * object.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_permission_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_permission_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        principal: (request.principal !== undefined && request.principal !== null) ? request.principal : "",
        object: request.object,
        object_type: request.object_type,
        permission: request.permission,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/permission", actual_request, callback);
};

/**
 * Checks if the specified user has the specified permission on the specified
 * object.
 *
 * @param {String} principal  Name of the user for which the permission is
 *                            being checked. Must be an existing user. If
 *                            blank, will use the current user.
 * @param {String} object  Name of object to check for the requested
 *                         permission.  It is recommended to use a
 *                         fully-qualified name when possible.
 * @param {String} object_type  The type of object being checked
 *                              Supported values:
 *                              <ul>
 *                                      <li> 'credential': Credential
 *                                      <li> 'datasink': Data Sink
 *                                      <li> 'datasource': Data Source
 *                                      <li> 'directory': KiFS File Directory
 *                                      <li> 'graph': A Graph object
 *                                      <li> 'proc': UDF Procedure
 *                                      <li> 'schema': Schema
 *                                      <li> 'sql_proc': SQL Procedure
 *                                      <li> 'system': System-level access
 *                                      <li> 'table': Database Table
 *                                      <li> 'table_monitor': Table monitor
 *                              </ul>
 * @param {String} permission  Permission to check for.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'admin': Full read/write and
 *                             administrative access on the object.
 *                                     <li> 'connect': Connect access on the
 *                             given data source or data sink.
 *                                     <li> 'delete': Delete rows from tables.
 *                                     <li> 'execute': Ability to Execute the
 *                             Procedure object.
 *                                     <li> 'insert': Insert access to tables.
 *                                     <li> 'read': Ability to read, list and
 *                             use the object.
 *                                     <li> 'update': Update access to the
 *                             table.
 *                                     <li> 'user_admin': Access to administer
 *                             users and roles that do not have system_admin
 *                             permission.
 *                                     <li> 'write': Access to write, change
 *                             and delete objects.
 *                             </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>false</code> will return an error if the
 *                          provided <code>object</code> does not exist or is
 *                          blank. If <code>true</code> then it will return
 *                          <code>false</code> for <code>has_permission</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_permission = function(principal, object, object_type, permission, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_permission(principal, object, object_type, permission, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        principal: (principal !== undefined && principal !== null) ? principal : "",
        object: object,
        object_type: object_type,
        permission: permission,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/permission", actual_request, callback);
};

/**
 * Checks the existence of a proc with the given name.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: request.proc_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/proc", actual_request, callback);
};

/**
 * Checks the existence of a proc with the given name.
 *
 * @param {String} proc_name  Name of the proc to check for existence.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_proc = function(proc_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_proc(proc_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: proc_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/proc", actual_request, callback);
};

/**
 * Checks if the specified user has the specified role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        principal: (request.principal !== undefined && request.principal !== null) ? request.principal : "",
        role: request.role,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/role", actual_request, callback);
};

/**
 * Checks if the specified user has the specified role.
 *
 * @param {String} principal  Name of the user for which role membersih is
 *                            being checked. Must be an existing user. If
 *                            blank, will use the current user.
 * @param {String} role  Name of role to check for membership.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>false</code> will return an error if the
 *                          provided <code>role</code> does not exist or is
 *                          blank. If <code>true</code> then it will return
 *                          <code>false</code> for <code>has_role</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'only_direct': If <code>false</code>
 *                          will search recursively if the
 *                          <code>principal</code> is a member of
 *                          <code>role</code>.  If <code>true</code> then
 *                          <code>principal</code> must directly be a member of
 *                          <code>role</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_role = function(principal, role, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_role(principal, role, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        principal: (principal !== undefined && principal !== null) ? principal : "",
        role: role,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/role", actual_request, callback);
};

/**
 * Checks for the existence of a schema with the given name.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_schema_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_schema_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: request.schema_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/schema", actual_request, callback);
};

/**
 * Checks for the existence of a schema with the given name.
 *
 * @param {String} schema_name  Name of the schema to check for existence, in
 *                              root, using standard <a
 *                              href="../../../concepts/tables/#table-name-resolution"
 *                              target="_top">name resolution rules</a>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_schema = function(schema_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_schema(schema_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: schema_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/schema", actual_request, callback);
};

/**
 * Checks for the existence of a table with the given name.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/table", actual_request, callback);
};

/**
 * Checks for the existence of a table with the given name.
 *
 * @param {String} table_name  Name of the table to check for existence, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_table = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_table(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/table", actual_request, callback);
};

/**
 * Check for the existence of a type.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/type", actual_request, callback);
};

/**
 * Check for the existence of a type.
 *
 * @param {String} type_id  Id of the type returned in response to
 *                          {@linkcode GPUdb#create_type} request.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_type = function(type_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_type(type_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/type", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.import_model_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.import_model_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_name: request.model_name,
        registry_name: request.registry_name,
        container: request.container,
        run_function: request.run_function,
        model_type: request.model_type,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/import/model", actual_request, callback);
};

/**
 *
 * @param {String} model_name
 * @param {String} registry_name
 * @param {String} container
 * @param {String} run_function
 * @param {String} model_type
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'memory_limit': The default value is
 *                          ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.import_model = function(model_name, registry_name, container, run_function, model_type, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.import_model(model_name, registry_name, container, run_function, model_type, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_name: model_name,
        registry_name: registry_name,
        container: container,
        run_function: run_function,
        model_type: model_type,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/import/model", actual_request, callback);
};

/**
 * Adds multiple records to the specified table. The operation is
 * synchronous, meaning that a response will not be returned until all the
 * records
 * are fully inserted and available. The response payload provides the counts
 * of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The <code>options</code> parameter can be used to customize this function's
 * behavior.
 * <p>
 * The <code>update_on_existing_pk</code> option specifies the record
 * collision policy for inserting into a table with a
 * <a href="../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, but is ignored if
 * no primary key exists.
 * <p>
 * The <code>return_record_ids</code> option indicates that the
 * database should return the unique identifiers of inserted records.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        list: (request.list !== undefined && request.list !== null) ? request.list : [],
        list_str: (request.data !== undefined && request.data !== null) ? GPUdb.encode(request.data) : [],
        list_encoding: (request.list_encoding !== undefined && request.list_encoding !== null) ? request.list_encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records", actual_request, callback);
};

/**
 * Adds multiple records to the specified table. The operation is
 * synchronous, meaning that a response will not be returned until all the
 * records
 * are fully inserted and available. The response payload provides the counts
 * of
 * the number of records actually inserted and/or updated, and can provide the
 * unique identifier of each added record.
 * <p>
 * The <code>options</code> parameter can be used to customize this function's
 * behavior.
 * <p>
 * The <code>update_on_existing_pk</code> option specifies the record
 * collision policy for inserting into a table with a
 * <a href="../../../concepts/tables/#primary-keys" target="_top">primary
 * key</a>, but is ignored if
 * no primary key exists.
 * <p>
 * The <code>return_record_ids</code> option indicates that the
 * database should return the unique identifiers of inserted records.
 *
 * @param {String} table_name  Name of table to which the records are to be
 *                             added, in [schema_name.]table_name format, using
 *                             standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table.
 * @param {Object[]} data  An array of JSON encoded data for the records to be
 *                         added. All records must be of the same type as that
 *                         of the table. Empty array if
 *                         <code>list_encoding</code> is <code>binary</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'update_on_existing_pk': Specifies the
 *                          record collision policy for inserting into a table
 *                          with a <a
 *                          href="../../../concepts/tables/#primary-keys"
 *                          target="_top">primary key</a>.  If set to
 *                          <code>true</code>, any existing table record with
 *                          primary key values that match those of a record
 *                          being inserted will be replaced by that new record.
 *                          If set to <code>false</code>, any existing table
 *                          record with primary key values that match those of
 *                          a record being inserted will remain unchanged and
 *                          the new record discarded.  If the specified table
 *                          does not have a primary key, then this option is
 *                          ignored.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'return_record_ids': If
 *                          <code>true</code> then return the internal record
 *                          id along for each inserted record.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'truncate_strings': If set to
 *                          <code>true</code>, any strings which are too long
 *                          for their target charN string columns will be
 *                          truncated to fit.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'return_individual_errors': If set to
 *                          <code>true</code>, success will always be returned,
 *                          and any errors found will be included in the info
 *                          map.  The "bad_record_indices" entry is a
 *                          comma-separated list of bad records (0-based).  And
 *                          if so, there will also be an "error_N" entry for
 *                          each record with an error, where N is the index
 *                          (0-based).
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'allow_partial_batch': If set to
 *                          <code>true</code>, all correct records will be
 *                          inserted and incorrect records will be rejected and
 *                          reported.  Otherwise, the entire batch will be
 *                          rejected if any records are incorrect.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'dry_run': If set to
 *                          <code>true</code>, no data will be saved and any
 *                          errors will be returned.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records = function(table_name, data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records(table_name, data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        list: [],
        list_str: GPUdb.encode(data),
        list_encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records", actual_request, callback);
};

/**
 * Reads from one or more files and inserts the data into a new or existing
 * table.
 * The source data can be located either in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>; on the cluster, accessible to the database; or
 * remotely, accessible via a pre-defined external <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>.
 * <p>

 * For delimited text files, there are two loading schemes: positional and
 * name-based. The name-based
 * loading scheme is enabled when the file has a header present and
 * <code>text_has_header</code> is set to
 * <code>true</code>. In this scheme, the source file(s) field names
 * must match the target table's column names exactly; however, the source file
 * can have more fields
 * than the target table has columns. If <code>error_handling</code> is set to
 * <code>permissive</code>, the source file can have fewer fields
 * than the target table has columns. If the name-based loading scheme is being
 * used, names matching
 * the file header's names may be provided to <code>columns_to_load</code>
 * instead of
 * numbers, but ranges are not supported.
 * <p>
 * Note: Due to data being loaded in parallel, there is no insertion order
 * guaranteed.  For tables with
 * primary keys, in the case of a primary key collision, this means it is
 * indeterminate which record
 * will be inserted first and remain, while the rest of the colliding key
 * records are discarded.
 * <p>
 * Returns once all files are processed.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_from_files_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_from_files_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        filepaths: request.filepaths,
        modify_columns: (request.modify_columns !== undefined && request.modify_columns !== null) ? request.modify_columns : {},
        create_table_options: (request.create_table_options !== undefined && request.create_table_options !== null) ? request.create_table_options : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records/fromfiles", actual_request, callback);
};

/**
 * Reads from one or more files and inserts the data into a new or existing
 * table.
 * The source data can be located either in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>; on the cluster, accessible to the database; or
 * remotely, accessible via a pre-defined external <a
 * href="../../../concepts/data_sources/" target="_top">data source</a>.
 * <p>

 * For delimited text files, there are two loading schemes: positional and
 * name-based. The name-based
 * loading scheme is enabled when the file has a header present and
 * <code>text_has_header</code> is set to
 * <code>true</code>. In this scheme, the source file(s) field names
 * must match the target table's column names exactly; however, the source file
 * can have more fields
 * than the target table has columns. If <code>error_handling</code> is set to
 * <code>permissive</code>, the source file can have fewer fields
 * than the target table has columns. If the name-based loading scheme is being
 * used, names matching
 * the file header's names may be provided to <code>columns_to_load</code>
 * instead of
 * numbers, but ranges are not supported.
 * <p>
 * Note: Due to data being loaded in parallel, there is no insertion order
 * guaranteed.  For tables with
 * primary keys, in the case of a primary key collision, this means it is
 * indeterminate which record
 * will be inserted first and remain, while the rest of the colliding key
 * records are discarded.
 * <p>
 * Returns once all files are processed.
 *
 * @param {String} table_name  Name of the table into which the data will be
 *                             inserted, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 *                             If the table does not exist, the table will be
 *                             created using either an existing
 *                             <code>type_id</code> or the type inferred from
 *                             the
 *                             file, and the new table name will have to meet
 *                             standard
 *                             <a
 *                             href="../../../concepts/tables/#table-naming-criteria"
 *                             target="_top">table naming criteria</a>.
 * @param {String[]} filepaths  A list of file paths from which data will be
 *                              sourced;
 *                              For paths in <a href="../../../tools/kifs/"
 *                              target="_top">KiFS</a>, use the uri prefix of
 *                              kifs:// followed by the path to
 *                              a file or directory. File matching by prefix is
 *                              supported, e.g. kifs://dir/file would match
 *                              dir/file_1
 *                              and dir/file_2. When prefix matching is used,
 *                              the path must start with a full, valid KiFS
 *                              directory name.
 *                              If an external data source is specified in
 *                              <code>datasource_name</code>, these file
 *                              paths must resolve to accessible files at that
 *                              data source location. Prefix matching is
 *                              supported.
 *                              If the data source is hdfs, prefixes must be
 *                              aligned with directories, i.e. partial file
 *                              names will
 *                              not match.
 *                              If no data source is specified, the files are
 *                              assumed to be local to the database and must
 *                              all be
 *                              accessible to the gpudb user, residing on the
 *                              path (or relative to the path) specified by the
 *                              external files directory in the Kinetica
 *                              <a
 *                              href="../../../config/#config-main-external-files"
 *                              target="_top">configuration file</a>. Wildcards
 *                              (*) can be used to
 *                              specify a group of files.  Prefix matching is
 *                              supported, the prefixes must be aligned with
 *                              directories.
 *                              If the first path ends in .tsv, the text
 *                              delimiter will be defaulted to a tab character.
 *                              If the first path ends in .psv, the text
 *                              delimiter will be defaulted to a pipe character
 *                              (|).
 * @param {Object} modify_columns  Not implemented yet
 * @param {Object} create_table_options  Options used when creating the target
 *                                       table.
 *                                       <ul>
 *                                               <li> 'type_id': ID of a
 *                                       currently registered <a
 *                                       href="../../../concepts/types/"
 *                                       target="_top">type</a>.  The default
 *                                       value is ''.
 *                                               <li> 'no_error_if_exists': If
 *                                       <code>true</code>, prevents an error
 *                                       from occurring if the table already
 *                                       exists and is of the given type.  If a
 *                                       table with the same ID but a different
 *                                       type exists, it is still an error.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'is_replicated': Affects
 *                                       the <a
 *                                       href="../../../concepts/tables/#distribution"
 *                                       target="_top">distribution scheme</a>
 *                                       for the table's data.  If
 *                                       <code>true</code> and the given type
 *                                       has no explicit <a
 *                                       href="../../../concepts/tables/#shard-key"
 *                                       target="_top">shard key</a> defined,
 *                                       the table will be <a
 *                                       href="../../../concepts/tables/#replication"
 *                                       target="_top">replicated</a>.  If
 *                                       <code>false</code>, the table will be
 *                                       <a
 *                                       href="../../../concepts/tables/#sharding"
 *                                       target="_top">sharded</a> according to
 *                                       the shard key specified in the given
 *                                       <code>type_id</code>, or <a
 *                                       href="../../../concepts/tables/#random-sharding"
 *                                       target="_top">randomly sharded</a>, if
 *                                       no shard key is specified.  Note that
 *                                       a type containing a shard key cannot
 *                                       be used to create a replicated table.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'foreign_keys':
 *                                       Semicolon-separated list of <a
 *                                       href="../../../concepts/tables/#foreign-keys"
 *                                       target="_top">foreign keys</a>, of the
 *                                       format '(source_column_name [, ...])
 *                                       references
 *                                       target_table_name(primary_key_column_name
 *                                       [, ...]) [as foreign_key_name]'.
 *                                               <li> 'foreign_shard_key':
 *                                       Foreign shard key of the format
 *                                       'source_column references
 *                                       shard_by_column from
 *                                       target_table(primary_key_column)'.
 *                                               <li> 'partition_type': <a
 *                                       href="../../../concepts/tables/#partitioning"
 *                                       target="_top">Partitioning</a> scheme
 *                                       to use.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'RANGE': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-range"
 *                                       target="_top">range partitioning</a>.
 *                                               <li> 'INTERVAL': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-interval"
 *                                       target="_top">interval
 *                                       partitioning</a>.
 *                                               <li> 'LIST': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitioning</a>.
 *                                               <li> 'HASH': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-hash"
 *                                       target="_top">hash partitioning</a>.
 *                                               <li> 'SERIES': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-series"
 *                                       target="_top">series partitioning</a>.
 *                                       </ul>
 *                                               <li> 'partition_keys':
 *                                       Comma-separated list of partition
 *                                       keys, which are the columns or column
 *                                       expressions by which records will be
 *                                       assigned to partitions defined by
 *                                       <code>partition_definitions</code>.
 *                                               <li> 'partition_definitions':
 *                                       Comma-separated list of partition
 *                                       definitions, whose format depends on
 *                                       the choice of
 *                                       <code>partition_type</code>.  See <a
 *                                       href="../../../concepts/tables/#partitioning-by-range"
 *                                       target="_top">range partitioning</a>,
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-interval"
 *                                       target="_top">interval
 *                                       partitioning</a>, <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitioning</a>,
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-hash"
 *                                       target="_top">hash partitioning</a>,
 *                                       or <a
 *                                       href="../../../concepts/tables/#partitioning-by-series"
 *                                       target="_top">series partitioning</a>
 *                                       for example formats.
 *                                               <li> 'is_automatic_partition':
 *                                       If <code>true</code>, a new partition
 *                                       will be created for values which don't
 *                                       fall into an existing partition.
 *                                       Currently only supported for <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitions</a>.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'ttl': Sets the <a
 *                                       href="../../../concepts/ttl/"
 *                                       target="_top">TTL</a> of the table
 *                                       specified in <code>table_name</code>.
 *                                               <li> 'chunk_size': Indicates
 *                                       the number of records per chunk to be
 *                                       used for this table.
 *                                               <li> 'is_result_table':
 *                                       Indicates whether the table is a <a
 *                                       href="../../../concepts/tables_memory_only/"
 *                                       target="_top">memory-only table</a>. A
 *                                       result table cannot contain columns
 *                                       with store_only or text_search <a
 *                                       href="../../../concepts/types/#data-handling"
 *                                       target="_top">data-handling</a> or
 *                                       that are <a
 *                                       href="../../../concepts/types/#primitive-types"
 *                                       target="_top">non-charN strings</a>,
 *                                       and it will not be retained if the
 *                                       server is restarted.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'strategy_definition':
 *                                       The <a
 *                                       href="../../../rm/concepts/#tier-strategies"
 *                                       target="_top">tier strategy</a> for
 *                                       the table and its columns.
 *                                       </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'bad_record_table_name': Optional name
 *                          of a table to which records that were rejected are
 *                          written.  The bad-record-table has the following
 *                          columns: line_number (long), line_rejected
 *                          (string), error_message (string). When error
 *                          handling is Abort, bad records table is not
 *                          populated.
 *                                  <li> 'bad_record_table_limit': A positive
 *                          integer indicating the maximum number of records
 *                          that can be  written to the bad-record-table.
 *                          Default value is 10000
 *                                  <li> 'bad_record_table_limit_per_input':
 *                          For subscriptions: A positive integer indicating
 *                          the maximum number of records that can be written
 *                          to the bad-record-table per file/payload. Default
 *                          value will be 'bad_record_table_limit' and total
 *                          size of the table per rank is limited to
 *                          'bad_record_table_limit'
 *                                  <li> 'batch_size': Internal tuning
 *                          parameter--number of records per batch when
 *                          inserting data.
 *                                  <li> 'column_formats': For each target
 *                          column specified, applies the column-property-bound
 *                          format to the source data
 *                          loaded into that column.  Each column format will
 *                          contain a mapping of one or more of its column
 *                          properties to an appropriate format for each
 *                          property.  Currently supported column properties
 *                          include date, time, & datetime. The parameter value
 *                          must be formatted as a JSON string of maps of
 *                          column names to maps of column properties to their
 *                          corresponding column formats, e.g.,
 *                          '{ "order_date" : { "date" : "%Y.%m.%d" },
 *                          "order_time" : { "time" : "%H:%M:%S" } }'.
 *                          See <code>default_column_formats</code> for valid
 *                          format syntax.
 *                                  <li> 'columns_to_load': Specifies a
 *                          comma-delimited list of columns from the source
 *                          data to
 *                          load.  If more than one file is being loaded, this
 *                          list applies to all files.
 *                          Column numbers can be specified discretely or as a
 *                          range.  For example, a value of '5,7,1..3' will
 *                          insert values from the fifth column in the source
 *                          data into the first column in the target table,
 *                          from the seventh column in the source data into the
 *                          second column in the target table, and from the
 *                          first through third columns in the source data into
 *                          the third through fifth columns in the target
 *                          table.
 *                          If the source data contains a header, column names
 *                          matching the file header names may be provided
 *                          instead of column numbers.  If the target table
 *                          doesn't exist, the table will be created with the
 *                          columns in this order.  If the target table does
 *                          exist with columns in a different order than the
 *                          source data, this list can be used to match the
 *                          order of the target table.  For example, a value of
 *                          'C, B, A' will create a three column table with
 *                          column C, followed by column B, followed by column
 *                          A; or will insert those fields in that order into a
 *                          table created with columns in that order.  If
 *                          the target table exists, the column names must
 *                          match the source data field names for a
 *                          name-mapping
 *                          to be successful.
 *                                  <li> 'columns_to_skip': Specifies a
 *                          comma-delimited list of columns from the source
 *                          data to
 *                          skip.  Mutually exclusive to columns_to_load.
 *                                  <li> 'datasource_name': Name of an existing
 *                          external data source from which data file(s)
 *                          specified in <code>filepaths</code> will be loaded
 *                                  <li> 'default_column_formats': Specifies
 *                          the default format to be applied to source data
 *                          loaded
 *                          into columns with the corresponding column
 *                          property.  Currently supported column properties
 *                          include
 *                          date, time, & datetime.  This default
 *                          column-property-bound format can be overridden by
 *                          specifying a
 *                          column property & format for a given target column
 *                          in <code>column_formats</code>. For
 *                          each specified annotation, the format will apply to
 *                          all columns with that annotation unless a custom
 *                          <code>column_formats</code> for that annotation is
 *                          specified.
 *                          The parameter value must be formatted as a JSON
 *                          string that is a map of column properties to their
 *                          respective column formats, e.g., '{ "date" :
 *                          "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column
 *                          formats are specified as a string of control
 *                          characters and plain text. The supported control
 *                          characters are 'Y', 'm', 'd', 'H', 'M', 'S', and
 *                          's', which follow the Linux 'strptime()'
 *                          specification, as well as 's', which specifies
 *                          seconds and fractional seconds (though the
 *                          fractional
 *                          component will be truncated past milliseconds).
 *                          Formats for the 'date' annotation must include the
 *                          'Y', 'm', and 'd' control characters. Formats for
 *                          the 'time' annotation must include the 'H', 'M',
 *                          and either 'S' or 's' (but not both) control
 *                          characters. Formats for the 'datetime' annotation
 *                          meet both the 'date' and 'time' control character
 *                          requirements. For example, '{"datetime" : "%m/%d/%Y
 *                          %H:%M:%S" }' would be used to interpret text
 *                          as "05/04/2000 12:12:11"
 *                                  <li> 'error_handling': Specifies how errors
 *                          should be handled upon insertion.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'permissive': Records with missing
 *                          columns are populated with nulls if possible;
 *                          otherwise, the malformed records are skipped.
 *                                  <li> 'ignore_bad_records': Malformed
 *                          records are skipped.
 *                                  <li> 'abort': Stops current insertion and
 *                          aborts entire operation when an error is
 *                          encountered.  Primary key collisions are considered
 *                          abortable errors in this mode.
 *                          </ul>
 *                          The default value is 'abort'.
 *                                  <li> 'file_type': Specifies the type of the
 *                          file(s) whose records will be inserted.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'avro': Avro file format
 *                                  <li> 'delimited_text': Delimited text file
 *                          format; e.g., CSV, TSV, PSV, etc.
 *                                  <li> 'json': Json file format
 *                                  <li> 'parquet': Apache Parquet file format
 *                                  <li> 'shapefile': ShapeFile file format
 *                          </ul>
 *                          The default value is 'delimited_text'.
 *                                  <li> 'ingestion_mode': Whether to do a full
 *                          load, dry run, or perform a type inference on the
 *                          source data.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'full': Run a type inference on the
 *                          source data (if needed) and ingest
 *                                  <li> 'dry_run': Does not load data, but
 *                          walks through the source data and determines the
 *                          number of valid records, taking into account the
 *                          current mode of <code>error_handling</code>.
 *                                  <li> 'type_inference_only': Infer the type
 *                          of the source data and return, without ingesting
 *                          any data.  The inferred type is returned in the
 *                          response.
 *                          </ul>
 *                          The default value is 'full'.
 *                                  <li> 'kafka_group_id': The group id to be
 *                          used consuming data from a kakfa topic (valid only
 *                          for kafka datasource subscriptions).
 *                                  <li> 'loading_mode': Scheme for
 *                          distributing the extraction and loading of data
 *                          from the source data file(s). This option applies
 *                          only when loading files that are local to the
 *                          database
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'head': The head node loads all data.
 *                          All files must be available to the head node.
 *                                  <li> 'distributed_shared': The head node
 *                          coordinates loading data by worker
 *                          processes across all nodes from shared files
 *                          available to all workers.
 *                          NOTE:
 *                          Instead of existing on a shared source, the files
 *                          can be duplicated on a source local to each host
 *                          to improve performance, though the files must
 *                          appear as the same data set from the perspective of
 *                          all hosts performing the load.
 *                                  <li> 'distributed_local': A single worker
 *                          process on each node loads all files
 *                          that are available to it. This option works best
 *                          when each worker loads files from its own file
 *                          system, to maximize performance. In order to avoid
 *                          data duplication, either each worker performing
 *                          the load needs to have visibility to a set of files
 *                          unique to it (no file is visible to more than
 *                          one node) or the target table needs to have a
 *                          primary key (which will allow the worker to
 *                          automatically deduplicate data).
 *                          NOTE:
 *                          If the target table doesn't exist, the table
 *                          structure will be determined by the head node. If
 *                          the
 *                          head node has no files local to it, it will be
 *                          unable to determine the structure and the request
 *                          will fail.
 *                          If the head node is configured to have no worker
 *                          processes, no data strictly accessible to the head
 *                          node will be loaded.
 *                          </ul>
 *                          The default value is 'head'.
 *                                  <li> 'local_time_offset': For Avro local
 *                          timestamp columns
 *                                  <li> 'num_tasks_per_rank': Optional: number
 *                          of tasks for reading file per rank. Default will be
 *                          external_file_reader_num_tasks
 *                                  <li> 'poll_interval': If <code>true</code>,
 *                          the number of seconds between attempts to load
 *                          external files into the table.  If zero, polling
 *                          will be continuous as long as data is found.  If no
 *                          data is found, the interval will steadily increase
 *                          to a maximum of 60 seconds.
 *                                  <li> 'primary_keys': Optional: comma
 *                          separated list of column names, to set as primary
 *                          keys, when not specified in the type.  The default
 *                          value is ''.
 *                                  <li> 'shard_keys': Optional: comma
 *                          separated list of column names, to set as primary
 *                          keys, when not specified in the type.  The default
 *                          value is ''.
 *                                  <li> 'skip_lines': Skip number of lines
 *                          from begining of file.
 *                                  <li> 'subscribe': Continuously poll the
 *                          data source to check for new data and load it into
 *                          the table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'table_insert_mode': Optional:
 *                          table_insert_mode. When inserting records from
 *                          multiple files: if table_per_file then insert from
 *                          each file into a new table. Currently supported
 *                          only for shapefiles.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'single'
 *                                  <li> 'table_per_file'
 *                          </ul>
 *                          The default value is 'single'.
 *                                  <li> 'text_comment_string': Specifies the
 *                          character string that should be interpreted as a
 *                          comment line
 *                          prefix in the source data.  All lines in the data
 *                          starting with the provided string are ignored.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '#'.
 *                                  <li> 'text_delimiter': Specifies the
 *                          character delimiting field values in the source
 *                          data
 *                          and field names in the header (if present).
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          ','.
 *                                  <li> 'text_escape_character': Specifies the
 *                          character that is used to escape other characters
 *                          in
 *                          the source data.
 *                          An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by
 *                          an escape character will be interpreted as the
 *                          ASCII bell, backspace, form feed, line feed,
 *                          carriage return, horizontal tab, & vertical tab,
 *                          respectively.  For example, the escape character
 *                          followed by an 'n' will be interpreted as a newline
 *                          within a field value.
 *                          The escape character can also be used to escape the
 *                          quoting character, and will be treated as an
 *                          escape character whether it is within a quoted
 *                          field value or not.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.
 *                                  <li> 'text_has_header': Indicates whether
 *                          the source data contains a header row.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'text_header_property_delimiter':
 *                          Specifies the delimiter for
 *                          <a
 *                          href="../../../concepts/types/#column-properties"
 *                          target="_top">column properties</a> in the header
 *                          row (if
 *                          present).  Cannot be set to same value as
 *                          <code>text_delimiter</code>.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '|'.
 *                                  <li> 'text_null_string': Specifies the
 *                          character string that should be interpreted as a
 *                          null
 *                          value in the source data.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '\\N'.
 *                                  <li> 'text_quote_character': Specifies the
 *                          character that should be interpreted as a field
 *                          value
 *                          quoting character in the source data.  The
 *                          character must appear at beginning and end of field
 *                          value
 *                          to take effect.  Delimiters within quoted fields
 *                          are treated as literals and not delimiters.  Within
 *                          a quoted field, two consecutive quote characters
 *                          will be interpreted as a single literal quote
 *                          character, effectively escaping it.  To not have a
 *                          quote character, specify an empty string.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '"'.
 *                                  <li> 'text_search_columns': Add
 *                          'text_search' property to internally inferenced
 *                          string columns. Comma seperated list of column
 *                          names or '*' for all columns. To add text_search
 *                          property only to string columns of minimum size,
 *                          set also the option 'text_search_min_column_length'
 *                                  <li> 'text_search_min_column_length': Set
 *                          minimum column size. Used only when
 *                          'text_search_columns' has a value.
 *                                  <li> 'truncate_table': If set to
 *                          <code>true</code>, truncates the table specified by
 *                          <code>table_name</code> prior to loading the
 *                          file(s).
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'type_inference_mode': optimize type
 *                          inference for:
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'accuracy': scans all data to get
 *                          exactly-typed & sized columns for all data present
 *                                  <li> 'speed': picks the widest possible
 *                          column types so that 'all' values will fit with
 *                          minimum data scanned
 *                          </ul>
 *                          The default value is 'speed'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_from_files = function(table_name, filepaths, modify_columns, create_table_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_from_files(table_name, filepaths, modify_columns, create_table_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        filepaths: filepaths,
        modify_columns: (modify_columns !== undefined && modify_columns !== null) ? modify_columns : {},
        create_table_options: (create_table_options !== undefined && create_table_options !== null) ? create_table_options : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records/fromfiles", actual_request, callback);
};

/**
 * Reads from the given text-based or binary payload and inserts the
 * data into a new or existing table.  The table will be created if it doesn't
 * already exist.
 * <p>
 * Returns once all records are processed.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_from_payload_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_from_payload_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        data_text: request.data_text,
        data_bytes: request.data_bytes,
        modify_columns: (request.modify_columns !== undefined && request.modify_columns !== null) ? request.modify_columns : {},
        create_table_options: (request.create_table_options !== undefined && request.create_table_options !== null) ? request.create_table_options : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records/frompayload", actual_request, callback);
};

/**
 * Reads from the given text-based or binary payload and inserts the
 * data into a new or existing table.  The table will be created if it doesn't
 * already exist.
 * <p>
 * Returns once all records are processed.
 *
 * @param {String} table_name  Name of the table into which the data will be
 *                             inserted, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 *                             If the table does not exist, the table will be
 *                             created using either an existing
 *                             <code>type_id</code> or the type inferred from
 *                             the
 *                             payload, and the new table name will have to
 *                             meet standard
 *                             <a
 *                             href="../../../concepts/tables/#table-naming-criteria"
 *                             target="_top">table naming criteria</a>.
 * @param {String} data_text  Records formatted as delimited text
 * @param {String} data_bytes  Records formatted as binary data
 * @param {Object} modify_columns  Not implemented yet
 * @param {Object} create_table_options  Options used when creating the target
 *                                       table. Includes type to use. The other
 *                                       options match those in
 *                                       {@linkcode GPUdb#create_table}
 *                                       <ul>
 *                                               <li> 'type_id': ID of a
 *                                       currently registered <a
 *                                       href="../../../concepts/types/"
 *                                       target="_top">type</a>.  The default
 *                                       value is ''.
 *                                               <li> 'no_error_if_exists': If
 *                                       <code>true</code>, prevents an error
 *                                       from occurring if the table already
 *                                       exists and is of the given type.  If a
 *                                       table with the same ID but a different
 *                                       type exists, it is still an error.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'is_replicated': Affects
 *                                       the <a
 *                                       href="../../../concepts/tables/#distribution"
 *                                       target="_top">distribution scheme</a>
 *                                       for the table's data.  If
 *                                       <code>true</code> and the given type
 *                                       has no explicit <a
 *                                       href="../../../concepts/tables/#shard-key"
 *                                       target="_top">shard key</a> defined,
 *                                       the table will be <a
 *                                       href="../../../concepts/tables/#replication"
 *                                       target="_top">replicated</a>.  If
 *                                       <code>false</code>, the table will be
 *                                       <a
 *                                       href="../../../concepts/tables/#sharding"
 *                                       target="_top">sharded</a> according to
 *                                       the shard key specified in the given
 *                                       <code>type_id</code>, or <a
 *                                       href="../../../concepts/tables/#random-sharding"
 *                                       target="_top">randomly sharded</a>, if
 *                                       no shard key is specified.  Note that
 *                                       a type containing a shard key cannot
 *                                       be used to create a replicated table.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'foreign_keys':
 *                                       Semicolon-separated list of <a
 *                                       href="../../../concepts/tables/#foreign-keys"
 *                                       target="_top">foreign keys</a>, of the
 *                                       format '(source_column_name [, ...])
 *                                       references
 *                                       target_table_name(primary_key_column_name
 *                                       [, ...]) [as foreign_key_name]'.
 *                                               <li> 'foreign_shard_key':
 *                                       Foreign shard key of the format
 *                                       'source_column references
 *                                       shard_by_column from
 *                                       target_table(primary_key_column)'.
 *                                               <li> 'partition_type': <a
 *                                       href="../../../concepts/tables/#partitioning"
 *                                       target="_top">Partitioning</a> scheme
 *                                       to use.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'RANGE': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-range"
 *                                       target="_top">range partitioning</a>.
 *                                               <li> 'INTERVAL': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-interval"
 *                                       target="_top">interval
 *                                       partitioning</a>.
 *                                               <li> 'LIST': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitioning</a>.
 *                                               <li> 'HASH': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-hash"
 *                                       target="_top">hash partitioning</a>.
 *                                               <li> 'SERIES': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-series"
 *                                       target="_top">series partitioning</a>.
 *                                       </ul>
 *                                               <li> 'partition_keys':
 *                                       Comma-separated list of partition
 *                                       keys, which are the columns or column
 *                                       expressions by which records will be
 *                                       assigned to partitions defined by
 *                                       <code>partition_definitions</code>.
 *                                               <li> 'partition_definitions':
 *                                       Comma-separated list of partition
 *                                       definitions, whose format depends on
 *                                       the choice of
 *                                       <code>partition_type</code>.  See <a
 *                                       href="../../../concepts/tables/#partitioning-by-range"
 *                                       target="_top">range partitioning</a>,
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-interval"
 *                                       target="_top">interval
 *                                       partitioning</a>, <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitioning</a>,
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-hash"
 *                                       target="_top">hash partitioning</a>,
 *                                       or <a
 *                                       href="../../../concepts/tables/#partitioning-by-series"
 *                                       target="_top">series partitioning</a>
 *                                       for example formats.
 *                                               <li> 'is_automatic_partition':
 *                                       If <code>true</code>, a new partition
 *                                       will be created for values which don't
 *                                       fall into an existing partition.
 *                                       Currently only supported for <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitions</a>.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'ttl': Sets the <a
 *                                       href="../../../concepts/ttl/"
 *                                       target="_top">TTL</a> of the table
 *                                       specified in <code>table_name</code>.
 *                                               <li> 'chunk_size': Indicates
 *                                       the number of records per chunk to be
 *                                       used for this table.
 *                                               <li> 'is_result_table':
 *                                       Indicates whether the table is a <a
 *                                       href="../../../concepts/tables_memory_only/"
 *                                       target="_top">memory-only table</a>. A
 *                                       result table cannot contain columns
 *                                       with store_only or text_search <a
 *                                       href="../../../concepts/types/#data-handling"
 *                                       target="_top">data-handling</a> or
 *                                       that are <a
 *                                       href="../../../concepts/types/#primitive-types"
 *                                       target="_top">non-charN strings</a>,
 *                                       and it will not be retained if the
 *                                       server is restarted.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'strategy_definition':
 *                                       The <a
 *                                       href="../../../rm/concepts/#tier-strategies"
 *                                       target="_top">tier strategy</a> for
 *                                       the table and its columns.
 *                                       </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'bad_record_table_name': Optional name
 *                          of a table to which records that were rejected are
 *                          written.  The bad-record-table has the following
 *                          columns: line_number (long), line_rejected
 *                          (string), error_message (string).
 *                                  <li> 'bad_record_table_limit': A positive
 *                          integer indicating the maximum number of records
 *                          that can be  written to the bad-record-table.
 *                          Default value is 10000
 *                                  <li> 'bad_record_table_limit_per_input':
 *                          For subscriptions: A positive integer indicating
 *                          the maximum number of records that can be written
 *                          to the bad-record-table per file/payload. Default
 *                          value will be 'bad_record_table_limit' and total
 *                          size of the table per rank is limited to
 *                          'bad_record_table_limit'
 *                                  <li> 'batch_size': Internal tuning
 *                          parameter--number of records per batch when
 *                          inserting data.
 *                                  <li> 'column_formats': For each target
 *                          column specified, applies the column-property-bound
 *                          format to the source data
 *                          loaded into that column.  Each column format will
 *                          contain a mapping of one or more of its column
 *                          properties to an appropriate format for each
 *                          property.  Currently supported column properties
 *                          include date, time, & datetime. The parameter value
 *                          must be formatted as a JSON string of maps of
 *                          column names to maps of column properties to their
 *                          corresponding column formats, e.g.,
 *                          '{ "order_date" : { "date" : "%Y.%m.%d" },
 *                          "order_time" : { "time" : "%H:%M:%S" } }'.
 *                          See <code>default_column_formats</code> for valid
 *                          format syntax.
 *                                  <li> 'columns_to_load': Specifies a
 *                          comma-delimited list of columns from the source
 *                          data to
 *                          load.  If more than one file is being loaded, this
 *                          list applies to all files.
 *                          Column numbers can be specified discretely or as a
 *                          range.  For example, a value of '5,7,1..3' will
 *                          insert values from the fifth column in the source
 *                          data into the first column in the target table,
 *                          from the seventh column in the source data into the
 *                          second column in the target table, and from the
 *                          first through third columns in the source data into
 *                          the third through fifth columns in the target
 *                          table.
 *                          If the source data contains a header, column names
 *                          matching the file header names may be provided
 *                          instead of column numbers.  If the target table
 *                          doesn't exist, the table will be created with the
 *                          columns in this order.  If the target table does
 *                          exist with columns in a different order than the
 *                          source data, this list can be used to match the
 *                          order of the target table.  For example, a value of
 *                          'C, B, A' will create a three column table with
 *                          column C, followed by column B, followed by column
 *                          A; or will insert those fields in that order into a
 *                          table created with columns in that order.  If
 *                          the target table exists, the column names must
 *                          match the source data field names for a
 *                          name-mapping
 *                          to be successful.
 *                                  <li> 'columns_to_skip': Specifies a
 *                          comma-delimited list of columns from the source
 *                          data to
 *                          skip.  Mutually exclusive to columns_to_load.
 *                                  <li> 'default_column_formats': Specifies
 *                          the default format to be applied to source data
 *                          loaded
 *                          into columns with the corresponding column
 *                          property.  Currently supported column properties
 *                          include
 *                          date, time, & datetime.  This default
 *                          column-property-bound format can be overridden by
 *                          specifying a
 *                          column property & format for a given target column
 *                          in <code>column_formats</code>. For
 *                          each specified annotation, the format will apply to
 *                          all columns with that annotation unless a custom
 *                          <code>column_formats</code> for that annotation is
 *                          specified.
 *                          The parameter value must be formatted as a JSON
 *                          string that is a map of column properties to their
 *                          respective column formats, e.g., '{ "date" :
 *                          "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column
 *                          formats are specified as a string of control
 *                          characters and plain text. The supported control
 *                          characters are 'Y', 'm', 'd', 'H', 'M', 'S', and
 *                          's', which follow the Linux 'strptime()'
 *                          specification, as well as 's', which specifies
 *                          seconds and fractional seconds (though the
 *                          fractional
 *                          component will be truncated past milliseconds).
 *                          Formats for the 'date' annotation must include the
 *                          'Y', 'm', and 'd' control characters. Formats for
 *                          the 'time' annotation must include the 'H', 'M',
 *                          and either 'S' or 's' (but not both) control
 *                          characters. Formats for the 'datetime' annotation
 *                          meet both the 'date' and 'time' control character
 *                          requirements. For example, '{"datetime" : "%m/%d/%Y
 *                          %H:%M:%S" }' would be used to interpret text
 *                          as "05/04/2000 12:12:11"
 *                                  <li> 'error_handling': Specifies how errors
 *                          should be handled upon insertion.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'permissive': Records with missing
 *                          columns are populated with nulls if possible;
 *                          otherwise, the malformed records are skipped.
 *                                  <li> 'ignore_bad_records': Malformed
 *                          records are skipped.
 *                                  <li> 'abort': Stops current insertion and
 *                          aborts entire operation when an error is
 *                          encountered.  Primary key collisions are considered
 *                          abortable errors in this mode.
 *                          </ul>
 *                          The default value is 'abort'.
 *                                  <li> 'file_type': Specifies the type of the
 *                          file(s) whose records will be inserted.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'avro': Avro file format
 *                                  <li> 'delimited_text': Delimited text file
 *                          format; e.g., CSV, TSV, PSV, etc.
 *                                  <li> 'json': Json file format
 *                                  <li> 'parquet': Apache Parquet file format
 *                                  <li> 'shapefile': ShapeFile file format
 *                          </ul>
 *                          The default value is 'delimited_text'.
 *                                  <li> 'ingestion_mode': Whether to do a full
 *                          load, dry run, or perform a type inference on the
 *                          source data.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'full': Run a type inference on the
 *                          source data (if needed) and ingest
 *                                  <li> 'dry_run': Does not load data, but
 *                          walks through the source data and determines the
 *                          number of valid records, taking into account the
 *                          current mode of <code>error_handling</code>.
 *                                  <li> 'type_inference_only': Infer the type
 *                          of the source data and return, without ingesting
 *                          any data.  The inferred type is returned in the
 *                          response.
 *                          </ul>
 *                          The default value is 'full'.
 *                                  <li> 'loading_mode': Scheme for
 *                          distributing the extraction and loading of data
 *                          from the source data file(s). This option applies
 *                          only when loading files that are local to the
 *                          database
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'head': The head node loads all data.
 *                          All files must be available to the head node.
 *                                  <li> 'distributed_shared': The head node
 *                          coordinates loading data by worker
 *                          processes across all nodes from shared files
 *                          available to all workers.
 *                          NOTE:
 *                          Instead of existing on a shared source, the files
 *                          can be duplicated on a source local to each host
 *                          to improve performance, though the files must
 *                          appear as the same data set from the perspective of
 *                          all hosts performing the load.
 *                                  <li> 'distributed_local': A single worker
 *                          process on each node loads all files
 *                          that are available to it. This option works best
 *                          when each worker loads files from its own file
 *                          system, to maximize performance. In order to avoid
 *                          data duplication, either each worker performing
 *                          the load needs to have visibility to a set of files
 *                          unique to it (no file is visible to more than
 *                          one node) or the target table needs to have a
 *                          primary key (which will allow the worker to
 *                          automatically deduplicate data).
 *                          NOTE:
 *                          If the target table doesn't exist, the table
 *                          structure will be determined by the head node. If
 *                          the
 *                          head node has no files local to it, it will be
 *                          unable to determine the structure and the request
 *                          will fail.
 *                          If the head node is configured to have no worker
 *                          processes, no data strictly accessible to the head
 *                          node will be loaded.
 *                          </ul>
 *                          The default value is 'head'.
 *                                  <li> 'local_time_offset': For Avro local
 *                          timestamp columns
 *                                  <li> 'num_tasks_per_rank': Optional: number
 *                          of tasks for reading file per rank. Default will be
 *                          external_file_reader_num_tasks
 *                                  <li> 'poll_interval': If <code>true</code>,
 *                          the number of seconds between attempts to load
 *                          external files into the table.  If zero, polling
 *                          will be continuous as long as data is found.  If no
 *                          data is found, the interval will steadily increase
 *                          to a maximum of 60 seconds.
 *                                  <li> 'primary_keys': Optional: comma
 *                          separated list of column names, to set as primary
 *                          keys, when not specified in the type.  The default
 *                          value is ''.
 *                                  <li> 'shard_keys': Optional: comma
 *                          separated list of column names, to set as primary
 *                          keys, when not specified in the type.  The default
 *                          value is ''.
 *                                  <li> 'skip_lines': Skip number of lines
 *                          from begining of file.
 *                                  <li> 'subscribe': Continuously poll the
 *                          data source to check for new data and load it into
 *                          the table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'table_insert_mode': Optional:
 *                          table_insert_mode. When inserting records from
 *                          multiple files: if table_per_file then insert from
 *                          each file into a new table. Currently supported
 *                          only for shapefiles.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'single'
 *                                  <li> 'table_per_file'
 *                          </ul>
 *                          The default value is 'single'.
 *                                  <li> 'text_comment_string': Specifies the
 *                          character string that should be interpreted as a
 *                          comment line
 *                          prefix in the source data.  All lines in the data
 *                          starting with the provided string are ignored.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '#'.
 *                                  <li> 'text_delimiter': Specifies the
 *                          character delimiting field values in the source
 *                          data
 *                          and field names in the header (if present).
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          ','.
 *                                  <li> 'text_escape_character': Specifies the
 *                          character that is used to escape other characters
 *                          in
 *                          the source data.
 *                          An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by
 *                          an escape character will be interpreted as the
 *                          ASCII bell, backspace, form feed, line feed,
 *                          carriage return, horizontal tab, & vertical tab,
 *                          respectively.  For example, the escape character
 *                          followed by an 'n' will be interpreted as a newline
 *                          within a field value.
 *                          The escape character can also be used to escape the
 *                          quoting character, and will be treated as an
 *                          escape character whether it is within a quoted
 *                          field value or not.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.
 *                                  <li> 'text_has_header': Indicates whether
 *                          the source data contains a header row.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'text_header_property_delimiter':
 *                          Specifies the delimiter for
 *                          <a
 *                          href="../../../concepts/types/#column-properties"
 *                          target="_top">column properties</a> in the header
 *                          row (if
 *                          present).  Cannot be set to same value as
 *                          <code>text_delimiter</code>.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '|'.
 *                                  <li> 'text_null_string': Specifies the
 *                          character string that should be interpreted as a
 *                          null
 *                          value in the source data.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '\\N'.
 *                                  <li> 'text_quote_character': Specifies the
 *                          character that should be interpreted as a field
 *                          value
 *                          quoting character in the source data.  The
 *                          character must appear at beginning and end of field
 *                          value
 *                          to take effect.  Delimiters within quoted fields
 *                          are treated as literals and not delimiters.  Within
 *                          a quoted field, two consecutive quote characters
 *                          will be interpreted as a single literal quote
 *                          character, effectively escaping it.  To not have a
 *                          quote character, specify an empty string.
 *                          For <code>delimited_text</code>
 *                          <code>file_type</code> only.  The default value is
 *                          '"'.
 *                                  <li> 'text_search_columns': Add
 *                          'text_search' property to internally inferenced
 *                          string columns. Comma seperated list of column
 *                          names or '*' for all columns. To add text_search
 *                          property only to string columns of minimum size,
 *                          set also the option 'text_search_min_column_length'
 *                                  <li> 'text_search_min_column_length': Set
 *                          minimum column size. Used only when
 *                          'text_search_columns' has a value.
 *                                  <li> 'truncate_table': If set to
 *                          <code>true</code>, truncates the table specified by
 *                          <code>table_name</code> prior to loading the
 *                          file(s).
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'type_inference_mode': optimize type
 *                          inference for:
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'accuracy': scans all data to get
 *                          exactly-typed & sized columns for all data present
 *                                  <li> 'speed': picks the widest possible
 *                          column types so that 'all' values will fit with
 *                          minimum data scanned
 *                          </ul>
 *                          The default value is 'speed'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_from_payload = function(table_name, data_text, data_bytes, modify_columns, create_table_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_from_payload(table_name, data_text, data_bytes, modify_columns, create_table_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        data_text: data_text,
        data_bytes: data_bytes,
        modify_columns: (modify_columns !== undefined && modify_columns !== null) ? modify_columns : {},
        create_table_options: (create_table_options !== undefined && create_table_options !== null) ? create_table_options : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records/frompayload", actual_request, callback);
};

/**
 * Computes remote query result and inserts the result data into a new or
 * existing table
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_from_query_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_from_query_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        remote_query: request.remote_query,
        modify_columns: (request.modify_columns !== undefined && request.modify_columns !== null) ? request.modify_columns : {},
        create_table_options: (request.create_table_options !== undefined && request.create_table_options !== null) ? request.create_table_options : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records/fromquery", actual_request, callback);
};

/**
 * Computes remote query result and inserts the result data into a new or
 * existing table
 *
 * @param {String} table_name  Name of the table into which the data will be
 *                             inserted, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 *                             If the table does not exist, the table will be
 *                             created using either an existing
 *                             <code>type_id</code> or the type inferred from
 *                             the
 *                             file, and the new table name will have to meet
 *                             standard
 *                             <a
 *                             href="../../../concepts/tables/#table-naming-criteria"
 *                             target="_top">table naming criteria</a>.
 * @param {String} remote_query  Query for which result data needs to be
 *                               imported
 * @param {Object} modify_columns  Not implemented yet
 * @param {Object} create_table_options  Options used when creating the target
 *                                       table.
 *                                       <ul>
 *                                               <li> 'type_id': ID of a
 *                                       currently registered <a
 *                                       href="../../../concepts/types/"
 *                                       target="_top">type</a>.  The default
 *                                       value is ''.
 *                                               <li> 'no_error_if_exists': If
 *                                       <code>true</code>, prevents an error
 *                                       from occurring if the table already
 *                                       exists and is of the given type.  If a
 *                                       table with the same ID but a different
 *                                       type exists, it is still an error.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'is_replicated': Affects
 *                                       the <a
 *                                       href="../../../concepts/tables/#distribution"
 *                                       target="_top">distribution scheme</a>
 *                                       for the table's data.  If
 *                                       <code>true</code> and the given type
 *                                       has no explicit <a
 *                                       href="../../../concepts/tables/#shard-key"
 *                                       target="_top">shard key</a> defined,
 *                                       the table will be <a
 *                                       href="../../../concepts/tables/#replication"
 *                                       target="_top">replicated</a>.  If
 *                                       <code>false</code>, the table will be
 *                                       <a
 *                                       href="../../../concepts/tables/#sharding"
 *                                       target="_top">sharded</a> according to
 *                                       the shard key specified in the given
 *                                       <code>type_id</code>, or <a
 *                                       href="../../../concepts/tables/#random-sharding"
 *                                       target="_top">randomly sharded</a>, if
 *                                       no shard key is specified.  Note that
 *                                       a type containing a shard key cannot
 *                                       be used to create a replicated table.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'foreign_keys':
 *                                       Semicolon-separated list of <a
 *                                       href="../../../concepts/tables/#foreign-keys"
 *                                       target="_top">foreign keys</a>, of the
 *                                       format '(source_column_name [, ...])
 *                                       references
 *                                       target_table_name(primary_key_column_name
 *                                       [, ...]) [as foreign_key_name]'.
 *                                               <li> 'foreign_shard_key':
 *                                       Foreign shard key of the format
 *                                       'source_column references
 *                                       shard_by_column from
 *                                       target_table(primary_key_column)'.
 *                                               <li> 'partition_type': <a
 *                                       href="../../../concepts/tables/#partitioning"
 *                                       target="_top">Partitioning</a> scheme
 *                                       to use.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'RANGE': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-range"
 *                                       target="_top">range partitioning</a>.
 *                                               <li> 'INTERVAL': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-interval"
 *                                       target="_top">interval
 *                                       partitioning</a>.
 *                                               <li> 'LIST': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitioning</a>.
 *                                               <li> 'HASH': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-hash"
 *                                       target="_top">hash partitioning</a>.
 *                                               <li> 'SERIES': Use <a
 *                                       href="../../../concepts/tables/#partitioning-by-series"
 *                                       target="_top">series partitioning</a>.
 *                                       </ul>
 *                                               <li> 'partition_keys':
 *                                       Comma-separated list of partition
 *                                       keys, which are the columns or column
 *                                       expressions by which records will be
 *                                       assigned to partitions defined by
 *                                       <code>partition_definitions</code>.
 *                                               <li> 'partition_definitions':
 *                                       Comma-separated list of partition
 *                                       definitions, whose format depends on
 *                                       the choice of
 *                                       <code>partition_type</code>.  See <a
 *                                       href="../../../concepts/tables/#partitioning-by-range"
 *                                       target="_top">range partitioning</a>,
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-interval"
 *                                       target="_top">interval
 *                                       partitioning</a>, <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitioning</a>,
 *                                       <a
 *                                       href="../../../concepts/tables/#partitioning-by-hash"
 *                                       target="_top">hash partitioning</a>,
 *                                       or <a
 *                                       href="../../../concepts/tables/#partitioning-by-series"
 *                                       target="_top">series partitioning</a>
 *                                       for example formats.
 *                                               <li> 'is_automatic_partition':
 *                                       If <code>true</code>, a new partition
 *                                       will be created for values which don't
 *                                       fall into an existing partition.
 *                                       Currently only supported for <a
 *                                       href="../../../concepts/tables/#partitioning-by-list"
 *                                       target="_top">list partitions</a>.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'ttl': Sets the <a
 *                                       href="../../../concepts/ttl/"
 *                                       target="_top">TTL</a> of the table
 *                                       specified in <code>table_name</code>.
 *                                               <li> 'chunk_size': Indicates
 *                                       the number of records per chunk to be
 *                                       used for this table.
 *                                               <li> 'is_result_table':
 *                                       Indicates whether the table is a <a
 *                                       href="../../../concepts/tables_memory_only/"
 *                                       target="_top">memory-only table</a>. A
 *                                       result table cannot contain columns
 *                                       with store_only or text_search <a
 *                                       href="../../../concepts/types/#data-handling"
 *                                       target="_top">data-handling</a> or
 *                                       that are <a
 *                                       href="../../../concepts/types/#primitive-types"
 *                                       target="_top">non-charN strings</a>,
 *                                       and it will not be retained if the
 *                                       server is restarted.
 *                                       Supported values:
 *                                       <ul>
 *                                               <li> 'true'
 *                                               <li> 'false'
 *                                       </ul>
 *                                       The default value is 'false'.
 *                                               <li> 'strategy_definition':
 *                                       The <a
 *                                       href="../../../rm/concepts/#tier-strategies"
 *                                       target="_top">tier strategy</a> for
 *                                       the table and its columns.
 *                                       </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'bad_record_table_name': Optional name
 *                          of a table to which records that were rejected are
 *                          written.  The bad-record-table has the following
 *                          columns: line_number (long), line_rejected
 *                          (string), error_message (string).
 *                                  <li> 'bad_record_table_limit': A positive
 *                          integer indicating the maximum number of records
 *                          that can be  written to the bad-record-table.
 *                          Default value is 10000
 *                                  <li> 'bad_record_table_limit_per_input':
 *                          For subscriptions: A positive integer indicating
 *                          the maximum number of records that can be written
 *                          to the bad-record-table per file/payload. Default
 *                          value will be 'bad_record_table_limit' and total
 *                          size of the table per rank is limited to
 *                          'bad_record_table_limit'
 *                                  <li> 'jdbc_fetch_size': The JDBC fetch
 *                          size, which determines how many rows to fetch per
 *                          round trip.
 *                                  <li> 'datasource_name': Name of an existing
 *                          external data source from which table will be
 *                          loaded
 *                                  <li> 'error_handling': Specifies how errors
 *                          should be handled upon insertion.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'permissive': Records with missing
 *                          columns are populated with nulls if possible;
 *                          otherwise, the malformed records are skipped.
 *                                  <li> 'ignore_bad_records': Malformed
 *                          records are skipped.
 *                                  <li> 'abort': Stops current insertion and
 *                          aborts entire operation when an error is
 *                          encountered.  Primary key collisions are considered
 *                          abortable errors in this mode.
 *                          </ul>
 *                          The default value is 'permissive'.
 *                                  <li> 'ingestion_mode': Whether to do a full
 *                          load, dry run, or perform a type inference on the
 *                          source data.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'full': Run a type inference on the
 *                          source data (if needed) and ingest
 *                                  <li> 'dry_run': Does not load data, but
 *                          walks through the source data and determines the
 *                          number of valid records, taking into account the
 *                          current mode of <code>error_handling</code>.
 *                                  <li> 'type_inference_only': Infer the type
 *                          of the source data and return, without ingesting
 *                          any data.  The inferred type is returned in the
 *                          response.
 *                          </ul>
 *                          The default value is 'full'.
 *                                  <li> 'loading_mode': Scheme for
 *                          distributing the extraction and loading of data
 *                          from the source data file(s). This option applies
 *                          only when loading files that are local to the
 *                          database
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'head': The head node loads all data.
 *                          All files must be available to the head node.
 *                                  <li> 'distributed_shared': The head node
 *                          coordinates loading data by worker
 *                          processes across all nodes from shared files
 *                          available to all workers.
 *                          NOTE:
 *                          Instead of existing on a shared source, the files
 *                          can be duplicated on a source local to each host
 *                          to improve performance, though the files must
 *                          appear as the same data set from the perspective of
 *                          all hosts performing the load.
 *                                  <li> 'distributed_local': A single worker
 *                          process on each node loads all files
 *                          that are available to it. This option works best
 *                          when each worker loads files from its own file
 *                          system, to maximize performance. In order to avoid
 *                          data duplication, either each worker performing
 *                          the load needs to have visibility to a set of files
 *                          unique to it (no file is visible to more than
 *                          one node) or the target table needs to have a
 *                          primary key (which will allow the worker to
 *                          automatically deduplicate data).
 *                          NOTE:
 *                          If the target table doesn't exist, the table
 *                          structure will be determined by the head node. If
 *                          the
 *                          head node has no files local to it, it will be
 *                          unable to determine the structure and the request
 *                          will fail.
 *                          If the head node is configured to have no worker
 *                          processes, no data strictly accessible to the head
 *                          node will be loaded.
 *                          </ul>
 *                          The default value is 'head'.
 *                                  <li> 'primary_keys': Optional: comma
 *                          separated list of column names, to set as primary
 *                          keys, when not specified in the type.  The default
 *                          value is ''.
 *                                  <li> 'shard_keys': Optional: comma
 *                          separated list of column names, to set as primary
 *                          keys, when not specified in the type.  The default
 *                          value is ''.
 *                                  <li> 'truncate_table': If set to
 *                          <code>true</code>, truncates the table specified by
 *                          <code>table_name</code> prior to loading the
 *                          file(s).
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'num_tasks_per_rank': Optional: number
 *                          of tasks for reading file per rank. Default will be
 *                          external_file_reader_num_tasks
 *                                  <li> 'remote_query': Remote SQL query from
 *                          which data will be sourced
 *                                  <li> 'remote_query_filter_column': Name of
 *                          column to be used for splitting the query into
 *                          multiple sub-queries.  The default value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_from_query = function(table_name, remote_query, modify_columns, create_table_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_from_query(table_name, remote_query, modify_columns, create_table_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        remote_query: remote_query,
        modify_columns: (modify_columns !== undefined && modify_columns !== null) ? modify_columns : {},
        create_table_options: (create_table_options !== undefined && create_table_options !== null) ? create_table_options : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records/fromquery", actual_request, callback);
};

/**
 * Generates a specified number of random records and adds them to the given
 * table.
 * There is an optional parameter that allows the user to customize the ranges
 * of
 * the column values. It also allows the user to specify linear profiles for
 * some
 * or all columns in which case linear values are generated rather than random
 * ones. Only individual tables are supported for this operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_random_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_random_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        count: request.count,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records/random", actual_request, callback);
};

/**
 * Generates a specified number of random records and adds them to the given
 * table.
 * There is an optional parameter that allows the user to customize the ranges
 * of
 * the column values. It also allows the user to specify linear profiles for
 * some
 * or all columns in which case linear values are generated rather than random
 * ones. Only individual tables are supported for this operation.
 * <p>
 * This operation is synchronous, meaning that a response will not be returned
 * until all random records are fully available.
 *
 * @param {String} table_name  Table to which random records will be added, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table, not a view.
 * @param {Number} count  Number of records to generate.
 * @param {Object} options  Optional parameter to pass in specifications for
 *                          the randomness of the values.  This map is
 *                          different from the *options* parameter of most
 *                          other endpoints in that it is a map of string to
 *                          map of string to doubles, while most others are
 *                          maps of string to string.  In this map, the top
 *                          level keys represent which column's parameters are
 *                          being specified, while the internal keys represents
 *                          which parameter is being specified.  These
 *                          parameters take on different meanings depending on
 *                          the type of the column.  Below follows a more
 *                          detailed description of the map:
 *                          <ul>
 *                                  <li> 'seed': If provided, the internal
 *                          random number generator will be initialized with
 *                          the given value.  The minimum is 0.  This allows
 *                          for the same set of random numbers to be generated
 *                          across invocation of this endpoint in case the user
 *                          wants to repeat the test.  Since
 *                          <code>options</code>, is a map of maps, we need an
 *                          internal map to provide the seed value.  For
 *                          example, to pass 100 as the seed value through this
 *                          parameter, you need something equivalent to:
 *                          'options' = {'seed': { 'value': 100 } }
 *                          <ul>
 *                                  <li> 'value': The seed value to use
 *                          </ul>
 *                                  <li> 'all': This key indicates that the
 *                          specifications relayed in the internal map are to
 *                          be applied to all columns of the records.
 *                          <ul>
 *                                  <li> 'min': For numerical columns, the
 *                          minimum of the generated values is set to this
 *                          value.  Default is -99999.  For point, shape, and
 *                          track columns, min for numeric 'x' and 'y' columns
 *                          needs to be within [-180, 180] and [-90, 90],
 *                          respectively. The default minimum possible values
 *                          for these columns in such cases are -180.0 and
 *                          -90.0. For the 'TIMESTAMP' column, the default
 *                          minimum corresponds to Jan 1, 2010.
 *                          For string columns, the minimum length of the
 *                          randomly generated strings is set to this value
 *                          (default is 0). If both minimum and maximum are
 *                          provided, minimum must be less than or equal to
 *                          max. Value needs to be within [0, 200].
 *                          If the min is outside the accepted ranges for
 *                          strings columns and 'x' and 'y' columns for
 *                          point/shape/track, then those parameters will not
 *                          be set; however, an error will not be thrown in
 *                          such a case. It is the responsibility of the user
 *                          to use the <code>all</code> parameter judiciously.
 *                                  <li> 'max': For numerical columns, the
 *                          maximum of the generated values is set to this
 *                          value. Default is 99999. For point, shape, and
 *                          track columns, max for numeric 'x' and 'y' columns
 *                          needs to be within [-180, 180] and [-90, 90],
 *                          respectively. The default minimum possible values
 *                          for these columns in such cases are 180.0 and 90.0.
 *                          For string columns, the maximum length of the
 *                          randomly generated strings is set to this value
 *                          (default is 200). If both minimum and maximum are
 *                          provided, *max* must be greater than or equal to
 *                          *min*. Value needs to be within [0, 200].
 *                          If the *max* is outside the accepted ranges for
 *                          strings columns and 'x' and 'y' columns for
 *                          point/shape/track, then those parameters will not
 *                          be set; however, an error will not be thrown in
 *                          such a case. It is the responsibility of the user
 *                          to use the <code>all</code> parameter judiciously.
 *                                  <li> 'interval': If specified, generate
 *                          values for all columns evenly spaced with the given
 *                          interval value. If a max value is specified for a
 *                          given column the data is randomly generated between
 *                          min and max and decimated down to the interval. If
 *                          no max is provided the data is linerally generated
 *                          starting at the minimum value (instead of
 *                          generating random data). For non-decimated
 *                          string-type columns the interval value is ignored.
 *                          Instead the values are generated following the
 *                          pattern: 'attrname_creationIndex#', i.e. the column
 *                          name suffixed with an underscore and a running
 *                          counter (starting at 0). For string types with
 *                          limited size (eg char4) the prefix is dropped. No
 *                          nulls will be generated for nullable columns.
 *                                  <li> 'null_percentage': If specified, then
 *                          generate the given percentage of the count as nulls
 *                          for all nullable columns.  This option will be
 *                          ignored for non-nullable columns.  The value must
 *                          be within the range [0, 1.0].  The default value is
 *                          5% (0.05).
 *                                  <li> 'cardinality': If specified, limit the
 *                          randomly generated values to a fixed set. Not
 *                          allowed on a column with interval specified, and is
 *                          not applicable to WKT or Track-specific columns.
 *                          The value must be greater than 0. This option is
 *                          disabled by default.
 *                          </ul>
 *                                  <li> 'attr_name': Use the desired column
 *                          name in place of <code>attr_name</code>, and set
 *                          the following parameters for the column specified.
 *                          This overrides any parameter set by
 *                          <code>all</code>.
 *                          <ul>
 *                                  <li> 'min': For numerical columns, the
 *                          minimum of the generated values is set to this
 *                          value.  Default is -99999.  For point, shape, and
 *                          track columns, min for numeric 'x' and 'y' columns
 *                          needs to be within [-180, 180] and [-90, 90],
 *                          respectively. The default minimum possible values
 *                          for these columns in such cases are -180.0 and
 *                          -90.0. For the 'TIMESTAMP' column, the default
 *                          minimum corresponds to Jan 1, 2010.
 *                          For string columns, the minimum length of the
 *                          randomly generated strings is set to this value
 *                          (default is 0). If both minimum and maximum are
 *                          provided, minimum must be less than or equal to
 *                          max. Value needs to be within [0, 200].
 *                          If the min is outside the accepted ranges for
 *                          strings columns and 'x' and 'y' columns for
 *                          point/shape/track, then those parameters will not
 *                          be set; however, an error will not be thrown in
 *                          such a case. It is the responsibility of the user
 *                          to use the <code>all</code> parameter judiciously.
 *                                  <li> 'max': For numerical columns, the
 *                          maximum of the generated values is set to this
 *                          value. Default is 99999. For point, shape, and
 *                          track columns, max for numeric 'x' and 'y' columns
 *                          needs to be within [-180, 180] and [-90, 90],
 *                          respectively. The default minimum possible values
 *                          for these columns in such cases are 180.0 and 90.0.
 *                          For string columns, the maximum length of the
 *                          randomly generated strings is set to this value
 *                          (default is 200). If both minimum and maximum are
 *                          provided, *max* must be greater than or equal to
 *                          *min*. Value needs to be within [0, 200].
 *                          If the *max* is outside the accepted ranges for
 *                          strings columns and 'x' and 'y' columns for
 *                          point/shape/track, then those parameters will not
 *                          be set; however, an error will not be thrown in
 *                          such a case. It is the responsibility of the user
 *                          to use the <code>all</code> parameter judiciously.
 *                                  <li> 'interval': If specified, generate
 *                          values for all columns evenly spaced with the given
 *                          interval value. If a max value is specified for a
 *                          given column the data is randomly generated between
 *                          min and max and decimated down to the interval. If
 *                          no max is provided the data is linerally generated
 *                          starting at the minimum value (instead of
 *                          generating random data). For non-decimated
 *                          string-type columns the interval value is ignored.
 *                          Instead the values are generated following the
 *                          pattern: 'attrname_creationIndex#', i.e. the column
 *                          name suffixed with an underscore and a running
 *                          counter (starting at 0). For string types with
 *                          limited size (eg char4) the prefix is dropped. No
 *                          nulls will be generated for nullable columns.
 *                                  <li> 'null_percentage': If specified and if
 *                          this column is nullable, then generate the given
 *                          percentage of the count as nulls.  This option will
 *                          result in an error if the column is not nullable.
 *                          The value must be within the range [0, 1.0].  The
 *                          default value is 5% (0.05).
 *                                  <li> 'cardinality': If specified, limit the
 *                          randomly generated values to a fixed set. Not
 *                          allowed on a column with interval specified, and is
 *                          not applicable to WKT or Track-specific columns.
 *                          The value must be greater than 0. This option is
 *                          disabled by default.
 *                          </ul>
 *                                  <li> 'track_length': This key-map pair is
 *                          only valid for track data sets (an error is thrown
 *                          otherwise).  No nulls would be generated for
 *                          nullable columns.
 *                          <ul>
 *                                  <li> 'min': Minimum possible length for
 *                          generated series; default is 100 records per
 *                          series. Must be an integral value within the range
 *                          [1, 500]. If both min and max are specified, min
 *                          must be less than or equal to max.
 *                                  <li> 'max': Maximum possible length for
 *                          generated series; default is 500 records per
 *                          series. Must be an integral value within the range
 *                          [1, 500]. If both min and max are specified, max
 *                          must be greater than or equal to min.
 *                          </ul>
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_random = function(table_name, count, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_random(table_name, count, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        count: count,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records/random", actual_request, callback);
};

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../../api/rest/wms_rest/" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_symbol_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_symbol_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        symbol_id: request.symbol_id,
        symbol_format: request.symbol_format,
        symbol_data: request.symbol_data,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/symbol", actual_request, callback);
};

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../../../api/rest/wms_rest/" target="_top">WMS</a>) if the
 * 'dosymbology' parameter is 'true' then the value of the 'SYMBOLCODE' column
 * is used to pick the symbol displayed for each point.
 *
 * @param {String} symbol_id  The id of the symbol being added. This is the
 *                            same id that should be in the 'SYMBOLCODE' column
 *                            for objects using this symbol
 * @param {String} symbol_format  Specifies the symbol format. Must be either
 *                                'svg' or 'svg_path'.
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'svg'
 *                                        <li> 'svg_path'
 *                                </ul>
 * @param {String} symbol_data  The actual symbol data. If
 *                              <code>symbol_format</code> is 'svg' then this
 *                              should be the raw bytes representing an svg
 *                              file. If <code>symbol_format</code> is svg path
 *                              then this should be an svg path string, for
 *                              example:
 *                              'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'color': If <code>symbol_format</code>
 *                          is 'svg' this is ignored. If
 *                          <code>symbol_format</code> is 'svg_path' then this
 *                          option specifies the color (in RRGGBB hex format)
 *                          of the path. For example, to have the path rendered
 *                          in red, used 'FF0000'. If 'color' is not provided
 *                          then '00FF00' (i.e. green) is used by default.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_symbol = function(symbol_id, symbol_format, symbol_data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_symbol(symbol_id, symbol_format, symbol_data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        symbol_id: symbol_id,
        symbol_format: symbol_format,
        symbol_data: symbol_data,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/symbol", actual_request, callback);
};

/**
 * Kills a running proc instance.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.kill_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.kill_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        run_id: (request.run_id !== undefined && request.run_id !== null) ? request.run_id : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/kill/proc", actual_request, callback);
};

/**
 * Kills a running proc instance.
 *
 * @param {String} run_id  The run ID of a running proc instance. If a proc
 *                         with a matching run ID is not found or the proc
 *                         instance has already completed, no procs will be
 *                         killed. If not specified, all running proc instances
 *                         will be killed.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'run_tag': If <code>run_id</code> is
 *                          specified, kill the proc instance that has a
 *                          matching run ID and a matching run tag that was
 *                          provided to {@linkcode GPUdb#execute_proc}. If
 *                          <code>run_id</code> is not specified, kill the proc
 *                          instance(s) where a matching run tag was provided
 *                          to {@linkcode GPUdb#execute_proc}.  The default
 *                          value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.kill_proc = function(run_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.kill_proc(run_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        run_id: (run_id !== undefined && run_id !== null) ? run_id : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/kill/proc", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.list_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.list_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: (request.graph_name !== undefined && request.graph_name !== null) ? request.graph_name : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/list/graph", actual_request, callback);
};

/**
 *
 * @param {String} graph_name
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.list_graph = function(graph_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.list_graph(graph_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: (graph_name !== undefined && graph_name !== null) ? graph_name : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/list/graph", actual_request, callback);
};

/**
 * Manages global access to a table's data.  By default a table has a
 * <code>lock_type</code> of <code>read_write</code>, indicating all operations
 * are permitted.  A user may request a <code>read_only</code> or a
 * <code>write_only</code> lock, after which only read or write operations,
 * respectively, are permitted on the table until the lock is removed.  When
 * <code>lock_type</code> is <code>no_access</code> then no operations are
 * permitted on the table.  The lock status can be queried by setting
 * <code>lock_type</code> to <code>status</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.lock_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.lock_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        lock_type: (request.lock_type !== undefined && request.lock_type !== null) ? request.lock_type : "status",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/lock/table", actual_request, callback);
};

/**
 * Manages global access to a table's data.  By default a table has a
 * <code>lock_type</code> of <code>read_write</code>, indicating all operations
 * are permitted.  A user may request a <code>read_only</code> or a
 * <code>write_only</code> lock, after which only read or write operations,
 * respectively, are permitted on the table until the lock is removed.  When
 * <code>lock_type</code> is <code>no_access</code> then no operations are
 * permitted on the table.  The lock status can be queried by setting
 * <code>lock_type</code> to <code>status</code>.
 *
 * @param {String} table_name  Name of the table to be locked, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  It
 *                             must be a currently existing table or view.
 * @param {String} lock_type  The type of lock being applied to the table.
 *                            Setting it to <code>status</code> will return the
 *                            current lock status of the table without changing
 *                            it.
 *                            Supported values:
 *                            <ul>
 *                                    <li> 'status': Show locked status
 *                                    <li> 'no_access': Allow no read/write
 *                            operations
 *                                    <li> 'read_only': Allow only read
 *                            operations
 *                                    <li> 'write_only': Allow only write
 *                            operations
 *                                    <li> 'read_write': Allow all read/write
 *                            operations
 *                            </ul>
 *                            The default value is 'status'.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.lock_table = function(table_name, lock_type, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.lock_table(table_name, lock_type, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        lock_type: (lock_type !== undefined && lock_type !== null) ? lock_type : "status",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/lock/table", actual_request, callback);
};

/**
 * Matches a directed route implied by a given set of
 * latitude/longitude points to an existing underlying road network graph using
 * a
 * given solution type.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph-match/" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.match_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.match_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        sample_points: request.sample_points,
        solve_method: (request.solve_method !== undefined && request.solve_method !== null) ? request.solve_method : "markov_chain",
        solution_table: (request.solution_table !== undefined && request.solution_table !== null) ? request.solution_table : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/match/graph", actual_request, callback);
};

/**
 * Matches a directed route implied by a given set of
 * latitude/longitude points to an existing underlying road network graph using
 * a
 * given solution type.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph-match/" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 *
 * @param {String} graph_name  Name of the underlying geospatial graph resource
 *                             to match to using <code>sample_points</code>.
 * @param {String[]} sample_points  Sample points used to match to an
 *                                  underlying geospatial
 *                                  graph. Sample points must be specified
 *                                  using
 *                                  <a
 *                                  href="../../../graph_solver/network_graph_solver/#match-identifiers"
 *                                  target="_top">identifiers</a>;
 *                                  identifiers are grouped as
 *                                  <a
 *                                  href="../../../graph_solver/network_graph_solver/#match-combinations"
 *                                  target="_top">combinations</a>.
 *                                  Identifiers can be used with: existing
 *                                  column names, e.g.,
 *                                  'table.column AS SAMPLE_X'; expressions,
 *                                  e.g.,
 *                                  'ST_MAKEPOINT(table.x, table.y) AS
 *                                  SAMPLE_WKTPOINT'; or constant values, e.g.,
 *                                  '{1, 2, 10} AS SAMPLE_TRIPID'.
 * @param {String} solve_method  The type of solver to use for graph matching.
 *                               Supported values:
 *                               <ul>
 *                                       <li> 'markov_chain': Matches
 *                               <code>sample_points</code> to the graph using
 *                               the Hidden Markov Model (HMM)-based method,
 *                               which conducts a range-tree closest-edge
 *                               search to find the best combinations of
 *                               possible road segments
 *                               (<code>num_segments</code>) for each sample
 *                               point to create the best route. The route is
 *                               secured one point at a time while looking
 *                               ahead <code>chain_width</code> number of
 *                               points, so the prediction is corrected after
 *                               each point. This solution type is the most
 *                               accurate but also the most computationally
 *                               intensive. Related options:
 *                               <code>num_segments</code> and
 *                               <code>chain_width</code>.
 *                                       <li> 'match_od_pairs': Matches
 *                               <code>sample_points</code> to find the most
 *                               probable path between origin and destination
 *                               pairs with cost constraints.
 *                                       <li> 'match_supply_demand': Matches
 *                               <code>sample_points</code> to optimize
 *                               scheduling multiple supplies (trucks) with
 *                               varying sizes to varying demand sites with
 *                               varying capacities per depot. Related options:
 *                               <code>partial_loading</code> and
 *                               <code>max_combinations</code>.
 *                                       <li> 'match_batch_solves': Matches
 *                               <code>sample_points</code> source and
 *                               destination pairs for the shortest path solves
 *                               in batch mode.
 *                                       <li> 'match_loops': Matches closed
 *                               loops (Eulerian paths) originating and ending
 *                               at each graph node within min and max hops
 *                               (levels).
 *                                       <li> 'match_charging_stations':
 *                               Matches an optimal path across a number of
 *                               ev-charging stations between source and target
 *                               locations.
 *                               </ul>
 *                               The default value is 'markov_chain'.
 * @param {String} solution_table  The name of the table used to store the
 *                                 results, in [schema_name.]table_name format,
 *                                 using standard <a
 *                                 href="../../../concepts/tables/#table-name-resolution"
 *                                 target="_top">name resolution rules</a> and
 *                                 meeting <a
 *                                 href="../../../concepts/tables/#table-naming-criteria"
 *                                 target="_top">table naming criteria</a>.
 *                                 This table contains a <a
 *                                 href="../../../geospatial/geo_objects/#geospatial-tracks"
 *                                 target="_top">track</a> of geospatial points
 *                                 for the matched portion of the graph, a
 *                                 track ID, and a score value. Also outputs a
 *                                 details table containing a trip ID (that
 *                                 matches the track ID), the
 *                                 latitude/longitude pair, the timestamp the
 *                                 point was recorded at, and an edge ID
 *                                 corresponding to the matched road segment.
 *                                 Must not be an existing table of the same
 *                                 name.
 * @param {Object} options  Additional parameters
 *                          <ul>
 *                                  <li> 'gps_noise': GPS noise value (in
 *                          meters) to remove redundant sample points. Use -1
 *                          to disable noise reduction. The default value
 *                          accounts for 95% of point variation (+ or -5
 *                          meters).  The default value is '5.0'.
 *                                  <li> 'num_segments': Maximum number of
 *                          potentially matching road segments for each sample
 *                          point. For the <code>markov_chain</code> solver,
 *                          the default is 3.  The default value is '3'.
 *                                  <li> 'search_radius': Maximum search radius
 *                          used when snapping sample points onto potentially
 *                          matching surrounding segments. The default value
 *                          corresponds to approximately 100 meters.  The
 *                          default value is '0.001'.
 *                                  <li> 'chain_width': For the
 *                          <code>markov_chain</code> solver only. Length of
 *                          the sample points lookahead window within the
 *                          Markov kernel; the larger the number, the more
 *                          accurate the solution.  The default value is '9'.
 *                                  <li> 'source': Optional WKT starting point
 *                          from <code>sample_points</code> for the solver. The
 *                          default behavior for the endpoint is to use time to
 *                          determine the starting point.  The default value is
 *                          'POINT NULL'.
 *                                  <li> 'destination': Optional WKT ending
 *                          point from <code>sample_points</code> for the
 *                          solver. The default behavior for the endpoint is to
 *                          use time to determine the destination point.  The
 *                          default value is 'POINT NULL'.
 *                                  <li> 'partial_loading': For the
 *                          <code>match_supply_demand</code> solver only. When
 *                          false (non-default), trucks do not off-load at the
 *                          demand (store) side if the remainder is less than
 *                          the store's need
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': Partial off-loading at
 *                          multiple store (demand) locations
 *                                  <li> 'false': No partial off-loading
 *                          allowed if supply is less than the store's demand.
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'max_combinations': For the
 *                          <code>match_supply_demand</code> solver only. This
 *                          is the cutoff for the number of generated
 *                          combinations for sequencing the demand locations -
 *                          can increase this up to 2M.  The default value is
 *                          '10000'.
 *                                  <li> 'left_turn_penalty': This will add an
 *                          additonal weight over the edges labelled as 'left
 *                          turn' if the 'add_turn' option parameter of the
 *                          {@linkcode GPUdb#create_graph} was invoked at
 *                          graph creation.  The default value is '0.0'.
 *                                  <li> 'right_turn_penalty': This will add an
 *                          additonal weight over the edges labelled as' right
 *                          turn' if the 'add_turn' option parameter of the
 *                          {@linkcode GPUdb#create_graph} was invoked at
 *                          graph creation.  The default value is '0.0'.
 *                                  <li> 'intersection_penalty': This will add
 *                          an additonal weight over the edges labelled as
 *                          'intersection' if the 'add_turn' option parameter
 *                          of the {@linkcode GPUdb#create_graph} was invoked
 *                          at graph creation.  The default value is '0.0'.
 *                                  <li> 'sharp_turn_penalty': This will add an
 *                          additonal weight over the edges labelled as 'sharp
 *                          turn' or 'u-turn' if the 'add_turn' option
 *                          parameter of the {@linkcode GPUdb#create_graph}
 *                          was invoked at graph creation.  The default value
 *                          is '0.0'.
 *                                  <li> 'aggregated_output': For the
 *                          <code>match_supply_demand</code> solver only. When
 *                          it is true (default), each record in the output
 *                          table shows a particular truck's scheduled
 *                          cumulative round trip path (MULTILINESTRING) and
 *                          the corresponding aggregated cost. Otherwise, each
 *                          record shows a single scheduled truck route
 *                          (LINESTRING) towards a particular demand location
 *                          (store id) with its corresponding cost.  The
 *                          default value is 'true'.
 *                                  <li> 'output_tracks': For the
 *                          <code>match_supply_demand</code> solver only. When
 *                          it is true (non-default), the output will be in
 *                          tracks format for all the round trips of each truck
 *                          in which the timestamps are populated directly from
 *                          the edge weights starting from their originating
 *                          depots.  The default value is 'false'.
 *                                  <li> 'max_trip_cost': For the
 *                          <code>match_supply_demand</code> solver only. If
 *                          this constraint is greater than zero (default) then
 *                          the trucks will skip travelling from one demand
 *                          location to another if the cost between them is
 *                          greater than this number (distance or time). Zero
 *                          (default) value means no check is performed.  The
 *                          default value is '0.0'.
 *                                  <li> 'filter_folding_paths': For the
 *                          <code>markov_chain</code> solver only. When true
 *                          (non-default), the paths per sequence combination
 *                          is checked for folding over patterns and can
 *                          significantly increase the execution time depending
 *                          on the chain width and the number of gps samples.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': Filter out the folded paths.
 *                                  <li> 'false': Do not filter out the folded
 *                          paths
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'unit_unloading_cost': For the
 *                          <code>match_supply_demand</code> solver only. The
 *                          unit cost per load amount to be delivered. If this
 *                          value is greater than zero (default) then the
 *                          additional cost of this unit load multiplied by the
 *                          total dropped load will be added over to the trip
 *                          cost to the demand location.  The default value is
 *                          '0.0'.
 *                                  <li> 'max_num_threads': For the
 *                          <code>markov_chain</code> solver only. If specified
 *                          (greater than zero), the maximum number of threads
 *                          will not be greater than the specified value. It
 *                          can be lower due to the memory and the number cores
 *                          available. Default value of zero allows the
 *                          algorithm to set the maximal number of threads
 *                          within these constraints.  The default value is
 *                          '0'.
 *                                  <li> 'truck_service_limit': For the
 *                          <code>match_supply_demand</code> solver only. If
 *                          specified (greater than zero), any truck's total
 *                          service cost (distance or time) will be limited by
 *                          the specified value including multiple rounds (if
 *                          set).  The default value is '0.0'.
 *                                  <li> 'enable_truck_reuse': For the
 *                          <code>match_supply_demand</code> solver only. If
 *                          specified (true), all trucks can be scheduled for
 *                          second rounds from their originating depots.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': Allows reusing trucks for
 *                          scheduling again.
 *                                  <li> 'false': Trucks are scheduled only
 *                          once from their depots.
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'max_truck_stops': For the
 *                          <code>match_supply_demand</code> solver only. If
 *                          specified (greater than zero), a truck can at most
 *                          have this many stops (demand locations) in one
 *                          round trip. Otherwise, it is unlimited. If
 *                          'enable_truck_reuse' is on, this condition will be
 *                          applied separately at each round trip use of the
 *                          same truck.  The default value is '0'.
 *                                  <li> 'server_id': Indicates which graph
 *                          server(s) to send the request to. Default is to
 *                          send to the server, amongst those containing the
 *                          corresponding graph, that has the most
 *                          computational bandwidth.  The default value is ''.
 *                                  <li> 'inverse_solve': For the
 *                          <code>match_batch_solves</code> solver only. Solves
 *                          source-destination pairs using inverse shortest
 *                          path solver.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': Solves using inverse shortest
 *                          path solver.
 *                                  <li> 'false': Solves using direct shortest
 *                          path solver.
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'min_loop_level': For the
 *                          <code>match_loops</code> solver only. Finds closed
 *                          loops around each node deducible not less than this
 *                          minimal hop (level) deep.  The default value is
 *                          '0'.
 *                                  <li> 'max_loop_level': For the
 *                          <code>match_loops</code> solver only. Finds closed
 *                          loops around each node deducible not more than this
 *                          maximal hop (level) deep.  The default value is
 *                          '5'.
 *                                  <li> 'search_limit': For the
 *                          <code>match_loops</code> solver only. Searches
 *                          within this limit of nodes per vertex to detect
 *                          loops. The value zero means there is no limit.  The
 *                          default value is '10000'.
 *                                  <li> 'output_batch_size': For the
 *                          <code>match_loops</code> solver only. Uses this
 *                          value as the batch size of the number of loops in
 *                          flushing(inserting) to the output table.  The
 *                          default value is '1000'.
 *                                  <li> 'charging_capacity': For the
 *                          <code>match_charging_stations</code> solver only.
 *                          This is the maximum ev-charging capacity of a
 *                          vehicle (distance in meters or time in seconds
 *                          depending on the unit of the graph weights).  The
 *                          default value is '300000.0'.
 *                                  <li> 'charging_candidates': For the
 *                          <code>match_charging_stations</code> solver only.
 *                          Solver searches for this many number of stations
 *                          closest around each base charging location found by
 *                          capacity.  The default value is '10'.
 *                                  <li> 'charging_penalty': For the
 *                          <code>match_charging_stations</code> solver only.
 *                          This is the penalty for full charging.  The default
 *                          value is '30000.0'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.match_graph = function(graph_name, sample_points, solve_method, solution_table, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.match_graph(graph_name, sample_points, solve_method, solution_table, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        sample_points: sample_points,
        solve_method: (solve_method !== undefined && solve_method !== null) ? solve_method : "markov_chain",
        solution_table: (solution_table !== undefined && solution_table !== null) ? solution_table : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/match/graph", actual_request, callback);
};

/**
 * Create a new empty result table (specified by <code>table_name</code>),
 * and insert all records from source tables
 * (specified by <code>source_table_names</code>) based on the field mapping
 * information (specified by <code>field_maps</code>).
 * <p>
 * For merge records details and examples, see
 * <a href="../../../concepts/merge_records/" target="_top">Merge Records</a>.
 * For limitations, see
 * <a href="../../../concepts/merge_records/#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by <code>field_maps</code>) holds the
 * user-specified maps
 * of target table column names to source table columns. The array of
 * <code>field_maps</code> must match one-to-one with the
 * <code>source_table_names</code>,
 * e.g., there's a map present in <code>field_maps</code> for each table listed
 * in
 * <code>source_table_names</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.merge_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.merge_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        source_table_names: request.source_table_names,
        field_maps: request.field_maps,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/merge/records", actual_request, callback);
};

/**
 * Create a new empty result table (specified by <code>table_name</code>),
 * and insert all records from source tables
 * (specified by <code>source_table_names</code>) based on the field mapping
 * information (specified by <code>field_maps</code>).
 * <p>
 * For merge records details and examples, see
 * <a href="../../../concepts/merge_records/" target="_top">Merge Records</a>.
 * For limitations, see
 * <a href="../../../concepts/merge_records/#limitations-and-cautions"
 * target="_top">Merge Records Limitations and Cautions</a>.

 * The field map (specified by <code>field_maps</code>) holds the
 * user-specified maps
 * of target table column names to source table columns. The array of
 * <code>field_maps</code> must match one-to-one with the
 * <code>source_table_names</code>,
 * e.g., there's a map present in <code>field_maps</code> for each table listed
 * in
 * <code>source_table_names</code>.
 *
 * @param {String} table_name  The name of the new result table for the records
 *                             to be merged into, in [schema_name.]table_name
 *                             format, using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a> and
 *                             meeting <a
 *                             href="../../../concepts/tables/#table-naming-criteria"
 *                             target="_top">table naming criteria</a>.  Must
 *                             NOT be an existing table.
 * @param {String[]} source_table_names  The list of names of source tables to
 *                                       get the records from, each in
 *                                       [schema_name.]table_name format, using
 *                                       standard <a
 *                                       href="../../../concepts/tables/#table-name-resolution"
 *                                       target="_top">name resolution
 *                                       rules</a>.  Must be existing table
 *                                       names.
 * @param {Object[]} field_maps  Contains a list of source/target column
 *                               mappings, one mapping for each source table
 *                               listed in <code>source_table_names</code>
 *                               being merged into the target table specified
 *                               by <code>table_name</code>.  Each mapping
 *                               contains the target column names (as keys)
 *                               that the data in the mapped source columns or
 *                               column <a
 *                               href="../../../concepts/expressions/"
 *                               target="_top">expressions</a> (as values) will
 *                               be merged into.  All of the source columns
 *                               being merged into a given target column must
 *                               match in type, as that type will determine the
 *                               type of the new target column.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'create_temp_table': If
 *                          <code>true</code>, a unique temporary table name
 *                          will be generated in the sys_temp schema and used
 *                          in place of <code>table_name</code>. If
 *                          <code>persist</code> is <code>false</code>, then
 *                          this is always allowed even if the caller does not
 *                          have permission to create tables. The generated
 *                          name is returned in
 *                          <code>qualified_table_name</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'collection_name': [DEPRECATED--please
 *                          specify the containing schema for the merged table
 *                          as part of <code>table_name</code> and use
 *                          {@linkcode GPUdb#create_schema} to create the
 *                          schema if non-existent]  Name of a schema for the
 *                          newly created merged table specified by
 *                          <code>table_name</code>.
 *                                  <li> 'is_replicated': Indicates the <a
 *                          href="../../../concepts/tables/#distribution"
 *                          target="_top">distribution scheme</a> for the data
 *                          of the merged table specified in
 *                          <code>table_name</code>.  If true, the table will
 *                          be <a href="../../../concepts/tables/#replication"
 *                          target="_top">replicated</a>.  If false, the table
 *                          will be <a
 *                          href="../../../concepts/tables/#random-sharding"
 *                          target="_top">randomly sharded</a>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'ttl': Sets the <a
 *                          href="../../../concepts/ttl/" target="_top">TTL</a>
 *                          of the merged table specified in
 *                          <code>table_name</code>.
 *                                  <li> 'persist': If <code>true</code>, then
 *                          the table specified in <code>table_name</code> will
 *                          be persisted and will not expire unless a
 *                          <code>ttl</code> is specified.   If
 *                          <code>false</code>, then the table will be an
 *                          in-memory table and will expire unless a
 *                          <code>ttl</code> is specified otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'chunk_size': Indicates the number of
 *                          records per chunk to be used for the merged table
 *                          specified in <code>table_name</code>.
 *                                  <li> 'view_id': view this result table is
 *                          part of.  The default value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.merge_records = function(table_name, source_table_names, field_maps, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.merge_records(table_name, source_table_names, field_maps, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        source_table_names: source_table_names,
        field_maps: field_maps,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/merge/records", actual_request, callback);
};

/**
 * Update an existing graph network using given nodes, edges, weights,
 * restrictions, and options.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation and
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>
 * before using this endpoint.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.modify_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.modify_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        nodes: request.nodes,
        edges: request.edges,
        weights: request.weights,
        restrictions: request.restrictions,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/modify/graph", actual_request, callback);
};

/**
 * Update an existing graph network using given nodes, edges, weights,
 * restrictions, and options.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation and
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>
 * before using this endpoint.
 *
 * @param {String} graph_name  Name of the graph resource to modify.
 * @param {String[]} nodes  Nodes with which to update existing
 *                          <code>nodes</code> in graph specified by
 *                          <code>graph_name</code>. Review <a
 *                          href="../../../graph_solver/network_graph_solver/#nodes"
 *                          target="_top">Nodes</a> for more information. Nodes
 *                          must be specified using <a
 *                          href="../../../graph_solver/network_graph_solver/#identifiers"
 *                          target="_top">identifiers</a>; identifiers are
 *                          grouped as <a
 *                          href="../../../graph_solver/network_graph_solver/#id-combos"
 *                          target="_top">combinations</a>. Identifiers can be
 *                          used with existing column names, e.g.,
 *                          'table.column AS NODE_ID', expressions, e.g.,
 *                          'ST_MAKEPOINT(column1, column2) AS NODE_WKTPOINT',
 *                          or raw values, e.g., '{9, 10, 11} AS NODE_ID'. If
 *                          using raw values in an identifier combination, the
 *                          number of values specified must match across the
 *                          combination. Identifier combination(s) do not have
 *                          to match the method used to create the graph, e.g.,
 *                          if column names were specified to create the graph,
 *                          expressions or raw values could also be used to
 *                          modify the graph.
 * @param {String[]} edges  Edges with which to update existing
 *                          <code>edges</code> in graph specified by
 *                          <code>graph_name</code>. Review <a
 *                          href="../../../graph_solver/network_graph_solver/#edges"
 *                          target="_top">Edges</a> for more information. Edges
 *                          must be specified using <a
 *                          href="../../../graph_solver/network_graph_solver/#identifiers"
 *                          target="_top">identifiers</a>; identifiers are
 *                          grouped as <a
 *                          href="../../../graph_solver/network_graph_solver/#id-combos"
 *                          target="_top">combinations</a>. Identifiers can be
 *                          used with existing column names, e.g.,
 *                          'table.column AS EDGE_ID', expressions, e.g.,
 *                          'SUBSTR(column, 1, 6) AS EDGE_NODE1_NAME', or raw
 *                          values, e.g., "{'family', 'coworker'} AS
 *                          EDGE_LABEL". If using raw values in an identifier
 *                          combination, the number of values specified must
 *                          match across the combination. Identifier
 *                          combination(s) do not have to match the method used
 *                          to create the graph, e.g., if column names were
 *                          specified to create the graph, expressions or raw
 *                          values could also be used to modify the graph.
 * @param {String[]} weights  Weights with which to update existing
 *                            <code>weights</code> in graph specified by
 *                            <code>graph_name</code>. Review <a
 *                            href="../../../graph_solver/network_graph_solver/#graph-weights"
 *                            target="_top">Weights</a> for more information.
 *                            Weights must be specified using <a
 *                            href="../../../graph_solver/network_graph_solver/#identifiers"
 *                            target="_top">identifiers</a>; identifiers are
 *                            grouped as <a
 *                            href="../../../graph_solver/network_graph_solver/#id-combos"
 *                            target="_top">combinations</a>. Identifiers can
 *                            be used with existing column names, e.g.,
 *                            'table.column AS WEIGHTS_EDGE_ID', expressions,
 *                            e.g., 'ST_LENGTH(wkt) AS WEIGHTS_VALUESPECIFIED',
 *                            or raw values, e.g., '{4, 15} AS
 *                            WEIGHTS_VALUESPECIFIED'. If using raw values in
 *                            an identifier combination, the number of values
 *                            specified must match across the combination.
 *                            Identifier combination(s) do not have to match
 *                            the method used to create the graph, e.g., if
 *                            column names were specified to create the graph,
 *                            expressions or raw values could also be used to
 *                            modify the graph.
 * @param {String[]} restrictions  Restrictions with which to update existing
 *                                 <code>restrictions</code> in graph specified
 *                                 by <code>graph_name</code>. Review <a
 *                                 href="../../../graph_solver/network_graph_solver/#graph-restrictions"
 *                                 target="_top">Restrictions</a> for more
 *                                 information. Restrictions must be specified
 *                                 using <a
 *                                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                                 target="_top">identifiers</a>; identifiers
 *                                 are grouped as <a
 *                                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                                 target="_top">combinations</a>. Identifiers
 *                                 can be used with existing column names,
 *                                 e.g., 'table.column AS
 *                                 RESTRICTIONS_EDGE_ID', expressions, e.g.,
 *                                 'column/2 AS RESTRICTIONS_VALUECOMPARED', or
 *                                 raw values, e.g., '{0, 0, 0, 1} AS
 *                                 RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                                 values in an identifier combination, the
 *                                 number of values specified must match across
 *                                 the combination. Identifier combination(s)
 *                                 do not have to match the method used to
 *                                 create the graph, e.g., if column names were
 *                                 specified to create the graph, expressions
 *                                 or raw values could also be used to modify
 *                                 the graph.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'restriction_threshold_value':
 *                          Value-based restriction comparison. Any node or
 *                          edge with a RESTRICTIONS_VALUECOMPARED value
 *                          greater than the
 *                          <code>restriction_threshold_value</code> will not
 *                          be included in the graph.
 *                                  <li> 'export_create_results': If set to
 *                          <code>true</code>, returns the graph topology in
 *                          the response as arrays.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'enable_graph_draw': If set to
 *                          <code>true</code>, adds a 'EDGE_WKTLINE' column
 *                          identifier to the specified
 *                          <code>graph_table</code> so the graph can be viewed
 *                          via WMS; for social and non-geospatial graphs, the
 *                          'EDGE_WKTLINE' column identifier will be populated
 *                          with spatial coordinates derived from a flattening
 *                          layout algorithm so the graph can still be viewed.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'save_persist': If set to
 *                          <code>true</code>, the graph will be saved in the
 *                          persist directory (see the <a
 *                          href="../../../config/" target="_top">config
 *                          reference</a> for more information). If set to
 *                          <code>false</code>, the graph will be removed when
 *                          the graph server is shutdown.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'add_table_monitor': Adds a table
 *                          monitor to every table used in the creation of the
 *                          graph; this table monitor will trigger the graph to
 *                          update dynamically upon inserts to the source
 *                          table(s). Note that upon database restart, if
 *                          <code>save_persist</code> is also set to
 *                          <code>true</code>, the graph will be fully
 *                          reconstructed and the table monitors will be
 *                          reattached. For more details on table monitors, see
 *                          {@linkcode GPUdb#create_table_monitor}.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'graph_table': If specified, the
 *                          created graph is also created as a table with the
 *                          given name, in [schema_name.]table_name format,
 *                          using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a> and meeting
 *                          <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>.  This
 *                          table will have the following identifier columns:
 *                          'EDGE_ID', 'EDGE_NODE1_ID', 'EDGE_NODE2_ID'. If
 *                          left blank, no table is created.  The default value
 *                          is ''.
 *                                  <li> 'remove_label_only': When RESTRICTIONS
 *                          on labeled entities requested, if set to true this
 *                          will NOT delete the entity but only the label
 *                          associated with the entity. Otherwise (default),
 *                          it'll delete the label AND the entity.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'add_turns': Adds dummy 'pillowed'
 *                          edges around intersection nodes where there are
 *                          more than three edges so that additional weight
 *                          penalties can be imposed by the solve endpoints.
 *                          (increases the total number of edges).
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'turn_angle': Value in degrees
 *                          modifies the thresholds for attributing right,
 *                          left, sharp turns, and intersections. It is the
 *                          vertical deviation angle from the incoming edge to
 *                          the intersection node. The larger the value, the
 *                          larger the threshold for sharp turns and
 *                          intersections; the smaller the value, the larger
 *                          the threshold for right and left turns; 0 <
 *                          turn_angle < 90.  The default value is '60'.
 *                                  <li> 'use_rtree': Use an range tree
 *                          structure to accelerate and improve the accuracy of
 *                          snapping, especially to edges.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.modify_graph = function(graph_name, nodes, edges, weights, restrictions, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.modify_graph(graph_name, nodes, edges, weights, restrictions, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        nodes: nodes,
        edges: edges,
        weights: weights,
        restrictions: restrictions,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/modify/graph", actual_request, callback);
};

/**
 * Employs a topological query on a network graph generated a-priori by
 * {@linkcode GPUdb#create_graph} and returns a list of adjacent edge(s) or
 * node(s),
 * also known as an adjacency list, depending on what's been provided to the
 * endpoint; providing edges will return nodes and providing nodes will return
 * edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to <code>queries</code>. This field can be
 * populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See
 * <a href="../../../graph_solver/network_graph_solver/#query-identifiers"
 * target="_top">Query Identifiers</a>
 * for more information.
 * <p>
 * To return the adjacency list in the response, leave
 * <code>adjacency_table</code>
 * empty.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph-query" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.query_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.query_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        queries: request.queries,
        restrictions: (request.restrictions !== undefined && request.restrictions !== null) ? request.restrictions : [],
        adjacency_table: (request.adjacency_table !== undefined && request.adjacency_table !== null) ? request.adjacency_table : "",
        rings: (request.rings !== undefined && request.rings !== null) ? request.rings : 1,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/query/graph", actual_request, callback);
};

/**
 * Employs a topological query on a network graph generated a-priori by
 * {@linkcode GPUdb#create_graph} and returns a list of adjacent edge(s) or
 * node(s),
 * also known as an adjacency list, depending on what's been provided to the
 * endpoint; providing edges will return nodes and providing nodes will return
 * edges.
 * <p>
 * To determine the node(s) or edge(s) adjacent to a value from a given column,
 * provide a list of values to <code>queries</code>. This field can be
 * populated with
 * column values from any table as long as the type is supported by the given
 * identifier. See
 * <a href="../../../graph_solver/network_graph_solver/#query-identifiers"
 * target="_top">Query Identifiers</a>
 * for more information.
 * <p>
 * To return the adjacency list in the response, leave
 * <code>adjacency_table</code>
 * empty.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph-query" target="_top">/match/graph
 * examples</a>
 * before using this endpoint.
 *
 * @param {String} graph_name  Name of the graph resource to query.
 * @param {String[]} queries  Nodes or edges to be queried specified using <a
 *                            href="../../../graph_solver/network_graph_solver/#query-identifiers"
 *                            target="_top">query identifiers</a>. Identifiers
 *                            can be used with existing column names, e.g.,
 *                            'table.column AS QUERY_NODE_ID', raw values,
 *                            e.g., '{0, 2} AS QUERY_NODE_ID', or expressions,
 *                            e.g., 'ST_MAKEPOINT(table.x, table.y) AS
 *                            QUERY_NODE_WKTPOINT'. Multiple values can be
 *                            provided as long as the same identifier is used
 *                            for all values. If using raw values in an
 *                            identifier combination, the number of values
 *                            specified must match across the combination.
 * @param {String[]} restrictions  Additional restrictions to apply to the
 *                                 nodes/edges of an existing graph.
 *                                 Restrictions must be specified using <a
 *                                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                                 target="_top">identifiers</a>; identifiers
 *                                 are grouped as <a
 *                                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                                 target="_top">combinations</a>. Identifiers
 *                                 can be used with existing column names,
 *                                 e.g., 'table.column AS
 *                                 RESTRICTIONS_EDGE_ID', expressions, e.g.,
 *                                 'column/2 AS RESTRICTIONS_VALUECOMPARED', or
 *                                 raw values, e.g., '{0, 0, 0, 1} AS
 *                                 RESTRICTIONS_ONOFFCOMPARED'. If using raw
 *                                 values in an identifier combination, the
 *                                 number of values specified must match across
 *                                 the combination.
 * @param {String} adjacency_table  Name of the table to store the resulting
 *                                  adjacencies, in [schema_name.]table_name
 *                                  format, using standard <a
 *                                  href="../../../concepts/tables/#table-name-resolution"
 *                                  target="_top">name resolution rules</a> and
 *                                  meeting <a
 *                                  href="../../../concepts/tables/#table-naming-criteria"
 *                                  target="_top">table naming criteria</a>.
 *                                  If left blank, the query results are
 *                                  instead returned in the response. If the
 *                                  'QUERY_TARGET_NODE_LABEL' <a
 *                                  href="../../../graph_solver/network_graph_solver/#query-identifiers"
 *                                  target="_top">query identifier</a> is used
 *                                  in <code>queries</code>, then two
 *                                  additional columns will be available:
 *                                  'PATH_ID' and 'RING_ID'. See <a
 *                                  href="../../../graph_solver/network_graph_solver/#using-labels"
 *                                  target="_top">Using Labels</a> for more
 *                                  information.
 * @param {Number} rings  Sets the number of rings around the node to query for
 *                        adjacency, with '1' being the edges directly attached
 *                        to the queried node. Also known as number of hops.
 *                        For example, if it is set to '2', the edge(s)
 *                        directly attached to the queried node(s) will be
 *                        returned; in addition, the edge(s) attached to the
 *                        node(s) attached to the initial ring of edge(s)
 *                        surrounding the queried node(s) will be returned. If
 *                        the value is set to '0', any nodes that meet the
 *                        criteria in <code>queries</code> and
 *                        <code>restrictions</code> will be returned. This
 *                        parameter is only applicable when querying nodes.
 * @param {Object} options  Additional parameters
 *                          <ul>
 *                                  <li> 'force_undirected': If set to
 *                          <code>true</code>, all inbound edges and outbound
 *                          edges relative to the node will be returned. If set
 *                          to <code>false</code>, only outbound edges relative
 *                          to the node will be returned. This parameter is
 *                          only applicable if the queried graph
 *                          <code>graph_name</code> is directed and when
 *                          querying nodes. Consult <a
 *                          href="../../../graph_solver/network_graph_solver/#directed-graphs"
 *                          target="_top">Directed Graphs</a> for more details.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'limit': When specified, limits the
 *                          number of query results. The size of the nodes
 *                          table will be limited by the <code>limit</code>
 *                          value.  The default value is an empty dict ( {} ).
 *                                  <li> 'output_wkt_path': If true then
 *                          concatenated wkt line segments will be added as the
 *                          WKT column of the adjacency table.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'and_labels': If set to
 *                          <code>true</code>, the result of the query has
 *                          entities that satisfy all of the target labels,
 *                          instead of any.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'server_id': Indicates which graph
 *                          server(s) to send the request to. Default is to
 *                          send to the server, amongst those containing the
 *                          corresponding graph, that has the most
 *                          computational bandwidth.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.query_graph = function(graph_name, queries, restrictions, adjacency_table, rings, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.query_graph(graph_name, queries, restrictions, adjacency_table, rings, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        queries: queries,
        restrictions: (restrictions !== undefined && restrictions !== null) ? restrictions : [],
        adjacency_table: (adjacency_table !== undefined && adjacency_table !== null) ? adjacency_table : "",
        rings: (rings !== undefined && rings !== null) ? rings : 1,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/query/graph", actual_request, callback);
};

/**
 * Rebalances an existing partitioned graph.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.repartition_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.repartition_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/repartition/graph", actual_request, callback);
};

/**
 * Rebalances an existing partitioned graph.

 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some <a href="../../../guide-tags/graph/" target="_top">graph
 * examples</a> before
 * using this endpoint.
 *
 * @param {String} graph_name  Name of the graph resource to rebalance.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'new_graph_name': If a non-empty value
 *                          is specified, the original graph will be kept
 *                          (non-default behaviour) and a new balanced graph
 *                          will be created under this given name.  When the
 *                          value is empty (default), the generated 'balanced'
 *                          graph will replace the original 'unbalanced'
 *                          graph under the same graph name.  The default value
 *                          is ''.
 *                                  <li> 'source_node': The distributed
 *                          shortest path solve is run from this source node to
 *                          all the nodes in the graph to create balaced
 *                          partitions using the iso-distance levels of the
 *                          solution.  The source node is selected by the
 *                          rebalance algorithm automatically (default case
 *                          when
 *                          the value is an empty string). Otherwise, the user
 *                          specified node is used as the source.  The default
 *                          value is ''.
 *                                  <li> 'sql_request_avro_json': The default
 *                          value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.repartition_graph = function(graph_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.repartition_graph(graph_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/repartition/graph", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.reserve_resource_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.reserve_resource_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        component: request.component,
        name: request.name,
        action: request.action,
        bytes_requested: (request.bytes_requested !== undefined && request.bytes_requested !== null) ? request.bytes_requested : 0,
        owner_id: (request.owner_id !== undefined && request.owner_id !== null) ? request.owner_id : 0,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/reserve/resource", actual_request, callback);
};

/**
 *
 * @param {String} component
 * @param {String} name
 * @param {String} action
 *                         Supported values:
 *                         <ul>
 *                                 <li> 'get_size'
 *                                 <li> 'notify_untiered'
 *                                 <li> 'tier'
 *                                 <li> 'evict'
 *                                 <li> 'delete'
 *                                 <li> 'change_owner'
 *                         </ul>
 * @param {Number} bytes_requested
 * @param {Number} owner_id
 * @param {Object} options
 *                          <ul>
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.reserve_resource = function(component, name, action, bytes_requested, owner_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.reserve_resource(component, name, action, bytes_requested, owner_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        component: component,
        name: name,
        action: action,
        bytes_requested: (bytes_requested !== undefined && bytes_requested !== null) ? bytes_requested : 0,
        owner_id: (owner_id !== undefined && owner_id !== null) ? owner_id : 0,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/reserve/resource", actual_request, callback);
};

/**
 * Revoke user or role the specified permission on the specified object.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        principal: (request.principal !== undefined && request.principal !== null) ? request.principal : "",
        object: request.object,
        object_type: request.object_type,
        permission: request.permission,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/revoke/permission", actual_request, callback);
};

/**
 * Revoke user or role the specified permission on the specified object.
 *
 * @param {String} principal  Name of the user or role for which the permission
 *                            is being revoked.  Must be an existing user or
 *                            role.
 * @param {String} object  Name of object permission is being revoked from.  It
 *                         is recommended to use a fully-qualified name when
 *                         possible.
 * @param {String} object_type  The type of object being revoked
 *                              Supported values:
 *                              <ul>
 *                                      <li> 'credential': Credential
 *                                      <li> 'datasink': Data Sink
 *                                      <li> 'datasource': Data Source
 *                                      <li> 'directory': KIFS File Directory
 *                                      <li> 'graph': A Graph object
 *                                      <li> 'proc': UDF Procedure
 *                                      <li> 'schema': Schema
 *                                      <li> 'sql_proc': SQL Procedure
 *                                      <li> 'system': System-level access
 *                                      <li> 'table': Database Table
 *                                      <li> 'table_monitor': Table monitor
 *                              </ul>
 * @param {String} permission  Permission being revoked.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'admin': Full read/write and
 *                             administrative access on the object.
 *                                     <li> 'connect': Connect access on the
 *                             given data source or data sink.
 *                                     <li> 'delete': Delete rows from tables.
 *                                     <li> 'execute': Ability to Execute the
 *                             Procedure object.
 *                                     <li> 'insert': Insert access to tables.
 *                                     <li> 'read': Ability to read, list and
 *                             use the object.
 *                                     <li> 'update': Update access to the
 *                             table.
 *                                     <li> 'user_admin': Access to administer
 *                             users and roles that do not have system_admin
 *                             permission.
 *                                     <li> 'write': Access to write, change
 *                             and delete objects.
 *                             </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'columns': Revoke table security from
 *                          these columns, comma-separated.  The default value
 *                          is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission = function(principal, object, object_type, permission, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission(principal, object, object_type, permission, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        principal: (principal !== undefined && principal !== null) ? principal : "",
        object: object,
        object_type: object_type,
        permission: permission,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/revoke/permission", actual_request, callback);
};

/**
 * Revokes a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_credential_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_credential_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        credential_name: request.credential_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/revoke/permission/credential", actual_request, callback);
};

/**
 * Revokes a <a
 * href="../../../security/sec_concepts/#security-concepts-permissions-credential"
 * target="_top">credential-level permission</a> from a user or role.
 *
 * @param {String} name  Name of the user or role from which the permission
 *                       will be revoked. Must be an existing user or role.
 * @param {String} permission  Permission to revoke from the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'credential_admin': Full read/write
 *                             and administrative access on the credential.
 *                                     <li> 'credential_read': Ability to read
 *                             and use the credential.
 *                             </ul>
 * @param {String} credential_name  Name of the credential on which the
 *                                  permission will be revoked. Must be an
 *                                  existing credential, or an empty string to
 *                                  revoke access on all credentials.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_credential = function(name, permission, credential_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_credential(name, permission, credential_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        credential_name: credential_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/revoke/permission/credential", actual_request, callback);
};

/**
 * Revokes a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_datasource_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_datasource_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        datasource_name: request.datasource_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/revoke/permission/datasource", actual_request, callback);
};

/**
 * Revokes a <a href="../../../concepts/data_sources/" target="_top">data
 * source</a> permission from a user or role.
 *
 * @param {String} name  Name of the user or role from which the permission
 *                       will be revoked. Must be an existing user or role.
 * @param {String} permission  Permission to revoke from the user or role
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'connect': Connect access on the
 *                             given data source
 *                             </ul>
 * @param {String} datasource_name  Name of the data source on which the
 *                                  permission will be revoked. Must be an
 *                                  existing data source, or an empty string to
 *                                  revoke permission from all data sources.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_datasource = function(name, permission, datasource_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_datasource(name, permission, datasource_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        datasource_name: datasource_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/revoke/permission/datasource", actual_request, callback);
};

/**
 * Revokes a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_directory_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_directory_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        directory_name: request.directory_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/revoke/permission/directory", actual_request, callback);
};

/**
 * Revokes a <a href="../../../tools/kifs/" target="_top">KiFS</a>
 * directory-level permission from a user or role.
 *
 * @param {String} name  Name of the user or role from which the permission
 *                       will be revoked. Must be an existing user or role.
 * @param {String} permission  Permission to revoke from the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'directory_read': For files in the
 *                             directory, access to list files, download files,
 *                             or use files in server side functions
 *                                     <li> 'directory_write': Access to upload
 *                             files to, or delete files from, the directory. A
 *                             user or role with write access automatically has
 *                             read acceess
 *                             </ul>
 * @param {String} directory_name  Name of the KiFS directory to which the
 *                                 permission revokes access
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_directory = function(name, permission, directory_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_directory(name, permission, directory_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        directory_name: directory_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/revoke/permission/directory", actual_request, callback);
};

/**
 * Revokes a proc-level permission from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        proc_name: request.proc_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/revoke/permission/proc", actual_request, callback);
};

/**
 * Revokes a proc-level permission from a user or role.
 *
 * @param {String} name  Name of the user or role from which the permission
 *                       will be revoked. Must be an existing user or role.
 * @param {String} permission  Permission to revoke from the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'proc_execute': Execute access to
 *                             the proc.
 *                             </ul>
 * @param {String} proc_name  Name of the proc to which the permission grants
 *                            access. Must be an existing proc, or an empty
 *                            string if the permission grants access to all
 *                            procs.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_proc = function(name, permission, proc_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_proc(name, permission, proc_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        proc_name: proc_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/revoke/permission/proc", actual_request, callback);
};

/**
 * Revokes a system-level permission from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_system_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_system_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/revoke/permission/system", actual_request, callback);
};

/**
 * Revokes a system-level permission from a user or role.
 *
 * @param {String} name  Name of the user or role from which the permission
 *                       will be revoked. Must be an existing user or role.
 * @param {String} permission  Permission to revoke from the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'system_admin': Full access to all
 *                             data and system functions.
 *                                     <li> 'system_user_admin': Access to
 *                             administer users and roles that do not have
 *                             system_admin permission.
 *                                     <li> 'system_write': Read and write
 *                             access to all tables.
 *                                     <li> 'system_read': Read-only access to
 *                             all tables.
 *                             </ul>
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_system = function(name, permission, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_system(name, permission, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/revoke/permission/system", actual_request, callback);
};

/**
 * Revokes a table-level permission from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        permission: request.permission,
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/revoke/permission/table", actual_request, callback);
};

/**
 * Revokes a table-level permission from a user or role.
 *
 * @param {String} name  Name of the user or role from which the permission
 *                       will be revoked. Must be an existing user or role.
 * @param {String} permission  Permission to revoke from the user or role.
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'table_admin': Full read/write and
 *                             administrative access to the table.
 *                                     <li> 'table_insert': Insert access to
 *                             the table.
 *                                     <li> 'table_update': Update access to
 *                             the table.
 *                                     <li> 'table_delete': Delete access to
 *                             the table.
 *                                     <li> 'table_read': Read access to the
 *                             table.
 *                             </ul>
 * @param {String} table_name  Name of the table to which the permission grants
 *                             access, in [schema_name.]table_name format,
 *                             using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing table, view or schema.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'columns': Apply security to these
 *                          columns, comma-separated.  The default value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_permission_table = function(name, permission, table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_permission_table(name, permission, table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        permission: permission,
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/revoke/permission/table", actual_request, callback);
};

/**
 * Revokes membership in a role from a user or role.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_role_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_role_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        role: request.role,
        member: request.member,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/revoke/role", actual_request, callback);
};

/**
 * Revokes membership in a role from a user or role.
 *
 * @param {String} role  Name of the role in which membership will be revoked.
 *                       Must be an existing role.
 * @param {String} member  Name of the user or role that will be revoked
 *                         membership in <code>role</code>. Must be an existing
 *                         user or role.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.revoke_role = function(role, member, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.revoke_role(role, member, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        role: role,
        member: member,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/revoke/role", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.show_container_registry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_container_registry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        registry_name: request.registry_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/container/registry", actual_request, callback);
};

/**
 *
 * @param {String} registry_name
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.show_container_registry = function(registry_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_container_registry(registry_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        registry_name: registry_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/container/registry", actual_request, callback);
};

/**
 * Shows information about a specified <a href="../../../concepts/credentials/"
 * target="_top">credential</a> or all credentials.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_credential_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_credential_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        credential_name: request.credential_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/credential", actual_request, callback);
};

/**
 * Shows information about a specified <a href="../../../concepts/credentials/"
 * target="_top">credential</a> or all credentials.
 *
 * @param {String} credential_name  Name of the credential on which to retrieve
 *                                  information. The name must refer to a
 *                                  currently existing credential. If '*' is
 *                                  specified, information about all
 *                                  credentials will be returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_credential = function(credential_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_credential(credential_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        credential_name: credential_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/credential", actual_request, callback);
};

/**
 * Shows information about a specified <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a> or all data sinks.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_datasink_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_datasink_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/datasink", actual_request, callback);
};

/**
 * Shows information about a specified <a href="../../../concepts/data_sinks/"
 * target="_top">data sink</a> or all data sinks.
 *
 * @param {String} name  Name of the data sink for which to retrieve
 *                       information. The name must refer to a currently
 *                       existing data sink. If '*' is specified, information
 *                       about all data sinks will be returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_datasink = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_datasink(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/datasink", actual_request, callback);
};

/**
 * Shows information about a specified <a
 * href="../../../concepts/data_sources/" target="_top">data source</a> or all
 * data sources.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_datasource_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_datasource_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/datasource", actual_request, callback);
};

/**
 * Shows information about a specified <a
 * href="../../../concepts/data_sources/" target="_top">data source</a> or all
 * data sources.
 *
 * @param {String} name  Name of the data source for which to retrieve
 *                       information. The name must refer to a currently
 *                       existing data source. If '*' is specified, information
 *                       about all data sources will be returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_datasource = function(name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_datasource(name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/datasource", actual_request, callback);
};

/**
 * Shows information about directories in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used to show a single directory, or all
 * directories.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_directories_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_directories_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        directory_name: (request.directory_name !== undefined && request.directory_name !== null) ? request.directory_name : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/directories", actual_request, callback);
};

/**
 * Shows information about directories in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used to show a single directory, or all
 * directories.
 *
 * @param {String} directory_name  The KiFS directory name to show. If empty,
 *                                 shows all directories.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_directories = function(directory_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_directories(directory_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        directory_name: (directory_name !== undefined && directory_name !== null) ? directory_name : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/directories", actual_request, callback);
};

/**
 * Shows information about files in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used for individual files, or to show all
 * files in a given directory.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_files_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_files_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        paths: request.paths,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/files", actual_request, callback);
};

/**
 * Shows information about files in <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. Can be used for individual files, or to show all
 * files in a given directory.
 *
 * @param {String[]} paths  File paths to show. Each path can be a KiFS
 *                          directory name, or a full path to a KiFS file.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_files = function(paths, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_files(paths, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        paths: paths,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/files", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.show_functions_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_functions_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        names: request.names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/functions", actual_request, callback);
};

/**
 *
 * @param {String[]} names
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'properties':
 *                                  <li> 'show_scalar_functions':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'show_aggregate_functions':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'show_sql_procedures':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'show_user_defined_functions':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'show_cast_functions':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.show_functions = function(names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_functions(names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        names: names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/functions", actual_request, callback);
};

/**
 * Shows information and characteristics of graphs that exist on the graph
 * server.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: (request.graph_name !== undefined && request.graph_name !== null) ? request.graph_name : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/graph", actual_request, callback);
};

/**
 * Shows information and characteristics of graphs that exist on the graph
 * server.
 *
 * @param {String} graph_name  Name of the graph on which to retrieve
 *                             information. If left as the default value,
 *                             information about all graphs is returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'show_original_request': If set to
 *                          <code>true</code>, the request that was originally
 *                          used to create the graph is also returned as JSON.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'server_id': Indicates which graph
 *                          server(s) to send the request to. Default is to
 *                          send to get information about all the servers.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_graph = function(graph_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_graph(graph_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: (graph_name !== undefined && graph_name !== null) ? graph_name : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/graph", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.show_graph_grammar_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_graph_grammar_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/graph/grammar", actual_request, callback);
};

/**
 *
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.show_graph_grammar = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_graph_grammar(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/graph/grammar", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.show_model_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_model_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_names: (request.model_names !== undefined && request.model_names !== null) ? request.model_names : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/model", actual_request, callback);
};

/**
 *
 * @param {String[]} model_names
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.show_model = function(model_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_model(model_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        model_names: (model_names !== undefined && model_names !== null) ? model_names : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/model", actual_request, callback);
};

/**
 * Shows information about a proc.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: (request.proc_name !== undefined && request.proc_name !== null) ? request.proc_name : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/proc", actual_request, callback);
};

/**
 * Shows information about a proc.
 *
 * @param {String} proc_name  Name of the proc to show information about. If
 *                            specified, must be the name of a currently
 *                            existing proc. If not specified, information
 *                            about all procs will be returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'include_files': If set to
 *                          <code>true</code>, the files that make up the proc
 *                          will be returned. If set to <code>false</code>, the
 *                          files will not be returned.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_proc = function(proc_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_proc(proc_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        proc_name: (proc_name !== undefined && proc_name !== null) ? proc_name : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/proc", actual_request, callback);
};

/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@linkcode GPUdb#execute_proc}) and
 * data segment ID (each invocation of the proc command on a data segment is
 * assigned a data segment ID).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_proc_status_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_proc_status_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        run_id: (request.run_id !== undefined && request.run_id !== null) ? request.run_id : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/proc/status", actual_request, callback);
};

/**
 * Shows the statuses of running or completed proc instances. Results are
 * grouped by run ID (as returned from {@linkcode GPUdb#execute_proc}) and
 * data segment ID (each invocation of the proc command on a data segment is
 * assigned a data segment ID).
 *
 * @param {String} run_id  The run ID of a specific proc instance for which the
 *                         status will be returned. If a proc with a matching
 *                         run ID is not found, the response will be empty. If
 *                         not specified, the statuses of all executed proc
 *                         instances will be returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'clear_complete': If set to
 *                          <code>true</code>, if a proc instance has completed
 *                          (either successfully or unsuccessfully) then its
 *                          status will be cleared and no longer returned in
 *                          subsequent calls.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'run_tag': If <code>run_id</code> is
 *                          specified, return the status for a proc instance
 *                          that has a matching run ID and a matching run tag
 *                          that was provided to
 *                          {@linkcode GPUdb#execute_proc}. If
 *                          <code>run_id</code> is not specified, return
 *                          statuses for all proc instances where a matching
 *                          run tag was provided to
 *                          {@linkcode GPUdb#execute_proc}.  The default
 *                          value is ''.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_proc_status = function(run_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_proc_status(run_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        run_id: (run_id !== undefined && run_id !== null) ? run_id : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/proc/status", actual_request, callback);
};

/**
 * Returns information about the internal sub-components (tiered objects)
 * which use resources of the system. The request can either return results
 * from
 * actively used objects (default) or it can be used to query the status of the
 * objects of a given list of tables.
 * Returns detailed information about the requested resource objects.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_resource_objects_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_resource_objects_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/resource/objects", actual_request, callback);
};

/**
 * Returns information about the internal sub-components (tiered objects)
 * which use resources of the system. The request can either return results
 * from
 * actively used objects (default) or it can be used to query the status of the
 * objects of a given list of tables.
 * Returns detailed information about the requested resource objects.
 *
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'tiers': Comma-separated list of tiers
 *                          to query, leave blank for all tiers.
 *                                  <li> 'expression': An expression to filter
 *                          the returned objects. Expression is
 *                          limited to the following operators:
 *                          =,!=,<,<=,>,>=,+,-,*,AND,OR,LIKE. For details see
 *                          <a href="../../../concepts/expressions/"
 *                          target="_top">Expressions</a>. To use a more
 *                          complex expression, query the
 *                          ki_catalog.ki_tiered_objects table directly.
 *                                  <li> 'order_by': Single column to be sorted
 *                          by as well as the sort direction, e.g., 'size asc'.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'size'
 *                                  <li> 'id'
 *                                  <li> 'priority'
 *                                  <li> 'tier'
 *                                  <li> 'evictable'
 *                                  <li> 'owner_resource_group'
 *                          </ul>
 *                                  <li> 'limit': An integer indicating the
 *                          maximum number of results to be
 *                          returned, per rank, or (-1) to indicate that the
 *                          maximum number of results allowed by the server
 *                          should be returned.  The number of records returned
 *                          will never exceed the server's own limit,
 *                          defined by the <a
 *                          href="../../../config/#config-main-general"
 *                          target="_top">max_get_records_size</a> parameter in
 *                          the server
 *                          configuration.  The default value is '100'.
 *                                  <li> 'table_names': Comma-separated list of
 *                          tables to restrict the results to. Use '*' to show
 *                          all tables.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_resource_objects = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_resource_objects(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/resource/objects", actual_request, callback);
};

/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_resource_statistics_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_resource_statistics_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/resource/statistics", actual_request, callback);
};

/**
 * Requests various statistics for storage/memory tiers and resource groups.
 * Returns statistics on a per-rank basis.
 *
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_resource_statistics = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_resource_statistics(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/resource/statistics", actual_request, callback);
};

/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_resource_groups_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_resource_groups_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        names: request.names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/resourcegroups", actual_request, callback);
};

/**
 * Requests resource group properties.
 * Returns detailed information about the requested resource groups.
 *
 * @param {String[]} names  List of names of groups to be shown. A single entry
 *                          with an empty string returns all groups.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'show_default_values': If
 *                          <code>true</code> include values of fields that are
 *                          based on the default resource group.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'show_default_group': If
 *                          <code>true</code> include the default and system
 *                          resource groups in the response. This value
 *                          defaults to false if an explicit list of group
 *                          names is provided, and true otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'show_tier_usage': If
 *                          <code>true</code> include the resource group usage
 *                          on the worker ranks in the response.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_resource_groups = function(names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_resource_groups(names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        names: names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/resourcegroups", actual_request, callback);
};

/**
 * Retrieves information about a <a href="../../../concepts/schemas/"
 * target="_top">schema</a> (or all schemas), as specified in
 * <code>schema_name</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_schema_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_schema_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: request.schema_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/schema", actual_request, callback);
};

/**
 * Retrieves information about a <a href="../../../concepts/schemas/"
 * target="_top">schema</a> (or all schemas), as specified in
 * <code>schema_name</code>.
 *
 * @param {String} schema_name  Name of the schema for which to retrieve the
 *                              information. If blank, then info for all
 *                              schemas is returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>false</code> will return an error if the
 *                          provided <code>schema_name</code> does not exist.
 *                          If <code>true</code> then it will return an empty
 *                          result if the provided <code>schema_name</code>
 *                          does not exist.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_schema = function(schema_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_schema(schema_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        schema_name: schema_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/schema", actual_request, callback);
};

/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_security_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_security_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        names: request.names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/security", actual_request, callback);
};

/**
 * Shows security information relating to users and/or roles. If the caller is
 * not a system administrator, only information relating to the caller and
 * their roles is returned.
 *
 * @param {String[]} names  A list of names of users and/or roles about which
 *                          security information is requested. If none are
 *                          provided, information about all users and roles
 *                          will be returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_security = function(names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_security(names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        names: names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/security", actual_request, callback);
};

/**
 * Shows information about SQL procedures, including the full definition of
 * each requested procedure.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_sql_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_sql_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        procedure_name: (request.procedure_name !== undefined && request.procedure_name !== null) ? request.procedure_name : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/sql/proc", actual_request, callback);
};

/**
 * Shows information about SQL procedures, including the full definition of
 * each requested procedure.
 *
 * @param {String} procedure_name  Name of the procedure for which to retrieve
 *                                 the information. If blank, then information
 *                                 about all procedures is returned.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>true</code>, no error will be returned if the
 *                          requested procedure does not exist.  If
 *                          <code>false</code>, an error will be returned if
 *                          the requested procedure does not exist.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_sql_proc = function(procedure_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_sql_proc(procedure_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        procedure_name: (procedure_name !== undefined && procedure_name !== null) ? procedure_name : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/sql/proc", actual_request, callback);
};

/**
 * Retrieves the collected column statistics for the specified table(s).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_statistics_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_statistics_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/statistics", actual_request, callback);
};

/**
 * Retrieves the collected column statistics for the specified table(s).
 *
 * @param {String[]} table_names  Names of tables whose metadata will be
 *                                fetched, each in [schema_name.]table_name
 *                                format, using standard <a
 *                                href="../../../concepts/tables/#table-name-resolution"
 *                                target="_top">name resolution rules</a>.  All
 *                                provided tables must exist, or an error is
 *                                returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_statistics = function(table_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_statistics(table_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/statistics", actual_request, callback);
};

/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_properties_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_properties_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/properties", actual_request, callback);
};

/**
 * Returns server configuration and version related information to the caller.
 * The admin tool uses it to present server related information to the user.
 *
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'properties': A list of comma
 *                          separated names of properties requested. If not
 *                          specified, all properties will be returned.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_properties = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_properties(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/properties", actual_request, callback);
};

/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_status_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_status_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/status", actual_request, callback);
};

/**
 * Provides server configuration and health related status to the caller. The
 * admin tool uses it to present server related information to the user.
 *
 * @param {Object} options  Optional parameters, currently unused.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_status = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_status(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/status", actual_request, callback);
};

/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_timing_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_timing_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/timing", actual_request, callback);
};

/**
 * Returns the last 100 database requests along with the request timing and
 * internal job id. The admin tool uses it to present request timing
 * information to the user.
 *
 * @param {Object} options  Optional parameters, currently unused.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_timing = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_timing(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/timing", actual_request, callback);
};

/**
 * Retrieves detailed information about a table, view, or schema,
 * specified in <code>table_name</code>. If the supplied
 * <code>table_name</code> is a
 * schema the call can return information about either the schema itself or the
 * tables and views it contains. If <code>table_name</code> is empty,
 * information about
 * all schemas will be returned.
 * <p>
 * If the option <code>get_sizes</code> is set to
 * <code>true</code>, then the number of records
 * in each table is returned (in <code>sizes</code> and
 * <code>full_sizes</code>), along with the total number of objects across all
 * requested tables (in <code>total_size</code> and
 * <code>total_full_size</code>).
 * <p>
 * For a schema, setting the <code>show_children</code> option to
 * <code>false</code> returns only information
 * about the schema itself; setting <code>show_children</code> to
 * <code>true</code> returns a list of tables and
 * views contained in the schema, along with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and schema in the database, set
 * <code>table_name</code> to '*' and <code>show_children</code> to
 * <code>true</code>.  When doing this, the
 * returned <code>total_size</code> and <code>total_full_size</code> will not
 * include the sizes of
 * non-base tables (e.g., filters, views, joins, etc.).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/table", actual_request, callback);
};

/**
 * Retrieves detailed information about a table, view, or schema,
 * specified in <code>table_name</code>. If the supplied
 * <code>table_name</code> is a
 * schema the call can return information about either the schema itself or the
 * tables and views it contains. If <code>table_name</code> is empty,
 * information about
 * all schemas will be returned.
 * <p>
 * If the option <code>get_sizes</code> is set to
 * <code>true</code>, then the number of records
 * in each table is returned (in <code>sizes</code> and
 * <code>full_sizes</code>), along with the total number of objects across all
 * requested tables (in <code>total_size</code> and
 * <code>total_full_size</code>).
 * <p>
 * For a schema, setting the <code>show_children</code> option to
 * <code>false</code> returns only information
 * about the schema itself; setting <code>show_children</code> to
 * <code>true</code> returns a list of tables and
 * views contained in the schema, along with their corresponding detail.
 * <p>
 * To retrieve a list of every table, view, and schema in the database, set
 * <code>table_name</code> to '*' and <code>show_children</code> to
 * <code>true</code>.  When doing this, the
 * returned <code>total_size</code> and <code>total_full_size</code> will not
 * include the sizes of
 * non-base tables (e.g., filters, views, joins, etc.).
 *
 * @param {String} table_name  Name of the table for which to retrieve the
 *                             information, in [schema_name.]table_name format,
 *                             using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  If
 *                             blank, then returns information about all tables
 *                             and views.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'force_synchronous': If
 *                          <code>true</code> then the table sizes will wait
 *                          for read lock before returning.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'get_sizes': If <code>true</code> then
 *                          the number of records in each table, along with a
 *                          cumulative count, will be returned; blank,
 *                          otherwise.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'show_children': If
 *                          <code>table_name</code> is a schema, then
 *                          <code>true</code> will return information about the
 *                          tables and views in the schema, and
 *                          <code>false</code> will return information about
 *                          the schema itself. If <code>table_name</code> is a
 *                          table or view, <code>show_children</code> must be
 *                          <code>false</code>. If <code>table_name</code> is
 *                          empty, then <code>show_children</code> must be
 *                          <code>true</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'no_error_if_not_exists': If
 *                          <code>false</code> will return an error if the
 *                          provided <code>table_name</code> does not exist. If
 *                          <code>true</code> then it will return an empty
 *                          result.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'get_column_info': If
 *                          <code>true</code> then column info (memory usage,
 *                          etc) will be returned.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/table", actual_request, callback);
};

/**
 * Retrieves the user provided metadata for the specified tables.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_metadata_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_metadata_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/table/metadata", actual_request, callback);
};

/**
 * Retrieves the user provided metadata for the specified tables.
 *
 * @param {String[]} table_names  Names of tables whose metadata will be
 *                                fetched, in [schema_name.]table_name format,
 *                                using standard <a
 *                                href="../../../concepts/tables/#table-name-resolution"
 *                                target="_top">name resolution rules</a>.  All
 *                                provided tables must exist, or an error is
 *                                returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_metadata = function(table_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_metadata(table_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/table/metadata", actual_request, callback);
};

/**
 * Show table monitors and their properties. Table monitors are created using
 * {@linkcode GPUdb#create_table_monitor}.
 * Returns detailed information about existing table monitors.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_monitors_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_monitors_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        monitor_ids: request.monitor_ids,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/tablemonitors", actual_request, callback);
};

/**
 * Show table monitors and their properties. Table monitors are created using
 * {@linkcode GPUdb#create_table_monitor}.
 * Returns detailed information about existing table monitors.
 *
 * @param {String[]} monitor_ids  List of monitors to be shown. An empty list
 *                                or a single entry with an empty string
 *                                returns all table monitors.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_monitors = function(monitor_ids, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_monitors(monitor_ids, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        monitor_ids: monitor_ids,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/tablemonitors", actual_request, callback);
};

/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_tables_by_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_tables_by_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        label: request.label,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/tables/bytype", actual_request, callback);
};

/**
 * Gets names of the tables whose type matches the given criteria. Each table
 * has a particular type. This type comprises the schema and properties of the
 * table and sometimes a type label. This function allows a look up of the
 * existing tables based on full or partial type information. The operation is
 * synchronous.
 *
 * @param {String} type_id  Type id returned by a call to
 *                          {@linkcode GPUdb#create_type}.
 * @param {String} label  Optional user supplied label which can be used
 *                        instead of the type_id to retrieve all tables with
 *                        the given label.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_tables_by_type = function(type_id, label, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_tables_by_type(type_id, label, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        label: label,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/tables/bytype", actual_request, callback);
};

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_triggers_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_triggers_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_ids: request.trigger_ids,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/triggers", actual_request, callback);
};

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active.
 *
 * @param {String[]} trigger_ids  List of IDs of the triggers whose information
 *                                is to be retrieved. An empty list means
 *                                information will be retrieved on all active
 *                                triggers.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_triggers = function(trigger_ids, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_triggers(trigger_ids, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_ids: trigger_ids,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/triggers", actual_request, callback);
};

/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_types_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_types_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        label: request.label,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/types", actual_request, callback);
};

/**
 * Retrieves information for the specified data type ID or type label. For all
 * data types that match the input criteria, the database returns the type ID,
 * the type schema, the label (if available), and the type's column properties.
 *
 * @param {String} type_id  Type Id returned in response to a call to
 *                          {@linkcode GPUdb#create_type}.
 * @param {String} label  Option string that was supplied by user in a call to
 *                        {@linkcode GPUdb#create_type}.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'no_join_types': When set to 'true',
 *                          no join types will be included.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_types = function(type_id, label, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_types(type_id, label, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        label: label,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/types", actual_request, callback);
};

/**
 * Retrieves information about rendered videos.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_video_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_video_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        paths: request.paths,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/video", actual_request, callback);
};

/**
 * Retrieves information about rendered videos.
 *
 * @param {String[]} paths  The fully-qualified <a href="../../../tools/kifs/"
 *                          target="_top">KiFS</a> paths for the videos to
 *                          show. If empty, shows all videos.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_video = function(paths, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_video(paths, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        paths: paths,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/video", actual_request, callback);
};

/**
 * Solves an existing graph for a type of problem (e.g., shortest path,
 * page rank, travelling salesman, etc.) using source nodes, destination nodes,
 * and
 * additional, optional weights and restrictions.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph-solve" target="_top">/solve/graph
 * examples</a>
 * before using this endpoint.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.solve_graph_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.solve_graph_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        weights_on_edges: (request.weights_on_edges !== undefined && request.weights_on_edges !== null) ? request.weights_on_edges : [],
        restrictions: (request.restrictions !== undefined && request.restrictions !== null) ? request.restrictions : [],
        solver_type: (request.solver_type !== undefined && request.solver_type !== null) ? request.solver_type : "SHORTEST_PATH",
        source_nodes: (request.source_nodes !== undefined && request.source_nodes !== null) ? request.source_nodes : [],
        destination_nodes: (request.destination_nodes !== undefined && request.destination_nodes !== null) ? request.destination_nodes : [],
        solution_table: (request.solution_table !== undefined && request.solution_table !== null) ? request.solution_table : "graph_solutions",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/solve/graph", actual_request, callback);
};

/**
 * Solves an existing graph for a type of problem (e.g., shortest path,
 * page rank, travelling salesman, etc.) using source nodes, destination nodes,
 * and
 * additional, optional weights and restrictions.
 * <p>
 * IMPORTANT: It's highly recommended that you review the
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * concepts documentation, the
 * <a href="../../../guides/graph_rest_guide/" target="_top">Graph REST
 * Tutorial</a>,
 * and/or some
 * <a href="../../../guide-tags/graph-solve" target="_top">/solve/graph
 * examples</a>
 * before using this endpoint.
 *
 * @param {String} graph_name  Name of the graph resource to solve.
 * @param {String[]} weights_on_edges  Additional weights to apply to the edges
 *                                     of an existing
 *                                     graph. Weights must be specified using
 *                                     <a
 *                                     href="../../../graph_solver/network_graph_solver/#identifiers"
 *                                     target="_top">identifiers</a>;
 *                                     identifiers are grouped as
 *                                     <a
 *                                     href="../../../graph_solver/network_graph_solver/#id-combos"
 *                                     target="_top">combinations</a>.
 *                                     Identifiers can be used with existing
 *                                     column names, e.g.,
 *                                     'table.column AS WEIGHTS_EDGE_ID',
 *                                     expressions, e.g.,
 *                                     'ST_LENGTH(wkt) AS
 *                                     WEIGHTS_VALUESPECIFIED', or constant
 *                                     values, e.g.,
 *                                     '{4, 15, 2} AS WEIGHTS_VALUESPECIFIED'.
 *                                     Any provided weights will be added
 *                                     (in the case of
 *                                     'WEIGHTS_VALUESPECIFIED') to or
 *                                     multiplied with
 *                                     (in the case of
 *                                     'WEIGHTS_FACTORSPECIFIED') the existing
 *                                     weight(s). If using
 *                                     constant values in an identifier
 *                                     combination, the number of values
 *                                     specified
 *                                     must match across the combination.
 * @param {String[]} restrictions  Additional restrictions to apply to the
 *                                 nodes/edges of an
 *                                 existing graph. Restrictions must be
 *                                 specified using
 *                                 <a
 *                                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                                 target="_top">identifiers</a>;
 *                                 identifiers are grouped as
 *                                 <a
 *                                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                                 target="_top">combinations</a>.
 *                                 Identifiers can be used with existing column
 *                                 names, e.g.,
 *                                 'table.column AS RESTRICTIONS_EDGE_ID',
 *                                 expressions, e.g.,
 *                                 'column/2 AS RESTRICTIONS_VALUECOMPARED', or
 *                                 constant values, e.g.,
 *                                 '{0, 0, 0, 1} AS
 *                                 RESTRICTIONS_ONOFFCOMPARED'. If using
 *                                 constant values in an
 *                                 identifier combination, the number of values
 *                                 specified must match across the
 *                                 combination. If remove_previous_restrictions
 *                                 option is set
 *                                 to true, any
 *                                 provided restrictions will replace the
 *                                 existing restrictions. Otherwise, any
 *                                 provided
 *                                 restrictions will be added (in the case of
 *                                 'RESTRICTIONS_VALUECOMPARED') to or
 *                                 replaced (in the case of
 *                                 'RESTRICTIONS_ONOFFCOMPARED').
 * @param {String} solver_type  The type of solver to use for the graph.
 *                              Supported values:
 *                              <ul>
 *                                      <li> 'SHORTEST_PATH': Solves for the
 *                              optimal (shortest) path based on weights and
 *                              restrictions from one source to destinations
 *                              nodes. Also known as the Dijkstra solver.
 *                                      <li> 'PAGE_RANK': Solves for the
 *                              probability of each destination node being
 *                              visited based on the links of the graph
 *                              topology. Weights are not required to use this
 *                              solver.
 *                                      <li> 'PROBABILITY_RANK': Solves for the
 *                              transitional probability (Hidden Markov) for
 *                              each node based on the weights (probability
 *                              assigned over given edges).
 *                                      <li> 'CENTRALITY': Solves for the
 *                              degree of a node to depict how many pairs of
 *                              individuals that would have to go through the
 *                              node to reach one another in the minimum number
 *                              of hops. Also known as betweenness.
 *                                      <li> 'MULTIPLE_ROUTING': Solves for
 *                              finding the minimum cost cumulative path for a
 *                              round-trip starting from the given source and
 *                              visiting each given destination node once then
 *                              returning to the source. Also known as the
 *                              travelling salesman problem.
 *                                      <li> 'INVERSE_SHORTEST_PATH': Solves
 *                              for finding the optimal path cost for each
 *                              destination node to route to the source node.
 *                              Also known as inverse Dijkstra or the service
 *                              man routing problem.
 *                                      <li> 'BACKHAUL_ROUTING': Solves for
 *                              optimal routes that connect remote asset nodes
 *                              to the fixed (backbone) asset nodes.
 *                                      <li> 'ALLPATHS': Solves for paths that
 *                              would give costs between max and min solution
 *                              radia - Make sure to limit by the
 *                              'max_solution_targets' option. Min cost shoudl
 *                              be >= shortest_path cost.
 *                                      <li> 'STATS_ALL': Solves for graph
 *                              statistics such as graph diameter, longest
 *                              pairs, vertex valences, topology numbers,
 *                              average and max cluster sizes, etc.
 *                                      <li> 'CLOSENESS': Solves for the
 *                              centrality closeness score per node as the sum
 *                              of the inverse shortest path costs to all nodes
 *                              in the graph.
 *                              </ul>
 *                              The default value is 'SHORTEST_PATH'.
 * @param {String[]} source_nodes  It can be one of the nodal identifiers -
 *                                 e.g: 'NODE_WKTPOINT' for source nodes. For
 *                                 <code>BACKHAUL_ROUTING</code>, this list
 *                                 depicts the fixed assets.
 * @param {String[]} destination_nodes  It can be one of the nodal identifiers
 *                                      - e.g: 'NODE_WKTPOINT' for destination
 *                                      (target) nodes. For
 *                                      <code>BACKHAUL_ROUTING</code>, this
 *                                      list depicts the remote assets.
 * @param {String} solution_table  Name of the table to store the solution, in
 *                                 [schema_name.]table_name format, using
 *                                 standard <a
 *                                 href="../../../concepts/tables/#table-name-resolution"
 *                                 target="_top">name resolution rules</a>.
 * @param {Object} options  Additional parameters
 *                          <ul>
 *                                  <li> 'max_solution_radius': For
 *                          <code>ALLPATHS</code>, <code>SHORTEST_PATH</code>
 *                          and <code>INVERSE_SHORTEST_PATH</code> solvers
 *                          only. Sets the maximum solution cost radius, which
 *                          ignores the <code>destination_nodes</code> list and
 *                          instead outputs the nodes within the radius sorted
 *                          by ascending cost. If set to '0.0', the setting is
 *                          ignored.  The default value is '0.0'.
 *                                  <li> 'min_solution_radius': For
 *                          <code>ALLPATHS</code>, <code>SHORTEST_PATH</code>
 *                          and <code>INVERSE_SHORTEST_PATH</code> solvers
 *                          only. Applicable only when
 *                          <code>max_solution_radius</code> is set. Sets the
 *                          minimum solution cost radius, which ignores the
 *                          <code>destination_nodes</code> list and instead
 *                          outputs the nodes within the radius sorted by
 *                          ascending cost. If set to '0.0', the setting is
 *                          ignored.  The default value is '0.0'.
 *                                  <li> 'max_solution_targets': For
 *                          <code>ALLPATHS</code>, <code>SHORTEST_PATH</code>
 *                          and <code>INVERSE_SHORTEST_PATH</code> solvers
 *                          only. Sets the maximum number of solution targets,
 *                          which ignores the <code>destination_nodes</code>
 *                          list and instead outputs no more than n number of
 *                          nodes sorted by ascending cost where n is equal to
 *                          the setting value. If set to 0, the setting is
 *                          ignored.  The default value is '1000'.
 *                                  <li> 'uniform_weights': When specified,
 *                          assigns the given value to all the edges in the
 *                          graph. Note that weights provided in
 *                          <code>weights_on_edges</code> will override this
 *                          value.
 *                                  <li> 'left_turn_penalty': This will add an
 *                          additonal weight over the edges labelled as 'left
 *                          turn' if the 'add_turn' option parameter of the
 *                          {@linkcode GPUdb#create_graph} was invoked at
 *                          graph creation.  The default value is '0.0'.
 *                                  <li> 'right_turn_penalty': This will add an
 *                          additonal weight over the edges labelled as' right
 *                          turn' if the 'add_turn' option parameter of the
 *                          {@linkcode GPUdb#create_graph} was invoked at
 *                          graph creation.  The default value is '0.0'.
 *                                  <li> 'intersection_penalty': This will add
 *                          an additonal weight over the edges labelled as
 *                          'intersection' if the 'add_turn' option parameter
 *                          of the {@linkcode GPUdb#create_graph} was invoked
 *                          at graph creation.  The default value is '0.0'.
 *                                  <li> 'sharp_turn_penalty': This will add an
 *                          additonal weight over the edges labelled as 'sharp
 *                          turn' or 'u-turn' if the 'add_turn' option
 *                          parameter of the {@linkcode GPUdb#create_graph}
 *                          was invoked at graph creation.  The default value
 *                          is '0.0'.
 *                                  <li> 'num_best_paths': For
 *                          <code>MULTIPLE_ROUTING</code> solvers only; sets
 *                          the number of shortest paths computed from each
 *                          node. This is the heuristic criterion. Default
 *                          value of zero allows the number to be computed
 *                          automatically by the solver. The user may want to
 *                          override this parameter to speed-up the solver.
 *                          The default value is '0'.
 *                                  <li> 'max_num_combinations': For
 *                          <code>MULTIPLE_ROUTING</code> solvers only; sets
 *                          the cap on the combinatorial sequences generated.
 *                          If the default value of two millions is overridden
 *                          to a lesser value, it can potentially speed up the
 *                          solver.  The default value is '2000000'.
 *                                  <li> 'output_edge_path': If true then
 *                          concatenated edge ids will be added as the EDGE
 *                          path column of the solution table for each source
 *                          and target pair in shortest path solves.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'output_wkt_path': If true then
 *                          concatenated wkt line segments will be added as the
 *                          Wktroute column of the solution table for each
 *                          source and target pair in shortest path solves.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'server_id': Indicates which graph
 *                          server(s) to send the request to. Default is to
 *                          send to the server, amongst those containing the
 *                          corresponding graph, that has the most
 *                          computational bandwidth. For SHORTEST_PATH solver
 *                          type, the input is split amongst the server
 *                          containing the corresponding graph.
 *                                  <li> 'convergence_limit': For
 *                          <code>PAGE_RANK</code> solvers only; Maximum
 *                          percent relative threshold on the pagerank scores
 *                          of each node between consecutive iterations to
 *                          satisfy convergence. Default value is 1 (one)
 *                          percent.  The default value is '1.0'.
 *                                  <li> 'max_iterations': For
 *                          <code>PAGE_RANK</code> solvers only; Maximum number
 *                          of pagerank iterations for satisfying convergence.
 *                          Default value is 100.  The default value is '100'.
 *                                  <li> 'max_runs': For all
 *                          <code>CENTRALITY</code> solvers only; Sets the
 *                          maximum number of shortest path runs; maximum
 *                          possible value is the number of nodes in the graph.
 *                          Default value of 0 enables this value to be auto
 *                          computed by the solver.  The default value is '0'.
 *                                  <li> 'output_clusters': For
 *                          <code>STATS_ALL</code> solvers only; the cluster
 *                          index for each node will be inserted as an
 *                          additional column in the output.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': An additional column 'CLUSTER'
 *                          will be added for each node
 *                                  <li> 'false': No extra cluster info per
 *                          node will be available in the output
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'solve_heuristic': Specify heuristic
 *                          search criterion only for the geo graphs and
 *                          shortest path solves towards a single target
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'astar': Employs A-STAR heuristics to
 *                          speed up the shortest path traversal
 *                                  <li> 'none': No heuristics are applied
 *                          </ul>
 *                          The default value is 'none'.
 *                                  <li> 'astar_radius': For path solvers only
 *                          when 'solve_heuristic' option is 'astar'. The
 *                          shortest path traversal front includes nodes only
 *                          within this radius (kilometers) as it moves towards
 *                          the target location.  The default value is '70'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.solve_graph = function(graph_name, weights_on_edges, restrictions, solver_type, source_nodes, destination_nodes, solution_table, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.solve_graph(graph_name, weights_on_edges, restrictions, solver_type, source_nodes, destination_nodes, solution_table, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        weights_on_edges: (weights_on_edges !== undefined && weights_on_edges !== null) ? weights_on_edges : [],
        restrictions: (restrictions !== undefined && restrictions !== null) ? restrictions : [],
        solver_type: (solver_type !== undefined && solver_type !== null) ? solver_type : "SHORTEST_PATH",
        source_nodes: (source_nodes !== undefined && source_nodes !== null) ? source_nodes : [],
        destination_nodes: (destination_nodes !== undefined && destination_nodes !== null) ? destination_nodes : [],
        solution_table: (solution_table !== undefined && solution_table !== null) ? solution_table : "graph_solutions",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/solve/graph", actual_request, callback);
};

/**
 * Runs multiple predicate-based updates in a single call.  With the
 * list of given expressions, any matching record's column values will be
 * updated
 * as provided in <code>new_values_maps</code>.  There is also an optional
 * 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record,
 * then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only
 * 'pure primary key' predicates are allowed when updating primary key values.
 * If
 * the primary key for a table is the column 'attr1', then the operation will
 * only
 * accept predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then
 * this operation will only accept predicates of the form:
 * "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns
 * must appear in an equality predicate in the expressions.  Furthermore each
 * 'pure primary key' predicate must be unique within a given request.  These
 * restrictions can be removed by utilizing some available options through
 * <code>options</code>.
 * <p>
 * The <code>update_on_existing_pk</code> option specifies the record
 * collision policy for tables with a <a
 * href="../../../concepts/tables/#primary-keys" target="_top">primary key</a>,
 * and
 * is ignored on tables with no primary key.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        expressions: request.expressions,
        new_values_maps: request.new_values_maps,
        records_to_insert: (request.records_to_insert !== undefined && request.records_to_insert !== null) ? request.records_to_insert : [],
        records_to_insert_str: (request.data !== undefined && request.data !== null) ? GPUdb.encode(request.data) : [],
        record_encoding: (request.record_encoding !== undefined && request.record_encoding !== null) ? request.record_encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/update/records", actual_request, callback);
};

/**
 * Runs multiple predicate-based updates in a single call.  With the
 * list of given expressions, any matching record's column values will be
 * updated
 * as provided in <code>new_values_maps</code>.  There is also an optional
 * 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record,
 * then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * result view.
 * <p>
 * This operation can update primary key values.  By default only
 * 'pure primary key' predicates are allowed when updating primary key values.
 * If
 * the primary key for a table is the column 'attr1', then the operation will
 * only
 * accept predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then
 * this operation will only accept predicates of the form:
 * "(attr1 == 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns
 * must appear in an equality predicate in the expressions.  Furthermore each
 * 'pure primary key' predicate must be unique within a given request.  These
 * restrictions can be removed by utilizing some available options through
 * <code>options</code>.
 * <p>
 * The <code>update_on_existing_pk</code> option specifies the record
 * collision policy for tables with a <a
 * href="../../../concepts/tables/#primary-keys" target="_top">primary key</a>,
 * and
 * is ignored on tables with no primary key.
 *
 * @param {String} table_name  Name of table to be updated, in
 *                             [schema_name.]table_name format, using standard
 *                             <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be a currently existing table and not a view.
 * @param {String[]} expressions  A list of the actual predicates, one for each
 *                                update; format should follow the guidelines
 *                                [here]{@linkcode GPUdb#filter}.
 * @param {Object[]} new_values_maps  List of new values for the matching
 *                                    records.  Each element is a map with
 *                                    (key, value) pairs where the keys are the
 *                                    names of the columns whose values are to
 *                                    be updated; the values are the new
 *                                    values.  The number of elements in the
 *                                    list should match the length of
 *                                    <code>expressions</code>.
 * @param {Object[]} data  An optional list of JSON encoded objects to insert,
 *                         one for each update, to be added if the particular
 *                         update did not match any objects.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'global_expression': An optional
 *                          global expression to reduce the search space of the
 *                          predicates listed in <code>expressions</code>.  The
 *                          default value is ''.
 *                                  <li> 'bypass_safety_checks': When set to
 *                          <code>true</code>, all predicates are available for
 *                          primary key updates.  Keep in mind that it is
 *                          possible to destroy data in this case, since a
 *                          single predicate may match multiple objects
 *                          (potentially all of records of a table), and then
 *                          updating all of those records to have the same
 *                          primary key will, due to the primary key uniqueness
 *                          constraints, effectively delete all but one of
 *                          those updated records.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'update_on_existing_pk': Specifies the
 *                          record collision policy for tables with a <a
 *                          href="../../../concepts/tables/#primary-keys"
 *                          target="_top">primary key</a> when updating columns
 *                          of the <a
 *                          href="../../../concepts/tables/#primary-keys"
 *                          target="_top">primary key</a> or inserting new
 *                          records.  If <code>true</code>, existing records
 *                          with primary key values that match those of a
 *                          record being updated or inserted will be replaced
 *                          by the updated and new records.  If
 *                          <code>false</code>, existing records with matching
 *                          primary key values will remain unchanged, and the
 *                          updated or new records with primary key values that
 *                          match those of existing records will be discarded.
 *                          If the specified table does not have a primary key,
 *                          then this option has no effect.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': Overwrite existing records
 *                          when updated and inserted records have the same
 *                          primary keys
 *                                  <li> 'false': Discard updated and inserted
 *                          records when the same primary keys already exist
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'update_partition': Force qualifying
 *                          records to be deleted and reinserted so their
 *                          partition membership will be reevaluated.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'truncate_strings': If set to
 *                          <code>true</code>, any strings which are too long
 *                          for their charN string fields will be truncated to
 *                          fit.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'use_expressions_in_new_values_maps':
 *                          When set to <code>true</code>, all new values in
 *                          <code>new_values_maps</code> are considered as
 *                          expression values. When set to <code>false</code>,
 *                          all new values in <code>new_values_maps</code> are
 *                          considered as constants.  NOTE:  When
 *                          <code>true</code>, string constants will need to be
 *                          quoted to avoid being evaluated as expressions.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'record_id': ID of a single record to
 *                          be updated (returned in the call to
 *                          {@linkcode GPUdb#insert_records} or
 *                          {@linkcode GPUdb#get_records_from_collection}).
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records = function(table_name, expressions, new_values_maps, data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records(table_name, expressions, new_values_maps, data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        expressions: expressions,
        new_values_maps: new_values_maps,
        records_to_insert: [],
        records_to_insert_str: GPUdb.encode(data),
        record_encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/update/records", actual_request, callback);
};

/**
 * Updates the view specified by <code>table_name</code> to include full
 * series (track) information from the <code>world_table_name</code> for the
 * series
 * (tracks) present in the <code>view_name</code>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        world_table_name: request.world_table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        reserved: (request.reserved !== undefined && request.reserved !== null) ? request.reserved : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/update/records/byseries", actual_request, callback);
};

/**
 * Updates the view specified by <code>table_name</code> to include full
 * series (track) information from the <code>world_table_name</code> for the
 * series
 * (tracks) present in the <code>view_name</code>.
 *
 * @param {String} table_name  Name of the view on which the update operation
 *                             will be performed, in [schema_name.]view_name
 *                             format, using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.  Must
 *                             be an existing view.
 * @param {String} world_table_name  Name of the table containing the complete
 *                                   series (track) information, in
 *                                   [schema_name.]table_name format, using
 *                                   standard <a
 *                                   href="../../../concepts/tables/#table-name-resolution"
 *                                   target="_top">name resolution rules</a>.
 * @param {String} view_name  Name of the view containing the series (tracks)
 *                            which have to be updated, in
 *                            [schema_name.]view_name format, using standard <a
 *                            href="../../../concepts/tables/#table-name-resolution"
 *                            target="_top">name resolution rules</a>.
 * @param {String[]} reserved
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_by_series = function(table_name, world_table_name, view_name, reserved, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_by_series(table_name, world_table_name, view_name, reserved, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        world_table_name: world_table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        reserved: (reserved !== undefined && reserved !== null) ? reserved : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/update/records/byseries", actual_request, callback);
};

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. There are
 * two methods for uploading files: load files in their entirety, or load files
 * in
 * parts. The latter is recommeded for files of approximately 60 MB or larger.
 * <p>
 * To upload files in their entirety, populate <code>file_names</code> with the
 * file
 * names to upload into on KiFS, and their respective byte content in
 * <code>file_data</code>.
 * <p>
 * Multiple steps are involved when uploading in multiple parts. Only one file
 * at a
 * time can be uploaded in this manner. A user-provided UUID is utilized to tie
 * all
 * the upload steps together for a given file.  To upload a file in multiple
 * parts:
 * <p>
 * 1. Provide the file name in <code>file_names</code>, the UUID in
 *    the <code>multipart_upload_uuid</code> key in <code>options</code>, and
 *    a <code>multipart_operation</code> value of
 *    <code>init</code>.
 * 2. Upload one or more parts by providing the file name, the part data
 *    in <code>file_data</code>, the UUID, a <code>multipart_operation</code>
 *    value of <code>upload_part</code>, and
 *    the part number in the <code>multipart_upload_part_number</code>.
 *    The part numbers must start at 1 and increase incrementally.
 *    Parts may not be uploaded out of order.
 * 3. Complete the upload by providing the file name, the UUID, and a
 *    <code>multipart_operation</code> value of
 *    <code>complete</code>.
 * <p>
 * Multipart uploads in progress may be canceled by providing the file name,
 * the
 * UUID, and a <code>multipart_operation</code> value of
 * <code>cancel</code>.  If an new upload is
 * initialized with a different UUID for an existing upload in progress, the
 * pre-existing upload is automatically canceled in favor of the new upload.
 * <p>
 * The multipart upload must be completed for the file to be usable in KiFS.
 * Information about multipart uploads in progress is available in
 * {@linkcode GPUdb#show_files}.
 * <p>
 * File data may be pre-encoded using base64 encoding. This should be indicated
 * using the <code>file_encoding</code> option, and is recommended when
 * using JSON serialization.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@linkcode GPUdb#show_directories}. The user must
 * have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.upload_files_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.upload_files_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        file_names: request.file_names,
        file_data: request.file_data,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/upload/files", actual_request, callback);
};

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>. There are
 * two methods for uploading files: load files in their entirety, or load files
 * in
 * parts. The latter is recommeded for files of approximately 60 MB or larger.
 * <p>
 * To upload files in their entirety, populate <code>file_names</code> with the
 * file
 * names to upload into on KiFS, and their respective byte content in
 * <code>file_data</code>.
 * <p>
 * Multiple steps are involved when uploading in multiple parts. Only one file
 * at a
 * time can be uploaded in this manner. A user-provided UUID is utilized to tie
 * all
 * the upload steps together for a given file.  To upload a file in multiple
 * parts:
 * <p>
 * 1. Provide the file name in <code>file_names</code>, the UUID in
 *    the <code>multipart_upload_uuid</code> key in <code>options</code>, and
 *    a <code>multipart_operation</code> value of
 *    <code>init</code>.
 * 2. Upload one or more parts by providing the file name, the part data
 *    in <code>file_data</code>, the UUID, a <code>multipart_operation</code>
 *    value of <code>upload_part</code>, and
 *    the part number in the <code>multipart_upload_part_number</code>.
 *    The part numbers must start at 1 and increase incrementally.
 *    Parts may not be uploaded out of order.
 * 3. Complete the upload by providing the file name, the UUID, and a
 *    <code>multipart_operation</code> value of
 *    <code>complete</code>.
 * <p>
 * Multipart uploads in progress may be canceled by providing the file name,
 * the
 * UUID, and a <code>multipart_operation</code> value of
 * <code>cancel</code>.  If an new upload is
 * initialized with a different UUID for an existing upload in progress, the
 * pre-existing upload is automatically canceled in favor of the new upload.
 * <p>
 * The multipart upload must be completed for the file to be usable in KiFS.
 * Information about multipart uploads in progress is available in
 * {@linkcode GPUdb#show_files}.
 * <p>
 * File data may be pre-encoded using base64 encoding. This should be indicated
 * using the <code>file_encoding</code> option, and is recommended when
 * using JSON serialization.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@linkcode GPUdb#show_directories}. The user must
 * have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 *
 * @param {String[]} file_names  An array of full file name paths to be used
 *                               for the files
 *                               uploaded to KiFS. File names may have any
 *                               number of nested directories in their
 *                               paths, but the top-level directory must be an
 *                               existing KiFS directory. Each file
 *                               must reside in or under a top-level directory.
 *                               A full file name path cannot be
 *                               larger than 1024 characters.
 * @param {String[]} file_data  File data for the files being uploaded, for the
 *                              respective files in <code>file_names</code>.
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'file_encoding': Encoding that has
 *                          been applied to the uploaded
 *                          file data. When using JSON serialization it is
 *                          recommended to utilize
 *                          <code>base64</code>. The caller is responsible
 *                          for encoding the data provided in this payload
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'base64': Specifies that the file data
 *                          being uploaded has been base64 encoded.
 *                                  <li> 'none': The uploaded file data has not
 *                          been encoded.
 *                          </ul>
 *                          The default value is 'none'.
 *                                  <li> 'multipart_operation': Multipart
 *                          upload operation to perform
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'none': Default, indicates this is not
 *                          a multipart upload
 *                                  <li> 'init': Initialize a multipart file
 *                          upload
 *                                  <li> 'upload_part': Uploads a part of the
 *                          specified multipart file upload
 *                                  <li> 'complete': Complete the specified
 *                          multipart file upload
 *                                  <li> 'cancel': Cancel the specified
 *                          multipart file upload
 *                          </ul>
 *                          The default value is 'none'.
 *                                  <li> 'multipart_upload_uuid': UUID to
 *                          uniquely identify a multipart upload
 *                                  <li> 'multipart_upload_part_number':
 *                          Incremental part number for each part in a
 *                          multipart upload. Part numbers start at 1,
 *                          increment by 1, and must be uploaded
 *                          sequentially
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.upload_files = function(file_names, file_data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.upload_files(file_names, file_data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        file_names: file_names,
        file_data: file_data,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/upload/files", actual_request, callback);
};

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@linkcode GPUdb#show_directories}. The user must
 * have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.upload_files_fromurl_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.upload_files_fromurl_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        file_names: request.file_names,
        urls: request.urls,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/upload/files/fromurl", actual_request, callback);
};

/**
 * Uploads one or more files to <a href="../../../tools/kifs/"
 * target="_top">KiFS</a>.
 * <p>
 * Each file path must reside in a top-level KiFS directory, i.e. one of the
 * directories listed in {@linkcode GPUdb#show_directories}. The user must
 * have write
 * permission on the directory. Nested directories are permitted in file name
 * paths. Directories are deliniated with the directory separator of '/'.  For
 * example, given the file path '/a/b/c/d.txt', 'a' must be a KiFS directory.
 * <p>
 * These characters are allowed in file name paths: letters, numbers, spaces,
 * the
 * path delimiter of '/', and the characters: '.' '-' ':' '[' ']' '(' ')' '#'
 * '='.
 *
 * @param {String[]} file_names  An array of full file name paths to be used
 *                               for the files
 *                               uploaded to KiFS. File names may have any
 *                               number of nested directories in their
 *                               paths, but the top-level directory must be an
 *                               existing KiFS directory. Each file
 *                               must reside in or under a top-level directory.
 *                               A full file name path cannot be
 *                               larger than 1024 characters.
 * @param {String[]} urls  List of URLs to upload, for each respective file in
 *                         <code>file_names</code>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.upload_files_fromurl = function(file_names, urls, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.upload_files_fromurl(file_names, urls, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        file_names: file_names,
        urls: urls,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/upload/files/fromurl", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        world_table_names: request.world_table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        symbol_column_name: request.symbol_column_name,
        geometry_column_name: request.geometry_column_name,
        track_ids: request.track_ids,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        bg_color: request.bg_color,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String[]} world_table_names
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String} symbol_column_name
 * @param {String} geometry_column_name
 * @param {String[][]} track_ids
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'EPSG:4326'
 *                                     <li> 'PLATE_CARREE'
 *                                     <li> '900913'
 *                                     <li> 'EPSG:900913'
 *                                     <li> '102100'
 *                                     <li> 'EPSG:102100'
 *                                     <li> '3857'
 *                                     <li> 'EPSG:3857'
 *                                     <li> 'WEB_MERCATOR'
 *                             </ul>
 *                             The default value is 'PLATE_CARREE'.
 * @param {Number} bg_color
 * @param {Object} style_options
 *                                <ul>
 *                                        <li> 'do_points':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'true'.
 *                                        <li> 'do_shapes':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'true'.
 *                                        <li> 'do_tracks':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'true'.
 *                                        <li> 'do_symbology':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'false'.
 *                                        <li> 'pointcolors':
 *                                        <li> 'pointsizes': The default value
 *                                is '3'.
 *                                        <li> 'pointoffset_x': The default
 *                                value is '0'.
 *                                        <li> 'pointoffset_y': The default
 *                                value is '0'.
 *                                        <li> 'pointshapes':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none'
 *                                        <li> 'circle'
 *                                        <li> 'square'
 *                                        <li> 'diamond'
 *                                        <li> 'hollowcircle'
 *                                        <li> 'hollowsquare'
 *                                        <li> 'hollowdiamond'
 *                                        <li> 'symbolcode'
 *                                </ul>
 *                                The default value is 'square'.
 *                                        <li> 'symbolrotations': The default
 *                                value is '0'.
 *                                        <li> 'shapelinewidths': The default
 *                                value is '3'.
 *                                        <li> 'shapelinecolors': The default
 *                                value is 'FFFF00 '.
 *                                        <li> 'shapelinepatterns': The default
 *                                value is '0'.
 *                                        <li> 'shapelinepatternlen': The
 *                                default value is '32'.
 *                                        <li> 'shapefillcolors': The default
 *                                value is '-1'.
 *                                        <li> 'hashlineintervals': The default
 *                                value is '20'.
 *                                        <li> 'hashlinecolors': The default
 *                                value is 'The same as line color.'.
 *                                        <li> 'hashlineangles': The default
 *                                value is '0'.
 *                                        <li> 'hashlinelens': The default
 *                                value is '0'.
 *                                        <li> 'hashlinewidths': The default
 *                                value is '3'.
 *                                        <li> 'tracklinewidths': The default
 *                                value is '3'.
 *                                        <li> 'tracklinecolors': The default
 *                                value is '00FF00'.
 *                                        <li> 'trackmarkersizes': The default
 *                                value is '3'.
 *                                        <li> 'trackmarkercolors': The default
 *                                value is '0000FF'.
 *                                        <li> 'trackmarkershapes':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none'
 *                                        <li> 'circle'
 *                                        <li> 'square'
 *                                        <li> 'diamond'
 *                                        <li> 'hollowcircle'
 *                                        <li> 'hollowsquare'
 *                                        <li> 'hollowdiamond'
 *                                        <li> 'oriented_arrow'
 *                                        <li> 'oriented_triangle'
 *                                        <li> 'symbolcode'
 *                                </ul>
 *                                The default value is 'circle'.
 *                                        <li> 'trackheadcolors': The default
 *                                value is 'FFFFFF'.
 *                                        <li> 'trackheadsizes': The default
 *                                value is '10'.
 *                                        <li> 'trackheadshapes':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none'
 *                                        <li> 'circle'
 *                                        <li> 'square'
 *                                        <li> 'diamond'
 *                                        <li> 'hollowcircle'
 *                                        <li> 'hollowsquare'
 *                                        <li> 'hollowdiamond'
 *                                        <li> 'symbolcode'
 *                                </ul>
 *                                The default value is 'hollowdiamond'.
 *                                </ul>
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'track_id_column_name':
 *                                  <li> 'track_order_column_name':
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image = function(table_names, world_table_names, x_column_name, y_column_name, symbol_column_name, geometry_column_name, track_ids, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image(table_names, world_table_names, x_column_name, y_column_name, symbol_column_name, geometry_column_name, track_ids, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        world_table_names: world_table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        symbol_column_name: symbol_column_name,
        geometry_column_name: geometry_column_name,
        track_ids: track_ids,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        bg_color: bg_color,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image", actual_request, callback);
};

/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the <code>image_data</code> field.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_chart_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_chart_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        x_column_names: request.x_column_names,
        y_column_names: request.y_column_names,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        bg_color: request.bg_color,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/chart", actual_request, callback);
};

/**
 * Scatter plot is the only plot type currently supported. A non-numeric column
 * can be specified as x or y column and jitters can be added to them to avoid
 * excessive overlapping. All color values must be in the format RRGGBB or
 * AARRGGBB (to specify the alpha value).
 * The image is contained in the <code>image_data</code> field.
 *
 * @param {String} table_name  Name of the table containing the data to be
 *                             drawn as a chart, in [schema_name.]table_name
 *                             format, using standard <a
 *                             href="../../../concepts/tables/#table-name-resolution"
 *                             target="_top">name resolution rules</a>.
 * @param {String[]} x_column_names  Names of the columns containing the data
 *                                   mapped to the x axis of a chart.
 * @param {String[]} y_column_names  Names of the columns containing the data
 *                                   mapped to the y axis of a chart.
 * @param {Number} min_x  Lower bound for the x column values. For non-numeric
 *                        x column, each x column item is mapped to an integral
 *                        value starting from 0.
 * @param {Number} max_x  Upper bound for the x column values. For non-numeric
 *                        x column, each x column item is mapped to an integral
 *                        value starting from 0.
 * @param {Number} min_y  Lower bound for the y column values. For non-numeric
 *                        y column, each y column item is mapped to an integral
 *                        value starting from 0.
 * @param {Number} max_y  Upper bound for the y column values. For non-numeric
 *                        y column, each y column item is mapped to an integral
 *                        value starting from 0.
 * @param {Number} width  Width of the generated image in pixels.
 * @param {Number} height  Height of the generated image in pixels.
 * @param {String} bg_color  Background color of the generated image.
 * @param {Object} style_options  Rendering style options for a chart.
 *                                <ul>
 *                                        <li> 'pointcolor': The color of
 *                                points in the plot represented as a
 *                                hexadecimal number.  The default value is
 *                                '0000FF'.
 *                                        <li> 'pointsize': The size of points
 *                                in the plot represented as number of pixels.
 *                                The default value is '3'.
 *                                        <li> 'pointshape': The shape of
 *                                points in the plot.
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none'
 *                                        <li> 'circle'
 *                                        <li> 'square'
 *                                        <li> 'diamond'
 *                                        <li> 'hollowcircle'
 *                                        <li> 'hollowsquare'
 *                                        <li> 'hollowdiamond'
 *                                </ul>
 *                                The default value is 'square'.
 *                                        <li> 'cb_pointcolors': Point color
 *                                class break information consisting of three
 *                                entries: class-break attribute, class-break
 *                                values/ranges, and point color values. This
 *                                option overrides the pointcolor option if
 *                                both are provided. Class-break ranges are
 *                                represented in the form of "min:max".
 *                                Class-break values/ranges and point color
 *                                values are separated by cb_delimiter, e.g.
 *                                {"price", "20:30;30:40;40:50",
 *                                "0xFF0000;0x00FF00;0x0000FF"}.
 *                                        <li> 'cb_pointsizes': Point size
 *                                class break information consisting of three
 *                                entries: class-break attribute, class-break
 *                                values/ranges, and point size values. This
 *                                option overrides the pointsize option if both
 *                                are provided. Class-break ranges are
 *                                represented in the form of "min:max".
 *                                Class-break values/ranges and point size
 *                                values are separated by cb_delimiter, e.g.
 *                                {"states", "NY;TX;CA", "3;5;7"}.
 *                                        <li> 'cb_pointshapes': Point shape
 *                                class break information consisting of three
 *                                entries: class-break attribute, class-break
 *                                values/ranges, and point shape names. This
 *                                option overrides the pointshape option if
 *                                both are provided. Class-break ranges are
 *                                represented in the form of "min:max".
 *                                Class-break values/ranges and point shape
 *                                names are separated by cb_delimiter, e.g.
 *                                {"states", "NY;TX;CA",
 *                                "circle;square;diamond"}.
 *                                        <li> 'cb_delimiter': A character or
 *                                string which separates per-class values in a
 *                                class-break style option string.  The default
 *                                value is ';'.
 *                                        <li> 'x_order_by': An expression or
 *                                aggregate expression by which non-numeric x
 *                                column values are sorted, e.g. "avg(price)
 *                                descending".
 *                                        <li> 'y_order_by': An expression or
 *                                aggregate expression by which non-numeric y
 *                                column values are sorted, e.g. "avg(price)",
 *                                which defaults to "avg(price) ascending".
 *                                        <li> 'scale_type_x': Type of x axis
 *                                scale.
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none': No scale is applied to
 *                                the x axis.
 *                                        <li> 'log': A base-10 log scale is
 *                                applied to the x axis.
 *                                </ul>
 *                                The default value is 'none'.
 *                                        <li> 'scale_type_y': Type of y axis
 *                                scale.
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none': No scale is applied to
 *                                the y axis.
 *                                        <li> 'log': A base-10 log scale is
 *                                applied to the y axis.
 *                                </ul>
 *                                The default value is 'none'.
 *                                        <li> 'min_max_scaled': If this
 *                                options is set to "false", this endpoint
 *                                expects request's min/max values are not yet
 *                                scaled. They will be scaled according to
 *                                scale_type_x or scale_type_y for response. If
 *                                this options is set to "true", this endpoint
 *                                expects request's min/max values are already
 *                                scaled according to
 *                                scale_type_x/scale_type_y. Response's min/max
 *                                values will be equal to request's min/max
 *                                values.  The default value is 'false'.
 *                                        <li> 'jitter_x': Amplitude of
 *                                horizontal jitter applied to non-numeric x
 *                                column values.  The default value is '0.0'.
 *                                        <li> 'jitter_y': Amplitude of
 *                                vertical jitter applied to non-numeric y
 *                                column values.  The default value is '0.0'.
 *                                        <li> 'plot_all': If this options is
 *                                set to "true", all non-numeric column values
 *                                are plotted ignoring min_x, max_x, min_y and
 *                                max_y parameters.  The default value is
 *                                'false'.
 *                                </ul>
 * @param {Object} options  Optional parameters.
 *                          <ul>
 *                                  <li> 'image_encoding': Encoding to be
 *                          applied to the output image. When using JSON
 *                          serialization it is recommended to specify this as
 *                          <code>base64</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'base64': Apply base64 encoding to the
 *                          output image.
 *                                  <li> 'none': Do not apply any additional
 *                          encoding to the output image.
 *                          </ul>
 *                          The default value is 'none'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_chart = function(table_name, x_column_names, y_column_names, min_x, max_x, min_y, max_y, width, height, bg_color, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_chart(table_name, x_column_names, y_column_names, min_x, max_x, min_y, max_y, width, height, bg_color, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        x_column_names: x_column_names,
        y_column_names: y_column_names,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        bg_color: bg_color,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/chart", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_classbreak_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_classbreak_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        world_table_names: request.world_table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        symbol_column_name: request.symbol_column_name,
        geometry_column_name: request.geometry_column_name,
        track_ids: request.track_ids,
        cb_attr: request.cb_attr,
        cb_vals: request.cb_vals,
        cb_pointcolor_attr: request.cb_pointcolor_attr,
        cb_pointcolor_vals: request.cb_pointcolor_vals,
        cb_pointalpha_attr: request.cb_pointalpha_attr,
        cb_pointalpha_vals: request.cb_pointalpha_vals,
        cb_pointsize_attr: request.cb_pointsize_attr,
        cb_pointsize_vals: request.cb_pointsize_vals,
        cb_pointshape_attr: request.cb_pointshape_attr,
        cb_pointshape_vals: request.cb_pointshape_vals,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        bg_color: request.bg_color,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {},
        cb_transparency_vec: request.cb_transparency_vec
    };

    this.submit_request("/visualize/image/classbreak", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String[]} world_table_names
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String} symbol_column_name
 * @param {String} geometry_column_name
 * @param {String[][]} track_ids
 * @param {String} cb_attr
 * @param {String[]} cb_vals
 * @param {String} cb_pointcolor_attr
 * @param {String[]} cb_pointcolor_vals
 * @param {String} cb_pointalpha_attr
 * @param {String[]} cb_pointalpha_vals
 * @param {String} cb_pointsize_attr
 * @param {String[]} cb_pointsize_vals
 * @param {String} cb_pointshape_attr
 * @param {String[]} cb_pointshape_vals
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'EPSG:4326'
 *                                     <li> 'PLATE_CARREE'
 *                                     <li> '900913'
 *                                     <li> 'EPSG:900913'
 *                                     <li> '102100'
 *                                     <li> 'EPSG:102100'
 *                                     <li> '3857'
 *                                     <li> 'EPSG:3857'
 *                                     <li> 'WEB_MERCATOR'
 *                             </ul>
 *                             The default value is 'PLATE_CARREE'.
 * @param {Number} bg_color
 * @param {Object} style_options
 *                                <ul>
 *                                        <li> 'do_points':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'true'.
 *                                        <li> 'do_shapes':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'true'.
 *                                        <li> 'do_tracks':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'true'.
 *                                        <li> 'do_symbology':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'false'.
 *                                        <li> 'pointcolors': The default value
 *                                is 'FF0000'.
 *                                        <li> 'cb_pointalphas': The default
 *                                value is '255'.
 *                                        <li> 'pointsizes': The default value
 *                                is '3'.
 *                                        <li> 'pointoffset_x': The default
 *                                value is '0'.
 *                                        <li> 'pointoffset_y': The default
 *                                value is '0'.
 *                                        <li> 'pointshapes':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none'
 *                                        <li> 'circle'
 *                                        <li> 'square'
 *                                        <li> 'diamond'
 *                                        <li> 'hollowcircle'
 *                                        <li> 'hollowsquare'
 *                                        <li> 'hollowdiamond'
 *                                        <li> 'symbolcode'
 *                                </ul>
 *                                The default value is 'none'.
 *                                        <li> 'symbolrotations': The default
 *                                value is '0'.
 *                                        <li> 'shapelinewidths': The default
 *                                value is '3'.
 *                                        <li> 'shapelinecolors': The default
 *                                value is 'FFFF00 '.
 *                                        <li> 'shapelinepatterns': The default
 *                                value is '0'.
 *                                        <li> 'shapelinepatternlen': The
 *                                default value is '32'.
 *                                        <li> 'shapefillcolors': The default
 *                                value is '-1'.
 *                                        <li> 'hashlineintervals': The default
 *                                value is '20'.
 *                                        <li> 'hashlinecolors': The default
 *                                value is 'The same as line color.'.
 *                                        <li> 'hashlineangles': The default
 *                                value is '0'.
 *                                        <li> 'hashlinelens': The default
 *                                value is '0'.
 *                                        <li> 'hashlinewidths': The default
 *                                value is '3'.
 *                                        <li> 'tracklinewidths': The default
 *                                value is '3'.
 *                                        <li> 'tracklinecolors': The default
 *                                value is '00FF00'.
 *                                        <li> 'trackmarkersizes': The default
 *                                value is '3'.
 *                                        <li> 'trackmarkercolors': The default
 *                                value is '0000FF'.
 *                                        <li> 'trackmarkershapes':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none'
 *                                        <li> 'circle'
 *                                        <li> 'square'
 *                                        <li> 'diamond'
 *                                        <li> 'hollowcircle'
 *                                        <li> 'hollowsquare'
 *                                        <li> 'hollowdiamond'
 *                                        <li> 'oriented_arrow'
 *                                        <li> 'oriented_triangle'
 *                                        <li> 'symbolcode'
 *                                </ul>
 *                                The default value is 'none'.
 *                                        <li> 'trackheadcolors': The default
 *                                value is 'FFFFFF'.
 *                                        <li> 'trackheadsizes': The default
 *                                value is '10'.
 *                                        <li> 'trackheadshapes':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'none'
 *                                        <li> 'circle'
 *                                        <li> 'square'
 *                                        <li> 'diamond'
 *                                        <li> 'hollowcircle'
 *                                        <li> 'hollowsquare'
 *                                        <li> 'hollowdiamond'
 *                                        <li> 'symbolcode'
 *                                </ul>
 *                                The default value is 'circle'.
 *                                </ul>
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'track_id_column_name':
 *                                  <li> 'track_order_column_name':
 *                          </ul>
 * @param {Number[]} cb_transparency_vec
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_classbreak = function(table_names, world_table_names, x_column_name, y_column_name, symbol_column_name, geometry_column_name, track_ids, cb_attr, cb_vals, cb_pointcolor_attr, cb_pointcolor_vals, cb_pointalpha_attr, cb_pointalpha_vals, cb_pointsize_attr, cb_pointsize_vals, cb_pointshape_attr, cb_pointshape_vals, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, cb_transparency_vec, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_classbreak(table_names, world_table_names, x_column_name, y_column_name, symbol_column_name, geometry_column_name, track_ids, cb_attr, cb_vals, cb_pointcolor_attr, cb_pointcolor_vals, cb_pointalpha_attr, cb_pointalpha_vals, cb_pointsize_attr, cb_pointsize_vals, cb_pointshape_attr, cb_pointshape_vals, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, cb_transparency_vec, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        world_table_names: world_table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        symbol_column_name: symbol_column_name,
        geometry_column_name: geometry_column_name,
        track_ids: track_ids,
        cb_attr: cb_attr,
        cb_vals: cb_vals,
        cb_pointcolor_attr: cb_pointcolor_attr,
        cb_pointcolor_vals: cb_pointcolor_vals,
        cb_pointalpha_attr: cb_pointalpha_attr,
        cb_pointalpha_vals: cb_pointalpha_vals,
        cb_pointsize_attr: cb_pointsize_attr,
        cb_pointsize_vals: cb_pointsize_vals,
        cb_pointshape_attr: cb_pointshape_attr,
        cb_pointshape_vals: cb_pointshape_vals,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        bg_color: bg_color,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {},
        cb_transparency_vec: cb_transparency_vec
    };

    this.submit_request("/visualize/image/classbreak", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_contour_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_contour_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        value_column_name: request.value_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/contour", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String} value_column_name
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection
 *                             Supported values:
 *                             <ul>
 *                                     <li> '3857'
 *                                     <li> '102100'
 *                                     <li> '900913'
 *                                     <li> 'EPSG:4326'
 *                                     <li> 'PLATE_CARREE'
 *                                     <li> 'EPSG:900913'
 *                                     <li> 'EPSG:102100'
 *                                     <li> 'EPSG:3857'
 *                                     <li> 'WEB_MERCATOR'
 *                             </ul>
 *                             The default value is 'PLATE_CARREE'.
 * @param {Object} style_options
 *                                <ul>
 *                                        <li> 'line_size': The default value
 *                                is '3'.
 *                                        <li> 'color': The default value is
 *                                'FF696969'.
 *                                        <li> 'bg_color': The default value is
 *                                '00000000'.
 *                                        <li> 'text_color': The default value
 *                                is 'FF000000'.
 *                                        <li> 'colormap':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'jet'
 *                                        <li> 'accent'
 *                                        <li> 'afmhot'
 *                                        <li> 'autumn'
 *                                        <li> 'binary'
 *                                        <li> 'blues'
 *                                        <li> 'bone'
 *                                        <li> 'brbg'
 *                                        <li> 'brg'
 *                                        <li> 'bugn'
 *                                        <li> 'bupu'
 *                                        <li> 'bwr'
 *                                        <li> 'cmrmap'
 *                                        <li> 'cool'
 *                                        <li> 'coolwarm'
 *                                        <li> 'copper'
 *                                        <li> 'cubehelix'
 *                                        <li> 'dark2'
 *                                        <li> 'flag'
 *                                        <li> 'gist_earth'
 *                                        <li> 'gist_gray'
 *                                        <li> 'gist_heat'
 *                                        <li> 'gist_ncar'
 *                                        <li> 'gist_rainbow'
 *                                        <li> 'gist_stern'
 *                                        <li> 'gist_yarg'
 *                                        <li> 'gnbu'
 *                                        <li> 'gnuplot2'
 *                                        <li> 'gnuplot'
 *                                        <li> 'gray'
 *                                        <li> 'greens'
 *                                        <li> 'greys'
 *                                        <li> 'hot'
 *                                        <li> 'hsv'
 *                                        <li> 'inferno'
 *                                        <li> 'magma'
 *                                        <li> 'nipy_spectral'
 *                                        <li> 'ocean'
 *                                        <li> 'oranges'
 *                                        <li> 'orrd'
 *                                        <li> 'paired'
 *                                        <li> 'pastel1'
 *                                        <li> 'pastel2'
 *                                        <li> 'pink'
 *                                        <li> 'piyg'
 *                                        <li> 'plasma'
 *                                        <li> 'prgn'
 *                                        <li> 'prism'
 *                                        <li> 'pubu'
 *                                        <li> 'pubugn'
 *                                        <li> 'puor'
 *                                        <li> 'purd'
 *                                        <li> 'purples'
 *                                        <li> 'rainbow'
 *                                        <li> 'rdbu'
 *                                        <li> 'rdgy'
 *                                        <li> 'rdpu'
 *                                        <li> 'rdylbu'
 *                                        <li> 'rdylgn'
 *                                        <li> 'reds'
 *                                        <li> 'seismic'
 *                                        <li> 'set1'
 *                                        <li> 'set2'
 *                                        <li> 'set3'
 *                                        <li> 'spectral'
 *                                        <li> 'spring'
 *                                        <li> 'summer'
 *                                        <li> 'terrain'
 *                                        <li> 'viridis'
 *                                        <li> 'winter'
 *                                        <li> 'wistia'
 *                                        <li> 'ylgn'
 *                                        <li> 'ylgnbu'
 *                                        <li> 'ylorbr'
 *                                        <li> 'ylorrd'
 *                                </ul>
 *                                The default value is 'jet'.
 *                                </ul>
 * @param {Object} options
 *                          <ul>
 *                                  <li> 'min_level':
 *                                  <li> 'max_level':
 *                                  <li> 'num_levels': The default value is
 *                          '10'.
 *                                  <li> 'adjust_levels': The default value is
 *                          'true'.
 *                                  <li> 'search_radius': The default value is
 *                          '20'.
 *                                  <li> 'max_search_cells': The default value
 *                          is '100'.
 *                                  <li> 'gridding_method':
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'INV_DST_POW'
 *                                  <li> 'MIN_CURV'
 *                                  <li> 'KRIGING'
 *                                  <li> 'PASS_THROUGH'
 *                                  <li> 'FILL_RATIO'
 *                          </ul>
 *                          The default value is 'INV_DST_POW'.
 *                                  <li> 'smoothing_factor': The default value
 *                          is '10'.
 *                                  <li> 'grid_size': The default value is
 *                          '100'.
 *                                  <li> 'adjust_grid': The default value is
 *                          'false'.
 *                                  <li> 'adjust_grid_neigh': The default value
 *                          is '1'.
 *                                  <li> 'adjust_grid_size': The default value
 *                          is '1'.
 *                                  <li> 'max_grid_size': The default value is
 *                          '500'.
 *                                  <li> 'min_grid_size': The default value is
 *                          '10'.
 *                                  <li> 'render_output_grid': The default
 *                          value is 'false'.
 *                                  <li> 'color_isolines': The default value is
 *                          'true'.
 *                                  <li> 'add_labels': The default value is
 *                          'false'.
 *                                  <li> 'labels_font_size': The default value
 *                          is '12'.
 *                                  <li> 'labels_font_family': The default
 *                          value is 'sans'.
 *                                  <li> 'labels_search_window': The default
 *                          value is '4'.
 *                                  <li> 'labels_intralevel_separation': The
 *                          default value is '4'.
 *                                  <li> 'labels_interlevel_separation': The
 *                          default value is '20'.
 *                                  <li> 'labels_max_angle': The default value
 *                          is '60'.
 *                                  <li> 'isochrone_concavity': The default
 *                          value is '-1'.
 *                                  <li> 'isochrone_output_table': The default
 *                          value is ''.
 *                                  <li> 'isochrone_image': The default value
 *                          is 'false'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_contour = function(table_names, x_column_name, y_column_name, value_column_name, min_x, max_x, min_y, max_y, width, height, projection, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_contour(table_names, x_column_name, y_column_name, value_column_name, min_x, max_x, min_y, max_y, width, height, projection, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        value_column_name: value_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/contour", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_heatmap_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_heatmap_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        value_column_name: request.value_column_name,
        geometry_column_name: request.geometry_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/heatmap", actual_request, callback);
};

/**
 *
 * @param {String[]} table_names
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String} value_column_name
 * @param {String} geometry_column_name
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'EPSG:4326'
 *                                     <li> 'PLATE_CARREE'
 *                                     <li> '900913'
 *                                     <li> 'EPSG:900913'
 *                                     <li> '102100'
 *                                     <li> 'EPSG:102100'
 *                                     <li> '3857'
 *                                     <li> 'EPSG:3857'
 *                                     <li> 'WEB_MERCATOR'
 *                             </ul>
 *                             The default value is 'PLATE_CARREE'.
 * @param {Object} style_options
 *                                <ul>
 *                                        <li> 'colormap':
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'jet'
 *                                        <li> 'accent'
 *                                        <li> 'afmhot'
 *                                        <li> 'autumn'
 *                                        <li> 'binary'
 *                                        <li> 'blues'
 *                                        <li> 'bone'
 *                                        <li> 'brbg'
 *                                        <li> 'brg'
 *                                        <li> 'bugn'
 *                                        <li> 'bupu'
 *                                        <li> 'bwr'
 *                                        <li> 'cmrmap'
 *                                        <li> 'cool'
 *                                        <li> 'coolwarm'
 *                                        <li> 'copper'
 *                                        <li> 'cubehelix'
 *                                        <li> 'dark2'
 *                                        <li> 'flag'
 *                                        <li> 'gist_earth'
 *                                        <li> 'gist_gray'
 *                                        <li> 'gist_heat'
 *                                        <li> 'gist_ncar'
 *                                        <li> 'gist_rainbow'
 *                                        <li> 'gist_stern'
 *                                        <li> 'gist_yarg'
 *                                        <li> 'gnbu'
 *                                        <li> 'gnuplot2'
 *                                        <li> 'gnuplot'
 *                                        <li> 'gray'
 *                                        <li> 'greens'
 *                                        <li> 'greys'
 *                                        <li> 'hot'
 *                                        <li> 'hsv'
 *                                        <li> 'inferno'
 *                                        <li> 'magma'
 *                                        <li> 'nipy_spectral'
 *                                        <li> 'ocean'
 *                                        <li> 'oranges'
 *                                        <li> 'orrd'
 *                                        <li> 'paired'
 *                                        <li> 'pastel1'
 *                                        <li> 'pastel2'
 *                                        <li> 'pink'
 *                                        <li> 'piyg'
 *                                        <li> 'plasma'
 *                                        <li> 'prgn'
 *                                        <li> 'prism'
 *                                        <li> 'pubu'
 *                                        <li> 'pubugn'
 *                                        <li> 'puor'
 *                                        <li> 'purd'
 *                                        <li> 'purples'
 *                                        <li> 'rainbow'
 *                                        <li> 'rdbu'
 *                                        <li> 'rdgy'
 *                                        <li> 'rdpu'
 *                                        <li> 'rdylbu'
 *                                        <li> 'rdylgn'
 *                                        <li> 'reds'
 *                                        <li> 'seismic'
 *                                        <li> 'set1'
 *                                        <li> 'set2'
 *                                        <li> 'set3'
 *                                        <li> 'spectral'
 *                                        <li> 'spring'
 *                                        <li> 'summer'
 *                                        <li> 'terrain'
 *                                        <li> 'viridis'
 *                                        <li> 'winter'
 *                                        <li> 'wistia'
 *                                        <li> 'ylgn'
 *                                        <li> 'ylgnbu'
 *                                        <li> 'ylorbr'
 *                                        <li> 'ylorrd'
 *                                </ul>
 *                                The default value is 'jet'.
 *                                        <li> 'blur_radius': The default value
 *                                is '5'.
 *                                        <li> 'bg_color':
 *                                        <li> 'gradient_start_color': The
 *                                default value is 'FFFFFF'.
 *                                        <li> 'gradient_end_color': The
 *                                default value is 'FF0000'.
 *                                </ul>
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_heatmap = function(table_names, x_column_name, y_column_name, value_column_name, geometry_column_name, min_x, max_x, min_y, max_y, width, height, projection, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_heatmap(table_names, x_column_name, y_column_name, value_column_name, geometry_column_name, min_x, max_x, min_y, max_y, width, height, projection, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        value_column_name: value_column_name,
        geometry_column_name: geometry_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/heatmap", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_labels_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_labels_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        x_offset: (request.x_offset !== undefined && request.x_offset !== null) ? request.x_offset : "",
        y_offset: (request.y_offset !== undefined && request.y_offset !== null) ? request.y_offset : "",
        text_string: request.text_string,
        font: (request.font !== undefined && request.font !== null) ? request.font : "",
        text_color: (request.text_color !== undefined && request.text_color !== null) ? request.text_color : "",
        text_angle: (request.text_angle !== undefined && request.text_angle !== null) ? request.text_angle : "",
        text_scale: (request.text_scale !== undefined && request.text_scale !== null) ? request.text_scale : "",
        draw_box: (request.draw_box !== undefined && request.draw_box !== null) ? request.draw_box : "",
        draw_leader: (request.draw_leader !== undefined && request.draw_leader !== null) ? request.draw_leader : "",
        line_width: (request.line_width !== undefined && request.line_width !== null) ? request.line_width : "",
        line_color: (request.line_color !== undefined && request.line_color !== null) ? request.line_color : "",
        fill_color: (request.fill_color !== undefined && request.fill_color !== null) ? request.fill_color : "",
        leader_x_column_name: (request.leader_x_column_name !== undefined && request.leader_x_column_name !== null) ? request.leader_x_column_name : "",
        leader_y_column_name: (request.leader_y_column_name !== undefined && request.leader_y_column_name !== null) ? request.leader_y_column_name : "",
        filter: (request.filter !== undefined && request.filter !== null) ? request.filter : "",
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/labels", actual_request, callback);
};

/**
 *
 * @param {String} table_name
 * @param {String} x_column_name
 * @param {String} y_column_name
 * @param {String} x_offset
 * @param {String} y_offset
 * @param {String} text_string
 * @param {String} font
 * @param {String} text_color
 * @param {String} text_angle
 * @param {String} text_scale
 * @param {String} draw_box
 * @param {String} draw_leader
 * @param {String} line_width
 * @param {String} line_color
 * @param {String} fill_color
 * @param {String} leader_x_column_name
 * @param {String} leader_y_column_name
 * @param {String} filter
 * @param {Number} min_x
 * @param {Number} max_x
 * @param {Number} min_y
 * @param {Number} max_y
 * @param {Number} width
 * @param {Number} height
 * @param {String} projection
 *                             Supported values:
 *                             <ul>
 *                                     <li> 'EPSG:4326'
 *                                     <li> 'PLATE_CARREE'
 *                                     <li> '900913'
 *                                     <li> 'EPSG:900913'
 *                                     <li> '102100'
 *                                     <li> 'EPSG:102100'
 *                                     <li> '3857'
 *                                     <li> 'EPSG:3857'
 *                                     <li> 'WEB_MERCATOR'
 *                             </ul>
 *                             The default value is 'PLATE_CARREE'.
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 * @private
 */
GPUdb.prototype.visualize_image_labels = function(table_name, x_column_name, y_column_name, x_offset, y_offset, text_string, font, text_color, text_angle, text_scale, draw_box, draw_leader, line_width, line_color, fill_color, leader_x_column_name, leader_y_column_name, filter, min_x, max_x, min_y, max_y, width, height, projection, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_labels(table_name, x_column_name, y_column_name, x_offset, y_offset, text_string, font, text_color, text_angle, text_scale, draw_box, draw_leader, line_width, line_color, fill_color, leader_x_column_name, leader_y_column_name, filter, min_x, max_x, min_y, max_y, width, height, projection, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        x_offset: (x_offset !== undefined && x_offset !== null) ? x_offset : "",
        y_offset: (y_offset !== undefined && y_offset !== null) ? y_offset : "",
        text_string: text_string,
        font: (font !== undefined && font !== null) ? font : "",
        text_color: (text_color !== undefined && text_color !== null) ? text_color : "",
        text_angle: (text_angle !== undefined && text_angle !== null) ? text_angle : "",
        text_scale: (text_scale !== undefined && text_scale !== null) ? text_scale : "",
        draw_box: (draw_box !== undefined && draw_box !== null) ? draw_box : "",
        draw_leader: (draw_leader !== undefined && draw_leader !== null) ? draw_leader : "",
        line_width: (line_width !== undefined && line_width !== null) ? line_width : "",
        line_color: (line_color !== undefined && line_color !== null) ? line_color : "",
        fill_color: (fill_color !== undefined && fill_color !== null) ? fill_color : "",
        leader_x_column_name: (leader_x_column_name !== undefined && leader_x_column_name !== null) ? leader_x_column_name : "",
        leader_y_column_name: (leader_y_column_name !== undefined && leader_y_column_name !== null) ? leader_y_column_name : "",
        filter: (filter !== undefined && filter !== null) ? filter : "",
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/labels", actual_request, callback);
};

/**
 * Generate an image containing isolines for travel results using an
 * existing graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * for more information on graphs.
 * .
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_isochrone_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_isochrone_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: request.graph_name,
        source_node: request.source_node,
        max_solution_radius: (request.max_solution_radius !== undefined && request.max_solution_radius !== null) ? request.max_solution_radius : "-1.0",
        weights_on_edges: (request.weights_on_edges !== undefined && request.weights_on_edges !== null) ? request.weights_on_edges : [],
        restrictions: (request.restrictions !== undefined && request.restrictions !== null) ? request.restrictions : [],
        num_levels: (request.num_levels !== undefined && request.num_levels !== null) ? request.num_levels : "1",
        generate_image: (request.generate_image !== undefined && request.generate_image !== null) ? request.generate_image : true,
        levels_table: (request.levels_table !== undefined && request.levels_table !== null) ? request.levels_table : "",
        style_options: request.style_options,
        solve_options: (request.solve_options !== undefined && request.solve_options !== null) ? request.solve_options : {},
        contour_options: (request.contour_options !== undefined && request.contour_options !== null) ? request.contour_options : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/isochrone", actual_request, callback);
};

/**
 * Generate an image containing isolines for travel results using an
 * existing graph. Isolines represent curves of equal cost, with cost typically
 * referring to the time or distance assigned as the weights of the underlying
 * graph. See
 * <a href="../../../graph_solver/network_graph_solver/" target="_top">Network
 * Graphs & Solvers</a>
 * for more information on graphs.
 * .
 *
 * @param {String} graph_name  Name of the graph on which the isochrone is to
 *                             be computed.
 * @param {String} source_node  Starting vertex on the underlying graph from/to
 *                              which the isochrones are created.
 * @param {Number} max_solution_radius  Extent of the search radius around
 *                                      <code>source_node</code>. Set to '-1.0'
 *                                      for unrestricted search radius.
 * @param {String[]} weights_on_edges  Additional weights to apply to the edges
 *                                     of an existing graph. Weights must be
 *                                     specified using <a
 *                                     href="../../../graph_solver/network_graph_solver/#identifiers"
 *                                     target="_top">identifiers</a>;
 *                                     identifiers are grouped as <a
 *                                     href="../../../graph_solver/network_graph_solver/#id-combos"
 *                                     target="_top">combinations</a>.
 *                                     Identifiers can be used with existing
 *                                     column names, e.g., 'table.column AS
 *                                     WEIGHTS_EDGE_ID', or expressions, e.g.,
 *                                     'ST_LENGTH(wkt) AS
 *                                     WEIGHTS_VALUESPECIFIED'. Any provided
 *                                     weights will be added (in the case of
 *                                     'WEIGHTS_VALUESPECIFIED') to or
 *                                     multiplied with (in the case of
 *                                     'WEIGHTS_FACTORSPECIFIED') the existing
 *                                     weight(s).
 * @param {String[]} restrictions  Additional restrictions to apply to the
 *                                 nodes/edges of an existing graph.
 *                                 Restrictions must be specified using <a
 *                                 href="../../../graph_solver/network_graph_solver/#identifiers"
 *                                 target="_top">identifiers</a>; identifiers
 *                                 are grouped as <a
 *                                 href="../../../graph_solver/network_graph_solver/#id-combos"
 *                                 target="_top">combinations</a>. Identifiers
 *                                 can be used with existing column names,
 *                                 e.g., 'table.column AS
 *                                 RESTRICTIONS_EDGE_ID', or expressions, e.g.,
 *                                 'column/2 AS RESTRICTIONS_VALUECOMPARED'. If
 *                                 <code>remove_previous_restrictions</code> is
 *                                 set to <code>true</code>, any provided
 *                                 restrictions will replace the existing
 *                                 restrictions. If
 *                                 <code>remove_previous_restrictions</code> is
 *                                 set to <code>false</code>, any provided
 *                                 restrictions will be added (in the case of
 *                                 'RESTRICTIONS_VALUECOMPARED') to or replaced
 *                                 (in the case of
 *                                 'RESTRICTIONS_ONOFFCOMPARED').
 * @param {Number} num_levels  Number of equally-separated isochrones to
 *                             compute.
 * @param {Boolean} generate_image  If set to <code>true</code>, generates a
 *                                  PNG image of the isochrones in the
 *                                  response.
 *                                  Supported values:
 *                                  <ul>
 *                                          <li> true
 *                                          <li> false
 *                                  </ul>
 *                                  The default value is true.
 * @param {String} levels_table  Name of the table to output the isochrones to,
 *                               in [schema_name.]table_name format, using
 *                               standard <a
 *                               href="../../../concepts/tables/#table-name-resolution"
 *                               target="_top">name resolution rules</a> and
 *                               meeting <a
 *                               href="../../../concepts/tables/#table-naming-criteria"
 *                               target="_top">table naming criteria</a>.  The
 *                               table will contain levels and their
 *                               corresponding WKT geometry. If no value is
 *                               provided, the table is not generated.
 * @param {Object} style_options  Various style related options of the
 *                                isochrone image.
 *                                <ul>
 *                                        <li> 'line_size': The width of the
 *                                contour lines in pixels.  The default value
 *                                is '3'.
 *                                        <li> 'color': Color of generated
 *                                isolines. All color values must be in the
 *                                format RRGGBB or AARRGGBB (to specify the
 *                                alpha value). If alpha is specified and
 *                                flooded contours are enabled, it will be used
 *                                for as the transparency of the latter.  The
 *                                default value is 'FF696969'.
 *                                        <li> 'bg_color': When
 *                                <code>generate_image</code> is set to
 *                                <code>true</code>, background color of the
 *                                generated image. All color values must be in
 *                                the format RRGGBB or AARRGGBB (to specify the
 *                                alpha value).  The default value is
 *                                '00000000'.
 *                                        <li> 'text_color': When
 *                                <code>add_labels</code> is set to
 *                                <code>true</code>, color for the labels. All
 *                                color values must be in the format RRGGBB or
 *                                AARRGGBB (to specify the alpha value).  The
 *                                default value is 'FF000000'.
 *                                        <li> 'colormap': Colormap for
 *                                contours or fill-in regions when applicable.
 *                                All color values must be in the format RRGGBB
 *                                or AARRGGBB (to specify the alpha value)
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'jet'
 *                                        <li> 'accent'
 *                                        <li> 'afmhot'
 *                                        <li> 'autumn'
 *                                        <li> 'binary'
 *                                        <li> 'blues'
 *                                        <li> 'bone'
 *                                        <li> 'brbg'
 *                                        <li> 'brg'
 *                                        <li> 'bugn'
 *                                        <li> 'bupu'
 *                                        <li> 'bwr'
 *                                        <li> 'cmrmap'
 *                                        <li> 'cool'
 *                                        <li> 'coolwarm'
 *                                        <li> 'copper'
 *                                        <li> 'cubehelix'
 *                                        <li> 'dark2'
 *                                        <li> 'flag'
 *                                        <li> 'gist_earth'
 *                                        <li> 'gist_gray'
 *                                        <li> 'gist_heat'
 *                                        <li> 'gist_ncar'
 *                                        <li> 'gist_rainbow'
 *                                        <li> 'gist_stern'
 *                                        <li> 'gist_yarg'
 *                                        <li> 'gnbu'
 *                                        <li> 'gnuplot2'
 *                                        <li> 'gnuplot'
 *                                        <li> 'gray'
 *                                        <li> 'greens'
 *                                        <li> 'greys'
 *                                        <li> 'hot'
 *                                        <li> 'hsv'
 *                                        <li> 'inferno'
 *                                        <li> 'magma'
 *                                        <li> 'nipy_spectral'
 *                                        <li> 'ocean'
 *                                        <li> 'oranges'
 *                                        <li> 'orrd'
 *                                        <li> 'paired'
 *                                        <li> 'pastel1'
 *                                        <li> 'pastel2'
 *                                        <li> 'pink'
 *                                        <li> 'piyg'
 *                                        <li> 'plasma'
 *                                        <li> 'prgn'
 *                                        <li> 'prism'
 *                                        <li> 'pubu'
 *                                        <li> 'pubugn'
 *                                        <li> 'puor'
 *                                        <li> 'purd'
 *                                        <li> 'purples'
 *                                        <li> 'rainbow'
 *                                        <li> 'rdbu'
 *                                        <li> 'rdgy'
 *                                        <li> 'rdpu'
 *                                        <li> 'rdylbu'
 *                                        <li> 'rdylgn'
 *                                        <li> 'reds'
 *                                        <li> 'seismic'
 *                                        <li> 'set1'
 *                                        <li> 'set2'
 *                                        <li> 'set3'
 *                                        <li> 'spectral'
 *                                        <li> 'spring'
 *                                        <li> 'summer'
 *                                        <li> 'terrain'
 *                                        <li> 'viridis'
 *                                        <li> 'winter'
 *                                        <li> 'wistia'
 *                                        <li> 'ylgn'
 *                                        <li> 'ylgnbu'
 *                                        <li> 'ylorbr'
 *                                        <li> 'ylorrd'
 *                                </ul>
 *                                The default value is 'jet'.
 *                                </ul>
 * @param {Object} solve_options  Solver specific parameters
 *                                <ul>
 *                                        <li> 'remove_previous_restrictions':
 *                                Ignore the restrictions applied to the graph
 *                                during the creation stage and only use the
 *                                restrictions specified in this request if set
 *                                to <code>true</code>.
 *                                Supported values:
 *                                <ul>
 *                                        <li> 'true'
 *                                        <li> 'false'
 *                                </ul>
 *                                The default value is 'false'.
 *                                        <li> 'restriction_threshold_value':
 *                                Value-based restriction comparison. Any node
 *                                or edge with a 'RESTRICTIONS_VALUECOMPARED'
 *                                value greater than the
 *                                <code>restriction_threshold_value</code> will
 *                                not be included in the solution.
 *                                        <li> 'uniform_weights': When
 *                                specified, assigns the given value to all the
 *                                edges in the graph. Note that weights
 *                                provided in <code>weights_on_edges</code>
 *                                will override this value.
 *                                </ul>
 * @param {Object} contour_options  Solver specific parameters
 *                                  <ul>
 *                                          <li> 'projection': Spatial
 *                                  Reference System (i.e. EPSG Code).
 *                                  Supported values:
 *                                  <ul>
 *                                          <li> '3857'
 *                                          <li> '102100'
 *                                          <li> '900913'
 *                                          <li> 'EPSG:4326'
 *                                          <li> 'PLATE_CARREE'
 *                                          <li> 'EPSG:900913'
 *                                          <li> 'EPSG:102100'
 *                                          <li> 'EPSG:3857'
 *                                          <li> 'WEB_MERCATOR'
 *                                  </ul>
 *                                  The default value is 'PLATE_CARREE'.
 *                                          <li> 'width': When
 *                                  <code>generate_image</code> is set to
 *                                  <code>true</code>, width of the generated
 *                                  image.  The default value is '512'.
 *                                          <li> 'height': When
 *                                  <code>generate_image</code> is set to
 *                                  <code>true</code>, height of the generated
 *                                  image. If the default value is used, the
 *                                  <code>height</code> is set to the value
 *                                  resulting from multiplying the aspect ratio
 *                                  by the <code>width</code>.  The default
 *                                  value is '-1'.
 *                                          <li> 'search_radius': When
 *                                  interpolating the graph solution to
 *                                  generate the isochrone, neighborhood of
 *                                  influence of sample data (in percent of the
 *                                  image/grid).  The default value is '20'.
 *                                          <li> 'grid_size': When
 *                                  interpolating the graph solution to
 *                                  generate the isochrone, number of
 *                                  subdivisions along the x axis when building
 *                                  the grid (the y is computed using the
 *                                  aspect ratio of the output image).  The
 *                                  default value is '100'.
 *                                          <li> 'color_isolines': Color each
 *                                  isoline according to the colormap;
 *                                  otherwise, use the foreground color.
 *                                  Supported values:
 *                                  <ul>
 *                                          <li> 'true'
 *                                          <li> 'false'
 *                                  </ul>
 *                                  The default value is 'true'.
 *                                          <li> 'add_labels': If set to
 *                                  <code>true</code>, add labels to the
 *                                  isolines.
 *                                  Supported values:
 *                                  <ul>
 *                                          <li> 'true'
 *                                          <li> 'false'
 *                                  </ul>
 *                                  The default value is 'false'.
 *                                          <li> 'labels_font_size': When
 *                                  <code>add_labels</code> is set to
 *                                  <code>true</code>, size of the font (in
 *                                  pixels) to use for labels.  The default
 *                                  value is '12'.
 *                                          <li> 'labels_font_family': When
 *                                  <code>add_labels</code> is set to
 *                                  <code>true</code>, font name to be used
 *                                  when adding labels.  The default value is
 *                                  'arial'.
 *                                          <li> 'labels_search_window': When
 *                                  <code>add_labels</code> is set to
 *                                  <code>true</code>, a search window is used
 *                                  to rate the local quality of each isoline.
 *                                  Smooth, continuous, long stretches with
 *                                  relatively flat angles are favored. The
 *                                  provided value is multiplied by the
 *                                  <code>labels_font_size</code> to calculate
 *                                  the final window size.  The default value
 *                                  is '4'.
 *                                          <li>
 *                                  'labels_intralevel_separation': When
 *                                  <code>add_labels</code> is set to
 *                                  <code>true</code>, this value determines
 *                                  the  distance (in multiples of the
 *                                  <code>labels_font_size</code>) to use when
 *                                  separating labels of different values.  The
 *                                  default value is '4'.
 *                                          <li>
 *                                  'labels_interlevel_separation': When
 *                                  <code>add_labels</code> is set to
 *                                  <code>true</code>, this value determines
 *                                  the distance (in percent of the total
 *                                  window size) to use when separating labels
 *                                  of the same value.  The default value is
 *                                  '20'.
 *                                          <li> 'labels_max_angle': When
 *                                  <code>add_labels</code> is set to
 *                                  <code>true</code>, maximum angle (in
 *                                  degrees) from the vertical to use when
 *                                  adding labels.  The default value is '60'.
 *                                  </ul>
 * @param {Object} options  Additional parameters
 *                          <ul>
 *                                  <li> 'solve_table': Name of the table to
 *                          host intermediate solve results, in
 *                          [schema_name.]table_name format, using standard <a
 *                          href="../../../concepts/tables/#table-name-resolution"
 *                          target="_top">name resolution rules</a> and meeting
 *                          <a
 *                          href="../../../concepts/tables/#table-naming-criteria"
 *                          target="_top">table naming criteria</a>.  This
 *                          table will contain the position and cost for each
 *                          vertex in the graph. If the default value is used,
 *                          a temporary table is created and deleted once the
 *                          solution is calculated.  The default value is ''.
 *                                  <li> 'is_replicated': If set to
 *                          <code>true</code>, replicate the
 *                          <code>solve_table</code>.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true'
 *                                  <li> 'false'
 *                          </ul>
 *                          The default value is 'true'.
 *                                  <li> 'data_min_x': Lower bound for the x
 *                          values. If not provided, it will be computed from
 *                          the bounds of the input data.
 *                                  <li> 'data_max_x': Upper bound for the x
 *                          values. If not provided, it will be computed from
 *                          the bounds of the input data.
 *                                  <li> 'data_min_y': Lower bound for the y
 *                          values. If not provided, it will be computed from
 *                          the bounds of the input data.
 *                                  <li> 'data_max_y': Upper bound for the y
 *                          values. If not provided, it will be computed from
 *                          the bounds of the input data.
 *                                  <li> 'concavity_level': Factor to qualify
 *                          the concavity of the isochrone curves. The lower
 *                          the value, the more convex (with '0' being
 *                          completely convex and '1' being the most concave).
 *                          The default value is '0.5'.
 *                                  <li> 'use_priority_queue_solvers': sets the
 *                          solver methods explicitly if true
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'true': uses the solvers scheduled for
 *                          'shortest_path' and 'inverse_shortest_path' based
 *                          on solve_direction
 *                                  <li> 'false': uses the solvers
 *                          'priority_queue' and 'inverse_priority_queue' based
 *                          on solve_direction
 *                          </ul>
 *                          The default value is 'false'.
 *                                  <li> 'solve_direction': Specify whether we
 *                          are going to the source node, or starting from it.
 *                          Supported values:
 *                          <ul>
 *                                  <li> 'from_source': Shortest path to get to
 *                          the source (inverse Dijkstra)
 *                                  <li> 'to_source': Shortest path to source
 *                          (Dijkstra)
 *                          </ul>
 *                          The default value is 'from_source'.
 *                          </ul>
 * @param {GPUdbCallback} callback  Callback that handles the response.
 *
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_isochrone = function(graph_name, source_node, max_solution_radius, weights_on_edges, restrictions, num_levels, generate_image, levels_table, style_options, solve_options, contour_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_isochrone(graph_name, source_node, max_solution_radius, weights_on_edges, restrictions, num_levels, generate_image, levels_table, style_options, solve_options, contour_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        graph_name: graph_name,
        source_node: source_node,
        max_solution_radius: (max_solution_radius !== undefined && max_solution_radius !== null) ? max_solution_radius : "-1.0",
        weights_on_edges: (weights_on_edges !== undefined && weights_on_edges !== null) ? weights_on_edges : [],
        restrictions: (restrictions !== undefined && restrictions !== null) ? restrictions : [],
        num_levels: (num_levels !== undefined && num_levels !== null) ? num_levels : "1",
        generate_image: (generate_image !== undefined && generate_image !== null) ? generate_image : true,
        levels_table: (levels_table !== undefined && levels_table !== null) ? levels_table : "",
        style_options: style_options,
        solve_options: (solve_options !== undefined && solve_options !== null) ? solve_options : {},
        contour_options: (contour_options !== undefined && contour_options !== null) ? contour_options : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/isochrone", actual_request, callback);
};



/**
 * Creates a FileHandler object
 *
 * @class
 * @classdesc FileHandler API object that provides access to KIFS server functions.
 * @param {Object} [gpuDB] GPUdb API object that provides access to GPUdb server
 *                 functions.
 */
GPUdb.FileHandler = function(gpuDB) {
    if (!(gpuDB instanceof GPUdb) || gpuDB == undefined
        || gpuDB == null)
        throw new Error("Invalid GPUdb reference specified");
    /**
     * The GPUdb object providing access to GPUdb server functions
     * @name FileHandler#gpuDB
     * @type Object
     * @readonly
     */
    this.gpuDB = gpuDB;
    Object.defineProperty( this, "gpuDB", {
        enumerable: true,
        value: this.gpuDB
    });

} // end FileHandler


/**
 * Uploads the list of files from local filesystem to KIFS.
 *
 * @param {Object} filenames    Files to be uploaded.  Can be a single string
 *                              or multiple strings containing the full path
 *                              of the files, or file objects (single or
 *                              multiple) containing the file data.
 * @param {String} destination  Destination kifs path
 * @param {Map} options         Upload options  A placeholder for future
 *                              options.
 *
 * @returns {Promise} A promise that will be fulfilled with true for success
 *                    and false for faliure (if no callback function is
 *                    provided).
 */
GPUdb.FileHandler.prototype.upload = function( files, destination, options, callback ) {

    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.upload(files, destination, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }
    options = this.parse_options(options, "upload");

    var file_list = [];
    var file_names = [];
    var file_data = [];

    if (files instanceof Array) {
        if (files.length > 0) {
            file_list = files;
        } else {
            throw new Error("'files' argument is an empty Array that cannot be uploaded.");
        }
    } else if ((files instanceof Object) || (typeof(files) == "string") ||
               (files instanceof String)) {
        file_list = [files];
    } else {
        throw new Error("Wrong input format is provided for 'files' argument.");
    }

    var process_response = function(file_name, data, callback) {
        if ( (data.info !== undefined) && (data.info !== null) ) {
            callback(null, true);
        } else {
            callback(null, false);
        }
    }

    const numFiles = file_list.length;

    // Parsing client-given destination
    var dest_path = this.parse_dir_destination(destination);

    const toBase64 = (file) =>
          new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.readAsDataURL(file);
              reader.onload = () => {
                  const regex = /data:(.*);(.*),(.*)/gi;
                  const match = regex.exec(reader.result);
                  const data = match[3];
                  return resolve(data);
              };
              reader.onerror = (error) => reject(reader.error);
          });

    for (let i = 0; i < numFiles; i++) {
        const file = file_list[i];
        // Handle paths for the files to be uploaded
        if (typeof(file) == "string" || file instanceof String) {
            const file_name = dest_path + GPUdb.FileHandler.extract_filename(file, '/');
            var content = require("fs").readFileSync(file, 'utf8');
            const file_data = Buffer.from(content).toString('base64');
            this.gpuDB.upload_files([file_name], [file_data], options, function(error, response) {
                if (error === null) {
                    process_response(file_name, response, callback);
                } else {
                    console.error(error);
                    callback(error, null);
                }
            });
        } else if ( (typeof(file) == "object") && (file !== null)
                    && (file.name !== undefined) && (file.name !== null) ) {
            // Handle file objects
            const file_name = dest_path + GPUdb.FileHandler.extract_filename(file.name, ':');
            toBase64(file).then(file_data => {
                this.gpuDB.upload_files([file_name], [file_data], options, function(error, response) {
                    if (error === null) {
                        process_response(file_name, response, callback);
                    } else {
                        console.error(error);
                        callback(error, null);
                    }
                });
            }).catch(error => {
                console.error(error);
                callback(error, null);
            });
        } else {
            var msg = "One of 'files' argument values was provided in "
                + "a bad format. Only Array of Files or Array of "
                + "string filepaths are allowed as 'files' value.";
            callback( new Error( msg ), null );
        }
    }
};  // end upload


/**
 * Downloads the list of files from KIFS to local filesystem.
 *
 * @param {Array} filenames     Filepaths for KIFS files to be downloaded.
 * @param {Map} options         Download options.  A placeholder for future
 *                              options.
 *
 * @returns {Promise} A promise that will be fulfilled with object,
 *                    if no callback function is provided.  Returns
 *                    an array containing base64 file data.
 */
GPUdb.FileHandler.prototype.download = function( filenames, options, callback ) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.download(filenames, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }
    options = this.parse_options(options, "download");

    let file_names;
    if (!(filenames instanceof Array) && (typeof(filenames) == "string")) {
        file_names = [filenames];
    } else if ( (filenames instanceof Array)
                && (filenames.length > 0)
                && (typeof(filenames[0]) == "string") ) {
        file_names = filenames;
    } else {
        throw new Error("One of the 'files' arguments is not a string filepath " +
                        "and is unsafe to process. Wrong input format is provided.");
    }

    // Simply pass the array containing file data to the callback function
    var process_response = function(data, callback) {
        callback( null, data.file_data );
    }

    // Actually call /download/files
    this.gpuDB.download_files(file_names, [], [], options, function(err, data) {
        if (err === null) {
            process_response(data, callback);
        } else {
            callback(err, null);
        }
    });

};  // end download


/**
 * Downloads the list of files from KIFS to local filesystem.
 *
 * @param {Array} filenames     Filepaths for KIFS files to be downloaded.
 * @param {String} destination  Destination FS local path
 * @param {Map} options         Download options  A placeholder for future
 *                              options.
 *
 * @returns {Promise} A promise that will be fulfilled with the response object,
 *                    if no callback function is provided.
 */
GPUdb.FileHandler.prototype.download_and_save = function( filenames, destination, options, callback ) {
    if (callback === undefined || callback === null) {
        // When no callback is given, use a promise and call this method
        // recursively
        var self = this;

        return new Promise(function(resolve, reject) {
            self.download_and_save(filenames, destination, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    options = this.parse_options(options, "download");
    var dest_path = this.parse_dir_destination(destination);
    if (!require("fs").existsSync(dest_path)){
        require("fs").mkdirSync(dest_path);
    }

    let file_names;
    if (!(filenames instanceof Array) && (typeof(filenames) == "string")) {
        file_names = [filenames];
    } else if ( (filenames instanceof Array)
                && (filenames.length > 0)
                && (typeof(filenames[0]) == "string") ) {
        file_names = filenames;
    } else {
        throw new Error("One of the 'files' arguments is not a string filepath " +
                        "and is unsafe to process. Wrong input format is provided.");
    }

    // Write each file and then invoke the callback
    var process_response = function(data, callback) {
        if ((data.file_names instanceof Array) &&
            (data.file_data instanceof Array) &&
            (data.file_names.length == data.file_data.length) ) {
            var numFiles = data.file_names.length;

            // Promisify the async file write method
            const fs = require("fs");
            const util = require("util");
            let writeFilePromise = util.promisify( fs.writeFile );

            // We need to create a promise per downloaded file
            var write_promises = [];
            for (let i = 0; i < numFiles; i++) {
                var file_name = GPUdb.FileHandler.extract_filename(data.file_names[i], '/');
                const new_file_name = dest_path + file_name;
                var content = Buffer.from(data.file_data[i], 'base64').toString();
                var promise = writeFilePromise( new_file_name, content );
                write_promises.push( promise );
            }

            // Wait for all the promises to resolve before invoking the callback
            Promise.all( write_promises )
                .then( function() {
                    // All is well
                    callback( null, true );
                } ) // all is well
                .catch( function() {
                    // Some problem occurred!
                    callback( null, false );
                } );
        } else {
            // There's a problem
            callback( null, false );
        }
    }

    // Actually call /download/files
    this.gpuDB.download_files(file_names, [], [], options, function(err, data) {
        if (err === null) {
            process_response(data, callback);
        } else {
            callback(err, null);
        }
    });

};  // end download_and_save


// /**
//  * Retrieves the KIFS files details.
//  * Returns an array of KifsFileInfo objects
//  *
//  * @param {Array} paths     Filepaths for KIFS directories to show.
//  * @param {Map} options         Download options
//  *
//  * @returns {Array}   An Array of KifsFileInfo  objects.
//  */
// GPUdb.FileHandler.prototype.show_files = function( paths, options, callback ) {
//     if (callback === undefined || callback === null) {
//         var self = this;

//         return new Promise(function(resolve, reject) {
//             self.show_files(paths, options, function(err, response) {
//                 if (err !== null) {
//                     reject(err);
//                 } else {
//                     resolve(response);
//                 }
//             });
//         });
//     }
//     var call_paths = (paths instanceof Array)? paths : [paths];

//     if (options == undefined || options == null) {
//         options = {};
//     }

//     var process_response = function(data, callback) {
//         var kifsFileInfo = [];
//         if (data.file_names !== undefined && data.file_names !== null) {
//             for (i=0; i<data.file_names.length; i++) {
//                 var kifsFile = {};

//                 kifsFile.file = (data.file_names.length>i) ? data.file_names[i] : null;
//                 kifsFile.size = (data.sizes.length>i) ? data.sizes[i] : null;
//                 kifsFile.creation_time = (data.creation_times.length>i) ? data.creation_times[i] : null;
//                 kifsFile.created_by = (data.users.length>i) ? data.users[i] : null;
//                 // kifsFile.info = data.info;

//                 kifsFileInfo[i] = kifsFile;
//             }
//             callback(null, kifsFileInfo);
//         } else {
//             paths_list = "[" + call_paths.concat(", ") + "]";
//             callback(new Error("Show files failed for paths " + paths_list + "."), null);
//         }
//     }
//     console.log(this);
//     this.gpuDB.show_files(call_paths, options, function(err, data) {
//         if (err === null) {
//             process_response(data, callback);
//         } else {
//             callback(err, null);
//         }
//     });
// };

// /**
//  * Retrieves the KIFS directory details.
//  * Returns an array of KifsDirectoryInfo objects
//  *
//  * @param {Array} directory_name   Name of the KIFS directory to show.
//  * @param {Map} options            Download options
//  *
//  * @returns {Array}   An Array of KifsDirectoryInfo objects.
//  */
// GPUdb.FileHandler.prototype.show_directories = function( directory_name, options, callback ) {
//     if (callback === undefined || callback === null) {
//         var self = this;

//         return new Promise(function(resolve, reject) {
//             self.show_directories(directory_name, options, function(err, response) {
//                 if (err !== null) {
//                     reject(err);
//                 } else {
//                     resolve(response);
//                 }
//             });
//         });
//     }
//     if (options == undefined || options == null) {
//         options = {};
//     }

//     var process_response = function(data, callback) {
//         var kifsDirInfo = [];
//         if (data.directories !== undefined && data.directories !== null) {
//             for (i=0; i<data.directories.length; i++) {
//                 var kifsDir = {};

//                 kifsDir.directory = (data.directories.length>i) ? data.directories[i] : null;
//                 kifsDir.permissions = (data.permissions.length>i) ? data.permissions[i] : null;
//                 kifsDir.creation_time = (data.creation_times.length>i) ? data.creation_times[i] : null;
//                 kifsDir.created_by = (data.users.length>i) ? data.users[i] : null;
//                 // kifsDir.info = data.info;

//                 kifsDirInfo[i] = kifsDir;
//             }
//             callback(null, kifsDirInfo);
//         } else {
//             callback(Error("Directory " + directory_name + " does not exist."), null);
//         }
//     };
//     this.gpuDB.show_directories(directory_name, options, function(err, data) {
//         if (err === null) {
//             process_response(data, callback);
//         } else {
//             callback(err, null);
//         }
//     });

// };

// /**
//  * Creates a KIFS directory.
//  * Returns true/false for the success of operation
//  *
//  * @param {Array} directory_name   Name of the KIFS directory to show.
//  * @param {Map} options            Download options
//  *
//  * @returns {boolean} If the operation was successful, returns true,
//  *                    otherwise false.
//  */
// GPUdb.FileHandler.prototype.create_directory = function( directory_name, no_error_if_exists, callback ) {
//     if (callback === undefined || callback === null) {
//         var self = this;

//         return new Promise(function(resolve, reject) {
//             self.create_directory(directory_name, no_error_if_exists, function(err, response) {
//                 if (err !== null) {
//                     reject(err);
//                 } else {
//                     resolve(response);
//                 }
//             });
//         });
//     }

//     var options = {};
//     options.no_error_if_exists = this.parse_flag_to_str(no_error_if_exists, "true");

//     var process_response = function(response, callback) {
//         if (response.directory_name != directory_name) {
//             callback(null, false);
//         }
//         console.log("Directory " + directory_name + " was created.");
//         callback(null, true);
//     };

//     this.gpuDB.create_directory(directory_name, options, function(err, data) {
//         if (err === null) {
//             process_response(data, callback);
//         } else {
//             callback(err, null);
//         }
//     });
// };

GPUdb.FileHandler.prototype.parse_flag_to_str = function(value, default_value) {
    if (value !== undefined && value !== null) {
        if ((typeof value) == "boolean") {
            // Converting received boolean value to string
            return (value ? "true" : "false");
        } else if ((typeof value) == "string"){
            return value;
        } else {
            return default_value;
        }
    } else {
        return default_value;
    }
};

GPUdb.FileHandler.extract_filename = function(full_path, sep) {
    var filename_parts = full_path.split(sep);
    return filename_parts[filename_parts.length-1];
};


GPUdb.FileHandler.prototype.parse_dir_destination = function(destination) {
    var result = {};
    if (destination !== undefined && destination !== null
        && (typeof destination) == "string") {

        const first_slash_pos = destination.indexOf("/");
        if (first_slash_pos != 0) {
            // Empty path or path that does not start with a slash
            // Add the slash to path
            destination = "/" + destination;
        }

        const last_slash_pos = destination.lastIndexOf("/");
        if (last_slash_pos != destination.length-1 ) {
            destination = destination + "/";
        }
        return destination;
    } else {
        return "/";
    }
};

// GPUdb.FileHandler.prototype.parse_destination_with_renaming = function(destination) {
//     var result = {};
//     if (destination !== undefined && destination !== null
//         && (typeof destination) == "string") {

//         first_slash_pos = destination.indexOf("/");

//         if (first_slash_pos != 0) {
//             // Empty path or path that does not start with a slash
//             // Add the slash to path
//             destination = "/" + destination;
//         }
//         last_slash_pos = destination.lastIndexOf("/");

//         if ((destination.length == 0) || (last_slash_pos == destination.length-1) ) {
//             result.dest_path = destination;
//             result.dest_filename = null;
//         } else {
//             // path ends with some block of characters,
//             // filename or directory (can be hidden)
//             potential_filename = destination.substring(last_slash_pos+1);

//             if (potential_filename.lastIndexOf(".") <= 0 ||
//                 potential_filename.lastIndexOf(".")+1 != potential_filename.length) {
//                 // The name in question does not contain a dot
//                 // or the dot denotes hidden directory,
//                 // or it's a trailing dot
//                 result.dest_path = destination;
//             } else {
//                 // Found a dot in last chunk of destination path, it's a filename
//                 result.dest_path = destination.substring(0,last_slash_pos);
//                 result.dest_filename = potential_filename;
//             }
//         }
//     } else {
//         result.dest_path = "/";
//         result.dest_filename = null;
//     }
//     return result;
// };


GPUdb.FileHandler.prototype.parse_options = function(incoming_options, endpoint) {
    var options = {};
    var default_file_encoding = 'base64';
    switch(endpoint) {
    case "upload":
        options.file_encoding = default_file_encoding;
        break;
    case "download":
        options.file_encoding = default_file_encoding;
        break;
    }
    return options;
};
